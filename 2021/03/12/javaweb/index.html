<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="blog,java,mybatis,spring,web">
    <meta name="description" content="java,web,spring,mybatis,vue,jquery,博客，blog，html,http">
    <meta name="author" content="ShiJh">
    
    <title>
        
            Java Web |
        
        ShiJhBlogs
    </title>
    <link rel="stylesheet" href="/css/style.css">
    <link rel="shortcut icon" href="/images/logo.svg">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.1/source/css/font-awesome.min.css">
    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"blog.pressed.top","root":"/","language":"zh-CN","path":"search.json"};
    KEEP.theme_config = {"toc":{"enable":true,"number":false,"expand_all":true,"init_open":true},"style":{"primary_color":"#0066CC","avatar":"https://avatars.githubusercontent.com/u/55338151?s=60&v=4","favicon":"/images/logo.svg","article_img_align":"left","left_side_width":"300px","content_max_width":"920px","hover":{"shadow":false,"scale":true},"first_screen":{"enable":true,"background_img":"/images/bg.svg","description":"Keep learning Keep loving"},"scroll":{"progress_bar":{"enable":false},"percent":{"enable":false}}},"local_search":{"enable":true,"preload":false},"code_copy":{"enable":true,"style":"default"},"pjax":{"enable":true},"lazyload":{"enable":false},"version":"3.4.1"};
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 月前","year":"%s 年前"};
  </script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
<div class="progress-bar-container">
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fas fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            <a class="logo-title" href="/">
                ShiJhBlogs
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                归档
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                分类
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/tags"
                            >
                                标签
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/links"
                            >
                                友链
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/about"
                            >
                                关于
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">归档</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories">分类</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags">标签</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/links">友链</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/about">关于</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">Java Web</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="https://avatars.githubusercontent.com/u/55338151?s=60&v=4">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">ShiJh</span>
                        
                            <span class="author-label">Lv2</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;2021-03-12 00:00:00
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/%E5%90%8E%E7%AB%AF/">后端</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/web/">web</a>&nbsp;
                    </li>
                
                    <li>
                        | <a href="/tags/java/">java</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i>&nbsp;<span>8.2k 字</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i>&nbsp;<span>32 分钟</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <p>从零开始学JAVA web，我学了些什么，这篇文章将会记录这一段学习历程。(暂告一段落)</p>
<span id="more"></span>
<h1>JavaWeb-Spring</h1>
<blockquote>
<p>GitHub：<a class="link"   target="_blank" rel="noopener" href="https://github.com/838239178/SpringStudy" >Spring学习过程中创建的项目，包含一些例子<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
<h2 id="一​、🚶JavaSE"><a class="header-anchor" href="#一​、🚶JavaSE">○</a>一​、🚶JavaSE</h2>
<ul>
<li>[x] Java语言基础内容，已经掌握</li>
</ul>
<h2 id="二、🐴JSP-Servlet"><a class="header-anchor" href="#二、🐴JSP-Servlet">○</a>二、🐴JSP/Servlet</h2>
<p>主要以理解Tomcat中Servlet的运行原理为重点</p>
<h3 id="JSP"><a class="header-anchor" href="#JSP">○</a>JSP</h3>
<p>Jsp本质是servlet，约等于分不清前后端，耦合性太强，已经被时代抛弃，大概了解即可，直接跳过学习。</p>
<h4 id="JSTL"><a class="header-anchor" href="#JSTL">○</a>JSTL</h4>
<p>JavaServer Pages Tag Library ：JSP标准标签库</p>
<p>用于简化和替换jsp页面上的java 代码</p>
<h3 id="Servlet"><a class="header-anchor" href="#Servlet">○</a>Servlet</h3>
<ul>
<li>
<p><strong>Servlet</strong>:</p>
<p>注解声明<code>@WebServlet(&quot;path&quot;)</code></p>
<p>tomcat服务器的核心，主要是理解Http协议、<code>HttpServletRequest</code>以及<code>HttpServletResponse</code>原理。req可以进行转发<code>forward</code>（服务器内servlet间转发），resp可以进行重定向<code>redirect</code>(由浏览器发送第二次请求，可跨服务器)</p>
</li>
<li>
<p><strong>Filter</strong>：</p>
<p>注解声明<code>@WebFilter(&quot;path&quot;)</code></p>
<p>过滤器，拦截request和response，可以对req和resp进行判断是否放行。</p>
</li>
<li>
<p><strong>Listener</strong>：</p>
<p>注解声明<code>@WebListener</code></p>
<p>监听器，<code>ServletContextListener</code>监听ServletContext对象的创建（服务器启动）和销毁（服务器关闭），该接口主要用于加载资源和释放资源等操作。除此之外还有其他监听器。</p>
</li>
<li>
<p>ServletContext：</p>
<p>服务器内的一个全局上下文，可以从servlet或req中获取（单例类）。作用是获取服务器真实路径<code>getRealPath()</code>、设置和获取服务器内共享的数据域<code>set/getAttribute()</code>和获取Content-type<code>getMimeType(filename)</code>，通过配置<code>&lt;context-param&gt;</code>可以用<code>getInitParam()</code>来加载资源文件</p>
</li>
<li>
<p>Cookie：保存于浏览器的数据，用来识别身份，保存sessionid等。可以设置存活周期。</p>
</li>
<li>
<p>Session：保存于服务器的数据，用来记录每个浏览器特定的信息，由一个id对应。可以设置存活周期，服务器关闭后会<code>钝化</code>，再次开启后<code>活化</code></p>
</li>
</ul>
<h3 id="EL表达式"><a class="header-anchor" href="#EL表达式">○</a>EL表达式</h3>
<p>语法：<code>$&#123;expression&#125;</code></p>
<ol>
<li>
<p>运算</p>
<p>算数运算、比较运算、逻辑运算、判空运算<code>empty</code></p>
</li>
<li>
<p><strong>获取值</strong></p>
<p>从域对象中获取值<code>$&#123;域名称.keyName&#125;</code>、<code>$&#123;keyName&#125;</code></p>
<table>
<thead>
<tr>
<th>域名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>pageScope</td>
<td>从pageContext获取</td>
</tr>
<tr>
<td>requestScope</td>
<td>从request中获取</td>
</tr>
<tr>
<td>sessionScope</td>
<td>从session中获取</td>
</tr>
<tr>
<td>applicationScope</td>
<td>从ServletContext获取</td>
</tr>
</tbody>
</table>
</li>
</ol>
<h3 id="ExtraDetail"><a class="header-anchor" href="#ExtraDetail">○</a>ExtraDetail</h3>
<p>这里记录在学习这个模块的过程中额外学习到的内容。</p>
<h4 id="ProxyMode"><a class="header-anchor" href="#ProxyMode">○</a>ProxyMode</h4>
<p>代理模式，软件设计模式的一种，通过中间代理执行方法，来达到增强的目的。后续框架中经常使用该模式。</p>
<p>动态代理在Java中使用</p>
<pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Proxy</span></span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">newProxyInstance</span><span class="hljs-params">(ClassLoader loader, Class&lt;?&gt;[] interfacies, InvocationHandler h)</span></span>&#123;&#125;
&#125;</code></pre>
<p>其中<code>InvocationHandler</code>是抽象类，需实现</p>
<pre><code class="hljs java"><span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;&#125;</code></pre>
<p>通过在该方法中调用<code>method.invoke(obj,args)</code>来执行被代理的对象的方法。可以<strong>修改返回值</strong>或者<strong>参数</strong>等手段来增强该方法，也可以在方法调用前和调用后增加其他类的方法。</p>
<h4 id="MVC开发模式"><a class="header-anchor" href="#MVC开发模式">○</a>MVC开发模式</h4>
<ol>
<li>
<p><strong>M:</strong> Model 模型 <code>JavaBean</code></p>
<p>完成业务逻辑操作，如查询数据库、封装数据</p>
</li>
<li>
<p><strong>V:</strong> View 视图 <code>jsp</code></p>
<p>展示数据</p>
</li>
<li>
<p><strong>C:</strong> Controller 控制器 <code>servlet</code></p>
<p>分发工作，获取客户端的输入然后调用模型，将数据交给视图。</p>
</li>
</ol>
<h4 id="三层架构"><a class="header-anchor" href="#三层架构">○</a>三层架构</h4>
<ol>
<li>
<p>界面层（表示层 web）<code>SpringMVC</code></p>
<p>用户能够通过界面的组件和服务器进行交互，调用Service完成请求处理，转发jsp页面完成显示。</p>
<ul>
<li>控制器：servlet，接受用户请求并封装参数信息到Servic层</li>
<li>视图：JSP，接受控制器提供的数据并展示出来给用户</li>
</ul>
</li>
<li>
<p>业务逻辑层 (service) <code>Spring</code></p>
<p>处理业务逻辑，组合DAO层的简单方法，组成各种复杂的业务功能。</p>
</li>
<li>
<p>数据访问层 (dao) <code>MyBatis</code></p>
<p>操作数据存储文件，定义了对数据库最基本的CRUD操作</p>
</li>
</ol>
<h4 id="Bootstrap-JQuery-AJAX"><a class="header-anchor" href="#Bootstrap-JQuery-AJAX">○</a>Bootstrap/JQuery/AJAX</h4>
<p>皆为前端框架</p>
<ul>
<li>
<p>Boostrap</p>
<p>提供丰富的html标签和css样式，具有响应式布局，配合JQuery/Vue使用。</p>
</li>
<li>
<p>JQuery</p>
<p>对js的封装，提供了选择器等许多丰富API来帮助编写js动态生成页面。</p>
</li>
<li>
<p>AJAX</p>
<p>异步的JavaScript和XML，用于向服务器发送异步请求，可以在JQuery/Vue中便捷使用。</p>
</li>
</ul>
<h2 id="三​、🚲JDBC-SQL"><a class="header-anchor" href="#三​、🚲JDBC-SQL">○</a>三​、🚲JDBC/SQL</h2>
<p>两者是数据库的重要内容，SQL有<code>MySQL、SQLserver</code>等，<code>JDBC</code>则是Java操作数据库SQL的重要API，都应熟练掌握并理解原理。</p>
<h3 id="MySQL"><a class="header-anchor" href="#MySQL">○</a>MySQL</h3>
<p>学会数据库增删查改等操作，熟练运用操控数据库的高级技巧，重点理解数据库原理，学会优化数据库。</p>
<h4 id="事务"><a class="header-anchor" href="#事务">○</a>事务</h4>
<h5 id="基本介绍"><a class="header-anchor" href="#基本介绍">○</a>基本介绍</h5>
<p>事务指的是一个包含多个步骤的业务操作，如果这个操作被事务管理，则要么同时成功，要么同时失败。事务可以提供回滚操作，撤销出错的影响。</p>
<ul>
<li><code>ＳＴＡＲＴ　ＴＲＡＮＳＡＣＴＩＯＮ</code>　开启事务管理</li>
<li><code>ＲＯＬＬＢＡＣＫ</code>　回滚</li>
<li><code>ＣＯＭＭＩＴ</code>　提交事务</li>
</ul>
<p><code>SELECT @@autocommit</code> 查看是否为自动提交，修改后可以改变默认管理方式</p>
<h5 id="四大特征"><a class="header-anchor" href="#四大特征">○</a>四大特征</h5>
<ul>
<li>原子性：数据库操作中不可分割的最小单位，要么同时成功，要么同时失败</li>
<li>持久性：事务提交或回滚后，数据会持久化保存在数据库中</li>
<li>隔离性：多个事务之间相互独立</li>
<li>一致性：事务操作前后，数据总量不变</li>
</ul>
<h5 id="隔离级别"><a class="header-anchor" href="#隔离级别">○</a>隔离级别</h5>
<p>多个事务操作同一批数据会引发一些问题，通过设置隔离级别可以解决这些问题。</p>
<ul>
<li>脏读：一个事务，读取到另一个事务中没有提交的数据。</li>
<li>不可重复读：同一个事务中，两次读取到的数据不一样（可能被另一个事务修改了）<a class="link"   target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/55872397" >MySql-MVCC原理<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%B9%BB%E8%AF%BB/153502?fr=aladdin" >幻读<i class="fas fa-external-link-alt"></i></a>：一个事务(同一个read view)在前后两次查询同一范围的时候，后一次查询看到了前一次查询没有看到的行。</li>
</ul>
<table>
<thead>
<tr>
<th>级别</th>
<th>说明</th>
<th>安全性</th>
</tr>
</thead>
<tbody>
<tr>
<td>read uncommitted</td>
<td>读未提交，允许读取未提交的数据</td>
<td>0</td>
</tr>
<tr>
<td>read committed</td>
<td>当前读、读已提交，只有已经提交的数据才能被读取</td>
<td>1</td>
</tr>
<tr>
<td>repeatable read</td>
<td>可重复读，使一个事务周期内的数据不受其他事务影响</td>
<td>2</td>
</tr>
<tr>
<td>serializable</td>
<td>串行化，锁定一张表，相当于单线程执行事务</td>
<td>3</td>
</tr>
</tbody>
</table>
<p><em>从小到大安全性越来越高，效率越来越低！不同的数据库隔离级别原理不同，如MySql的MMVC，因此能解决的问题也不同</em></p>
<p>通过<code>SELECT @@tx_isolation</code>查询隔离级别，<code>SET GLOBAL TRANSACTION ISOLATION LEVEL 级别名</code>设置隔离级别</p>
<h3 id="JDBC"><a class="header-anchor" href="#JDBC">○</a>JDBC</h3>
<p>JDBC是Java用来操作数据库的接口，具体实现由不同数据库公司实现，他的实现类被称为**“驱动”（Driver）**。</p>
<p><strong>常见驱动类：</strong></p>
<ul>
<li>MySql：“com.mysql.jdbc.Driver”</li>
<li>SqlServer：“com.microsoft.sqlserver.jdbc.SQLServerDriver”</li>
</ul>
<h4 id="使用方法"><a class="header-anchor" href="#使用方法">○</a>使用方法</h4>
<ol>
<li>
<p>注册驱动</p>
<pre><code class="hljs java"><span class="hljs-comment">/*</span>
<span class="hljs-comment"> 通过该方法把类加载到内存</span>
<span class="hljs-comment"> 驱动类来自每个不同的数据库公司，以下是mysql的驱动类</span>
<span class="hljs-comment"> 该方法执行时，类的静态代码块会被执行，Driver会使用registerDriver方法注册DriverManager</span>
<span class="hljs-comment"> mysql5以上的版本可以省略这个注册过程</span>
<span class="hljs-comment">*/</span>
Class.forName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>);</code></pre>
</li>
<li>
<p>获取数据库连接对象</p>
<pre><code class="hljs java"><span class="hljs-keyword">import</span> java.sql.*;
<span class="hljs-comment">/*</span>
<span class="hljs-comment"> url: 数据库地址 jdbc:mysql://域名:端口/dbName</span>
<span class="hljs-comment"> user: 管理员用户名</span>
<span class="hljs-comment"> pwd: 管理员密码</span>
<span class="hljs-comment">*/</span>
Connection conn = DriverManager.getConnection(url,user,pwd);</code></pre>
</li>
<li>
<p>定义sql语句<code>String</code></p>
</li>
<li>
<p>获取执行sql对象</p>
<pre><code class="hljs java"><span class="hljs-keyword">import</span> java.sql.*;
<span class="hljs-comment">//satement 可以执行sql语句</span>
Statement stat = conn.createStatement();</code></pre>
</li>
<li>
<p>执行sql获取返回结果</p>
<pre><code class="hljs java"><span class="hljs-comment">//sqlStr 为数据库执行语句，如DML(insert、update、delete)、DDL(create、alter、drop)</span>
<span class="hljs-comment">//返回影响的行数：可以通过这个值判断DML语句是否执行成功</span>
stat.excuteUpdate(sqlStr);</code></pre>
</li>
<li>
<p>释放资源</p>
<pre><code class="hljs java"><span class="hljs-comment">//执行对象释放</span>
stat.close();
<span class="hljs-comment">//数据库连接释放</span>
conn.close();
<span class="hljs-comment">//结果对象释放</span>
resultSet.close();</code></pre>
</li>
</ol>
<h4 id="常用对象详解"><a class="header-anchor" href="#常用对象详解">○</a>常用对象详解</h4>
<p><strong>Connection：</strong></p>
<ul>
<li>
<p>获取sql对象</p>
<p><code>createStatement()</code>、<code>preparedStatement(sqlStr)</code></p>
</li>
<li>
<p>管理事务</p>
<p>关闭自动提交事务的功能即可开启手动事务管理</p>
<p>开启：<code>setAutoCommit(false)</code>、提交：<code>commit()</code>、回滚：<code>rollback()</code></p>
</li>
</ul>
<p><strong>Statement：</strong></p>
<ul>
<li><code>excuteUpdate(sql)</code>：执行DML(insert、update、delete)、DDL(create、alter、drop)，返回影响的行数</li>
<li><code>executeQuery(sql)</code>：执行DQL(select)语句，返回<code>ResultSet</code></li>
</ul>
<p><strong>ResultSet：</strong></p>
<ul>
<li>
<p><code>next()</code>：移动游标到下一行，游标初始于第0行（表头），如果下一行没有数据则返回false</p>
</li>
<li>
<p><code>getXxx(int/str)</code></p>
<p>获取当前行的数据，<code>Xxx</code>为数据类型名，返回类型为<code>Xxx</code></p>
<p>方法指定参数为int时，表示columIndex获取第几列的数据</p>
<p>方法指定参数为str时，表示columName获取名为str的列的数据</p>
</li>
</ul>
<p><strong>PreparedStatement：</strong></p>
<ul>
<li>
<p>解决SQL注入问题</p>
<p>某些sql特殊关键字参与字符串拼接会造成安全性问题，如<code>WHERE</code>后存在恒等式则表示没有约束作用</p>
</li>
<li>
<p>预编译sql</p>
<p>sql语句的参数使用<code>？</code>占位符，使用<code>setXxx(pos, value)</code>方法赋值，该方法传入占位符的位置（第几个）和值来进行sql参数补充，value类型为<code>Xxx</code></p>
</li>
<li>
<p><code>excuteUpdate()</code></p>
</li>
<li>
<p><code>executeQuery()</code></p>
</li>
</ul>
<h4 id="事务管理"><a class="header-anchor" href="#事务管理">○</a>事务管理</h4>
<p>事务指的是一个包含多个步骤的业务操作，如果这个操作被事务管理，则要么同时成功，要么同时失败。</p>
<ul>
<li>开启 提交 回滚 <a href="#%E5%B8%B8%E7%94%A8%E5%AF%B9%E8%B1%A1%E8%AF%A6%E8%A7%A3">使用Connection管理</a></li>
</ul>
<h5 id="使用方法-v2"><a class="header-anchor" href="#使用方法-v2">○</a>使用方法</h5>
<pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;
    conn.setAutoCommit(<span class="hljs-keyword">false</span>); <span class="hljs-comment">//open</span>
    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> do sql</span>
    conn.commit(); <span class="hljs-comment">//commit if no exception occur</span>
&#125; <span class="hljs-keyword">catch</span> (Exception e)&#123;
    conn.rollback(); <span class="hljs-comment">//rollback if has any exception </span>
&#125;</code></pre>
<p>当<code>rollback()</code>执行时，刚刚执行的sql操作都会撤销。</p>
<h4 id="数据库连接池"><a class="header-anchor" href="#数据库连接池">○</a>数据库连接池</h4>
<p>优化Connection操作，提高数据库访问性能</p>
<h5 id="原理"><a class="header-anchor" href="#原理">○</a>原理</h5>
<p>使用连接对象容器管理Connection，从容器中获取，归还到容器中去，由容器管理是否断开连接。</p>
<h5 id="实现方法"><a class="header-anchor" href="#实现方法">○</a>实现方法</h5>
<p>*Interface <strong>DataSource</strong>：*由<a href="#JDBC">Driver</a>实现，Druid性能较高</p>
<ol>
<li>
<p><strong>C3P0</strong>：ComboPooledDataSource</p>
<p>使用classpath:<code>c3p0.properties/c3p0-config.xml</code>配置参数</p>
</li>
<li>
<p><strong>Druid</strong>：DruidDataSourceFactory</p>
<p>使用<code>druid.properties</code>配置参数，需要手动加载。通常封装成工具类静态加载配置文件。</p>
</li>
</ol>
<h4 id="Spring-JdbcTemplete"><a class="header-anchor" href="#Spring-JdbcTemplete">○</a>Spring JdbcTemplete</h4>
<p>由Spring封装的JDBCUtils，简化操作。<a href="#Spring-JdbcTemplate">详细见下文</a></p>
<h3 id="Junit4"><a class="header-anchor" href="#Junit4">○</a>Junit4</h3>
<p>Junit单元测试属于白盒测试的一种。</p>
<h4 id="注解"><a class="header-anchor" href="#注解">○</a>注解</h4>
<table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>@Before</td>
<td>在所有测试方法前执行</td>
</tr>
<tr>
<td>@After</td>
<td>在所有测试方法后执行，无论是否存在异常</td>
</tr>
<tr>
<td>@Test</td>
<td>标注方法为测试方法</td>
</tr>
</tbody>
</table>
<h4 id="测试方法"><a class="header-anchor" href="#测试方法">○</a>测试方法</h4>
<p>所有测试方法都是无参的，测试方法内最好不要直接输出数值，应该尽量使用<code>assert</code>断言结果于预期是否相符合。对于测试期间出现的异常应该尽量捕获并写入文件中，标明异常方法和异常原因。</p>
<h3 id="Redis-Jedis"><a class="header-anchor" href="#Redis-Jedis">○</a>Redis/Jedis</h3>
<p>非关系型数据库，有缓存功能。。。</p>
<h2 id="四、🚗SSM"><a class="header-anchor" href="#四、🚗SSM">○</a>四、🚗SSM</h2>
<p>JavaWeb框架集合之一，由<code>Spring+SpringMVC+Mybatis</code>组成，适用于轻量级微服务开发，要深入理解原理。</p>
<h3 id="Spring"><a class="header-anchor" href="#Spring">○</a>Spring</h3>
<p>Spring框架属于Service层框架，但是也管理了Web层和DAO层</p>
<h4 id="IOC"><a class="header-anchor" href="#IOC">○</a>IOC</h4>
<h5 id="ioc容器"><a class="header-anchor" href="#ioc容器">○</a>ioc容器</h5>
<p>Bean容器，spring在内部创建Java类，我们或Spring可以从容器中取出Bean</p>
<h5 id="XML式依赖注入"><a class="header-anchor" href="#XML式依赖注入">○</a>XML式依赖注入</h5>
<p>对<code>&lt;bean id=&quot;&quot; class=&quot;&quot;&gt;&lt;/bean&gt;</code>对象的属性进行配置</p>
<p>分别为：对象注入<code>ref</code>、普通数据类型注入<code>value</code>、集合类型</p>
<ul>
<li>
<p>集合类型：配置文件使用<code>&lt;list&gt;&lt;value&gt;</code>、<code>&lt;map&gt;&lt;entry key=&quot;&quot; value-ref=&quot;&quot;&gt;</code>、<code>&lt;props&gt;&lt;prop key=&quot;&quot;&gt;</code>组合使用</p>
</li>
<li>
<p>构造方法：有参构造，配置文件中使用<code>&lt;constructor-arg name=&quot;&quot; ref=&quot;&quot;/&gt;</code>注入</p>
</li>
<li>
<p>set方法：配置文件中使用<code>&lt;property name=&quot;&quot; ref=&quot;&quot;/&gt;</code>子标签标签设置属性值注入</p>
</li>
</ul>
<p><strong>模块开发</strong></p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;applicationContext-xxx.xml&quot;</span> /&gt;</span></code></pre>
<h5 id="注解式依赖注入"><a class="header-anchor" href="#注解式依赖注入">○</a>注解式依赖注入</h5>
<ol>
<li>
<p><strong>原始注解</strong></p>
<p>使用前须在配置文件中配置组件扫描，指定需要注解开发的包</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span>
    <span class="hljs-comment">&lt;!--用于排除不需要被扫描的类--&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">context:exclude-filter</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;&quot;</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span></code></pre>
<table>
<thead>
<tr>
<th style="text-align:left">注解</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">@Component</td>
<td>类上实例化Bean，代替Bean标签</td>
</tr>
<tr>
<td style="text-align:left">@Controller</td>
<td>web层类上实例化Bean</td>
</tr>
<tr>
<td style="text-align:left">@Respository</td>
<td>dao层上实例化Bean</td>
</tr>
<tr>
<td style="text-align:left">@Service</td>
<td>service层上实例化Bean</td>
</tr>
<tr>
<td style="text-align:left">@Autowired</td>
<td>依赖注入标签，加在成员变量/setter/构造方法</td>
</tr>
<tr>
<td style="text-align:left">@Qualifier</td>
<td>结合Autowired一起使用根据名称进行依赖注入</td>
</tr>
<tr>
<td style="text-align:left">@Resource</td>
<td>相当于前两者的结合，是javaEE的注解，不是Spring的注解</td>
</tr>
<tr>
<td style="text-align:left">@Value</td>
<td>注入普通属性（int等）</td>
</tr>
<tr>
<td style="text-align:left">@PostConstruct</td>
<td>声明Bean的初始化方法</td>
</tr>
<tr>
<td style="text-align:left">@PreDestroy</td>
<td>声明Bean的销毁方法</td>
</tr>
<tr>
<td style="text-align:left">@Scope</td>
<td>标志Bean的范围，singleton/prototype</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><strong>新注解</strong></p>
<p>可以完全替代xml配置文件</p>
<table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>@Configuration</td>
<td>指定类为配置类，创建容器时从该类上加载注解</td>
</tr>
<tr>
<td>@ComponentScan</td>
<td>指定要扫描的包，同<code>&lt;context:componnet-scan&gt;</code>，使用excludeFilters排除不需要被扫描的类</td>
</tr>
<tr>
<td>@Bean</td>
<td>标注方法的返回值储存于容器中</td>
</tr>
<tr>
<td>@PropertySource</td>
<td>用于加载<code>.properties</code>文件的配置</td>
</tr>
<tr>
<td>@Import</td>
<td>用于导入其他配置类</td>
</tr>
</tbody>
</table>
</li>
</ol>
<h4 id="AOP"><a class="header-anchor" href="#AOP">○</a>AOP</h4>
<h5 id="概念"><a class="header-anchor" href="#概念">○</a>概念</h5>
<p>面向切面编程，是动态代理的规范化编程，动态代理如何增强方法见上文。SpringAOP底层使用的动态代理为以下两种：</p>
<ol>
<li>
<p>Java原生接口代理</p>
<p>通过接口反射出代理对象，使用的是 <a href="#ProxyMode">ProxyMode</a></p>
</li>
<li>
<p>cglib子类代理</p>
<p>外部的工具库，已经集成在springframework-core中，使用的是Enhancer类。通过指定父类反射出代理对象。</p>
</li>
</ol>
<p>根据<u>目标对象</u><sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>是否有接口来选择其中一个方法。</p>
<h5 id="XML配置动态代理"><a class="header-anchor" href="#XML配置动态代理">○</a>XML配置动态代理</h5>
<p>maven导入依赖<code>aspectjweaver</code>、<code>spring-aop</code></p>
<ol>
<li>
<p>配置目标对象和切面对象Bean</p>
<p><strong>切面类和目标类都需要配置为Bean</strong>才能被Spring从IOC容器中取出来</p>
</li>
<li>
<p>配置织入（前置、后置……）</p>
<p>使用命名空间<code>xmlns:aop</code></p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span>
 	<span class="hljs-comment">&lt;!--声明切面类--&gt;</span>   
	<span class="hljs-tag">&lt;<span class="hljs-name">aop:aspect</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;beanName&quot;</span>&gt;</span>
    	<span class="hljs-comment">&lt;!--配置切面：切点+通知--&gt;</span>
        <span class="hljs-comment">&lt;!--类似的还有aop:after等等--&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">aop:before</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;adviceName&quot;</span> <span class="hljs-attr">pointcut</span>=<span class="hljs-string">&quot;execution(&#x27;方法声明&#x27;)&quot;</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">aop:aspect</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span></code></pre>
<p><strong>切面标签</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:left">标签</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">前置通知</td>
<td style="text-align:left">aop:before</td>
<td>略</td>
</tr>
<tr>
<td style="text-align:center">后置通知</td>
<td style="text-align:left">aop:after-returning</td>
<td>略</td>
</tr>
<tr>
<td style="text-align:center">环绕通知</td>
<td style="text-align:left">aop:around</td>
<td>前后都执行，比前置更前，比后置更后</td>
</tr>
<tr>
<td style="text-align:center">异常抛出通知</td>
<td style="text-align:left">aop:throwing</td>
<td>出现异常时执行</td>
</tr>
<tr>
<td style="text-align:center">最终通知</td>
<td style="text-align:left">aop:after</td>
<td>最后执行，无论是否抛出异常</td>
</tr>
</tbody>
</table>
<p>ℹ️<strong>环绕通知</strong>方法需要携带参数<code>ProceedingJoinPoint</code>表示连接点<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>对象，要在方法中执行该对象的<code>proceed()</code>方法并<strong>return</strong>该方法的返回值。</p>
<p>⚠️<strong>环绕通知</strong>方法的返回值都为<code>Object</code>，表示被增强的方法会返回一个对象或者<code>NULL</code>，因此需要注意被增强的方法不能返回<code>boolean</code>、<code>int</code>等基础类型，需要用对应的包装类替换！</p>
</li>
<li>
<p>切点表达式</p>
<p><code>execution([修饰符] 返回值 包名.类名.方法(参数))</code></p>
<ul>
<li>
<p>修饰符可以省略（public、private……）</p>
</li>
<li>
<p>可以用通配符（*）代表任意</p>
</li>
<li>
<p>参数可以用<code>..</code>表示任意个数，任意类型的参数列表（可变参数）</p>
</li>
</ul>
<p>ex:</p>
<pre><code class="hljs java">execution(* cn.test.*.*(..)) <span class="hljs-comment">//cn.test包下任意类的任意方法</span></code></pre>
<p>**表达式抽取：**替换<code>point-cut</code>为<code>point-cut-ref</code>，引用<code>&lt;aop:pointcut id=&quot;&quot; expression=&quot;&quot;/&gt;</code>标签设定好的表达式<u>id</u></p>
</li>
</ol>
<h5 id="注解配置动态代理"><a class="header-anchor" href="#注解配置动态代理">○</a>注解配置动态代理</h5>
<p>在配置文件中添加<code>&lt;aop:aspect-autoproxy /&gt;</code>自动代理aop</p>
<p>或者在配置类上用<code>@EnableAspectJAutoProxy</code>标注</p>
<table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>@Aspect</td>
<td>标注为切面类</td>
</tr>
<tr>
<td>@Before</td>
<td>标志为前置通知，参数为execution表达式</td>
</tr>
<tr>
<td>@AfterReturning</td>
<td>标志为后置通知，参数为execution表达式</td>
</tr>
<tr>
<td>@Around</td>
<td>标志为环绕通知，参数为execution表达式</td>
</tr>
<tr>
<td>@AfterThrowing</td>
<td>标志为异常抛出通知，参数为execution表达式</td>
</tr>
<tr>
<td>@After</td>
<td>标志为最终通知，参数为execution表达式</td>
</tr>
</tbody>
</table>
<p>**切点<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>表达式抽取：**在切面类中定义空实现方法，在方法上用<code>@PointCut（’表达式‘）</code>标注，引用时按照<code>className.methodName()</code>来描述</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Aspect</span> </span>&#123;
    <span class="hljs-meta">@PointCut(&quot;excution(*.cn.shijh.*.*(..))&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">myPointCut</span><span class="hljs-params">()</span></span>&#123;&#125;

    <span class="hljs-meta">@Before(&quot;Aspect.myPointCut()&quot;)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">beforeEnhance</span><span class="hljs-params">()</span>    </span>
<span class="hljs-function">&#125;</span>
<span class="hljs-function"></span></code></pre>
<h4 id="Spring事务控制"><a class="header-anchor" href="#Spring事务控制">○</a>Spring事务控制</h4>
<p>底层基于<a href="#aop">AOP</a>实现事务管理，一般在Service层进行。</p>
<p>切点：Service方法</p>
<p>通知：事务管理</p>
<hr>
<p>⚠️ ⚠️ ⚠️ <a href="https://blog.pressed.top/springTxError">关于这个问题的详细说明</a></p>
<p><strong>Spring事务管理与AOP之间存在神坑，被环绕通知的方法是无法进行事务控制的！！！！坑了我两三个小时！原因是事务管理本身就是环绕通知！！解决办法：设定Aspect和advisor的Order，且事务控制的Order要比环绕通知的大，否则无法完成事务回滚</strong></p>
<hr>
<h5 id="编程式控制"><a class="header-anchor" href="#编程式控制">○</a>编程式控制</h5>
<ol>
<li><strong>PlatfromTransactionManager</strong></li>
</ol>
<p>spring事务管理器的接口，依据不同Dao层技术使用不同的实现类。</p>
<ul>
<li><em>DataSourceTransactionManager</em></li>
</ul>
<pre><code> Jdbc or MyBatis 对应的实现类。
</code></pre>
<ol start="2">
<li><strong>TransacitonDefinition</strong></li>
</ol>
<p>事务的定义对象，封装事务的隔离级别、传播行为、超时时间等属性。</p>
<ul>
<li>
<p><a href="#%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB">隔离级别</a></p>
<p><code>ISOLATION_DEFAULT</code>：数据库默认级别</p>
<p><code>ISOLATION_READ_UNCOMMITTED</code></p>
<p><code>ISOLATION_READ_COMMITTED</code></p>
<p><code>ISOLATION_REPEATABLE_READ</code></p>
<p><code>ISOLATION_SERIALIZABLE</code></p>
</li>
<li>
<p>传播行为</p>
<p><code>REQUIRED</code>：默认值，防止嵌套的两个事务发生，后一个事务会加入到前一个事务中。</p>
<p><code>SUPPORTS</code>：后一个事务将不会开启</p>
<p><code>MANDATORY</code>：强制加进入前一个事务中，没有前一个事务就报错</p>
</li>
</ul>
<ol start="3">
<li>
<p><strong>TransactionStatus</strong></p>
<p>事务的运行状态对象。是否完成、是否回滚等状态。</p>
</li>
</ol>
<h5 id="XML声明式控制"><a class="header-anchor" href="#XML声明式控制">○</a>XML声明式控制</h5>
<pre><code class="hljs xml"><span class="hljs-comment">&lt;!--配置事务管理的增强方法--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">tx:advice</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">tx:attributes</span>&gt;</span>
        <span class="hljs-comment">&lt;!--name可以使用通配符‘*’和字符串组合使用</span>
<span class="hljs-comment">			如‘update*’表示以update开头的所有方法名--&gt;</span>
    	<span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;methodName&quot;</span> <span class="hljs-attr">isolation</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">propogation</span>=<span class="hljs-string">&quot;&quot;</span>/&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">tx:attributes</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">tx:advice</span>&gt;</span>
<span class="hljs-comment">&lt;!--transactionManager需要注入到IOC容器中--&gt;</span>
<span class="hljs-comment">&lt;!--配置增强方法的织入，使用aop--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span>
    <span class="hljs-comment">&lt;!--事务管理增强专用标签--&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">aop:advisor</span> <span class="hljs-attr">advice-ref</span>=<span class="hljs-string">&quot;tx:advice&quot;</span> <span class="hljs-attr">pointcut</span>=<span class="hljs-string">&quot;execution&quot;</span>/&gt;</span>	
<span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span></code></pre>
<table>
<thead>
<tr>
<th>标签</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>tx:advice</td>
<td>配置事务管理的通知，需指定transactionManager</td>
</tr>
<tr>
<td>tx:attributes</td>
<td>配置<a href="#%E7%BC%96%E7%A8%8B%E5%BC%8F%E6%8E%A7%E5%88%B6">事务的属性</a>，具体由多个<a class="link"   href="tx:method" >tx:method<i class="fas fa-external-link-alt"></i></a>配置</td>
</tr>
<tr>
<td>tx:method</td>
<td>指定一个方法名，配置一个业务方法的属性，包括隔离级别等</td>
</tr>
<tr>
<td>aop:advisor</td>
<td>用于事务管理的aop增强方法，引用配置好的<a class="link"   href="tx:advice" >tx:advice<i class="fas fa-external-link-alt"></i></a>作为通知</td>
</tr>
</tbody>
</table>
<p><em>配置事务属性时，只需指定方法名，不需要指定包名类名等，具体位置在织入时配置</em></p>
<h5 id="注解声明式控制"><a class="header-anchor" href="#注解声明式控制">○</a>注解声明式控制</h5>
<table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>@EnableTransactionManagement</td>
<td>在配置类中标注，表示开启spring事务管理</td>
</tr>
<tr>
<td>@Transactional</td>
<td>在方法或者类上标注，表示类下的方法都会被spring事务进行管理，可以加参数来配置<a href="#%E7%BC%96%E7%A8%8B%E5%BC%8F%E6%8E%A7%E5%88%B6">事务的属性</a></td>
</tr>
</tbody>
</table>
<p><em>使用注解配置时，driver会由spring自动配置，只需要将transactionManager放到IOC容器中</em></p>
<h4 id="Spring-Junit"><a class="header-anchor" href="#Spring-Junit">○</a>Spring-Junit</h4>
<p>通过注解集成Junit</p>
<table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>@RunWith</td>
<td>指定使用Spring内置的测试类</td>
</tr>
<tr>
<td>@ContextConfiguration</td>
<td>指定Spring配置文件、配置类</td>
</tr>
<tr>
<td>@AutoWired</td>
<td>从IOC容器中注入测试对象</td>
</tr>
</tbody>
</table>
<h4 id="Spring-JdbcTemplate"><a class="header-anchor" href="#Spring-JdbcTemplate">○</a>Spring-JdbcTemplate</h4>
<p>对<a href="#jdbc">JDBC</a> API的封装，使调用更加简单</p>
<p>maven需要导入依赖<code>spring-jdbc</code>和<code>spring-tx</code></p>
<p><strong>常用方法</strong></p>
<ol>
<li>
<p><code>setDataSource()</code>：设置连接池对象</p>
</li>
<li>
<p><code>update()</code>、<code>query()</code>：执行sql语句</p>
</li>
<li>
<p><code>RowMapper&lt;T&gt;</code>可以自动完成数据封装的接口，是<code>query()</code>的方法参数，对应实现类有 <code>BeanPropertyRowMapper&lt;T&gt;</code>，需要构造参数：</p>
<pre><code class="hljs java"><span class="hljs-keyword">new</span> BeanPropertyRowMapper&lt;JavaBean&gt;(JavaBean.class)</code></pre>
<p><code>query()</code>将返回<code>List&lt;T&gt;</code>类型的集合</p>
</li>
<li>
<p><code>queryForObject()</code>同<code>query()</code>一样，但是只返回一个对象</p>
</li>
<li>
<p>查询简单对象只需要传入<code>Class&lt;T&gt;</code></p>
</li>
</ol>
<p>可以使用IOC容器来创建jdbcTemplate、dataSource对象，完成参数的注入。</p>
<h4 id="Spring-web"><a class="header-anchor" href="#Spring-web">○</a>Spring-web</h4>
<p>用于集成web环境的maven依赖<code>spring-web</code>，提供获取应用上下文（ApplicationContext）的工具类和监听器。获取的原理是在服务器启动时创建上下文并放入ServletContext域中，即可在服务器共享。方便在 <code>Servlet</code>中获取应用上下文，且可以避免多次创建带来的性能开销。</p>
<ol>
<li>
<p>web.xml中配置监听器<code>ContextLoaderListener</code></p>
</li>
<li>
<p>配置<code>&lt;context-param&gt;</code>指定applicationContext.xml/.class的路径</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>xx.xx.xx.ClassName<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span>
<span class="hljs-comment">&lt;!--如果使用类配置则一定要指定下面的参数--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextClass<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>org.springframework.web.context.support.AnnotationConfigWebApplicationContext<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span></code></pre>
</li>
<li>
<p>使用<code>WebApplicationContextUtils</code>获取上下文</p>
</li>
</ol>
<h3 id="SpringMVC"><a class="header-anchor" href="#SpringMVC">○</a>SpringMVC</h3>
<p><a class="link"   target="_blank" rel="noopener" href="https://github.com/838239178/springdemo" >Spring+SpringMvc Demo<i class="fas fa-external-link-alt"></i></a></p>
<p>属于web层框架，提供轻量级的MVC开发 ，核心是用<code>servlet</code>实现的前端控制器。该控制器执行servlet的共有行为，并调用特有行为servlet，称为 <code>Controller</code></p>
<h4 id="组件解析"><a class="header-anchor" href="#组件解析">○</a>组件解析</h4>
<h5 id="原理图解"><a class="header-anchor" href="#原理图解">○</a>原理图解</h5>
<p><img src="https://i.loli.net/2021/02/26/OyFfPTpuwKC7jEo.jpg" alt=""></p>
<h5 id="组件详解"><a class="header-anchor" href="#组件详解">○</a>组件详解</h5>
<ul>
<li>
<p>HandlerMapping</p>
</li>
<li>
<p>HandlerAdaptor</p>
<p>执行对应的Controller，并把Controller的返回值包装成ModelAndView对象。</p>
</li>
<li>
<p>ModelAndView</p>
<ul>
<li><code>setViewName()</code>设置页面跳转的页面名称</li>
<li><code>addObject()</code>设置request域中的参数</li>
<li><code>new ModelAndView(JsonView, ModelMap)</code>用一个Map和JsonView对象创建Json数据视图</li>
</ul>
</li>
<li>
<p>ViewResolver</p>
<p><a class="link"   target="_blank" rel="noopener" href="https://blog.csdn.net/zmx729618/article/details/51554762" >参考地址<i class="fas fa-external-link-alt"></i></a></p>
<p>视图解析器，SpringMvc内部有很多解析器，默认使用的 <code>InternalResourceViewResolver</code>。主要作用是把一个ModelAndView解析为一个真正的视图。</p>
<p>其中一种视图解析使用了一种拼接url的方式，内部规定了前缀(prefix)、后缀(suffix)，与视图的名称，如&quot;index&quot;，拼接后就得到视图URL了。url方式可以在<code>ViewName</code>中加上前缀指定，有&quot;redirect:“和&quot;forward:”，表示重定向和转发。视图解析器会把这些包装成View对象返回前端控制器。</p>
</li>
<li>
<p>View</p>
<p>由解析器产生的对象，分为URL(jsp, jstl)、文档(excel, pdf)、报表、JSON。</p>
</li>
</ul>
<h4 id="XML配置"><a class="header-anchor" href="#XML配置">○</a>XML配置</h4>
<ol>
<li>
<p>在<code>web.xml</code>中配置前端控制器<code>DispatcherServlet</code></p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span>
    <span class="hljs-comment">&lt;!--设定SpringMVC配置文件的地址 使用类配置时要指定contextClass类型，同spring-web--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>配置文件地址<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span></code></pre>
</li>
<li>
<p>使用独立的<code>spring-mvc.xml</code>配置SpringMVC的各种属性</p>
<ul>
<li>
<p>配置组件，ViewResolver、HandleAdapter等</p>
<p>用<code>&lt;bean&gt;</code>标签配置，同Spring一样</p>
</li>
</ul>
</li>
<li>
<p><code>&lt;mvc:annotation-driven&gt;</code> 自动配置一些组件的属性</p>
</li>
</ol>
<h4 id="注解配置"><a class="header-anchor" href="#注解配置">○</a>注解配置</h4>
<p><a href="#%E6%B3%A8%E8%A7%A3%E5%BC%8F%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5">Spring新注解也通用于SpringMVC</a></p>
<table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
<th style="text-align:left">参数</th>
</tr>
</thead>
<tbody>
<tr>
<td>@EnableWebMvc</td>
<td>启用mvc注解驱动</td>
<td style="text-align:left">无</td>
</tr>
<tr>
<td>@RequestMapping</td>
<td>请求映射地址，用于类或方法中</td>
<td style="text-align:left">value：路径；method：请求方式；params：限定请求参数</td>
</tr>
<tr>
<td>@GetMapping</td>
<td>Request的细分</td>
<td style="text-align:left">value：路径</td>
</tr>
<tr>
<td>@PostMapping</td>
<td>同上</td>
<td style="text-align:left">同上</td>
</tr>
<tr>
<td>@ResponseBody</td>
<td>标注返回值到content中</td>
<td style="text-align:left">无</td>
</tr>
<tr>
<td>@RequestParam</td>
<td>取request的参数</td>
<td style="text-align:left">value：所需参数的名称; require：强制要求？;defaultValue：默认值</td>
</tr>
<tr>
<td>@RequestBody</td>
<td>标注方法参数上，注入JSON请求参数</td>
<td style="text-align:left">无</td>
</tr>
<tr>
<td>@PathVariable</td>
<td>标注方法参数上，用于restful风格的参数</td>
<td style="text-align:left">value；require；defaultValue; 同RequestParam</td>
</tr>
<tr>
<td>@RequstHeader</td>
<td>获取请求头数据</td>
<td style="text-align:left">value; require;</td>
</tr>
</tbody>
</table>
<p><strong>WebMvcConfigurer</strong></p>
<p>Mvc配置类需要实现的接口，用于配置更多SpringMvc的属性，如资源解析、拦截器等。</p>
<h5 id="注解配置web-xml"><a class="header-anchor" href="#注解配置web-xml">○</a>注解配置web.xml</h5>
<p>配置web.xml的类需要实现接口<code>AbstractAnnotationConfigDispatcherServletInitializer</code>，并实现其中方法，Spring会自动查找该实现类来代替web.xml</p>
<pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 指定 ContextLoaderListener 所需的配置类</span>
<span class="hljs-comment"> */</span>
<span class="hljs-meta">@Override</span>
<span class="hljs-keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;&#125;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 指定mvc的核心配置类</span>
<span class="hljs-comment"> */</span>
<span class="hljs-meta">@Override</span>
<span class="hljs-keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;&#125;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 等同于设置 DispatcherServlet 的 url-pattern</span>
<span class="hljs-comment"> */</span>
<span class="hljs-meta">@Override</span>
<span class="hljs-keyword">protected</span> String[] getServletMappings() &#123;&#125;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 配置过滤器</span>
<span class="hljs-comment"> */</span>
<span class="hljs-meta">@Override</span>
<span class="hljs-keyword">protected</span> Filter[] getServletFilters() &#123;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Filter[]&#123;
        <span class="hljs-keyword">new</span> CharacterEncodingFilter(<span class="hljs-string">&quot;UTF-8&quot;</span>),
    &#125;;
&#125;</code></pre>
<h4 id="数据响应"><a class="header-anchor" href="#数据响应">○</a>数据响应</h4>
<p>服务的的数据响应分为页面跳转和回写数据。</p>
<h5 id="页面跳转"><a class="header-anchor" href="#页面跳转">○</a>页面跳转</h5>
<ol>
<li>
<p>直接返回字符串，如页面的名称&quot;index&quot;，默认为转发</p>
</li>
<li>
<p>返回ModelAndView对象</p>
<p>通过<code>setViewName()</code>指定页面名称，<code>addObject()</code>保存数据供<code>JSP</code>调用</p>
<p>ModelAndView对象可以放在形参中，Spring会自动注入一个空的对象。</p>
</li>
</ol>
<h5 id="回写数据"><a class="header-anchor" href="#回写数据">○</a>回写数据</h5>
<ol>
<li>
<p>ModelAndView</p>
<p>Json数据内容由<code>LinkedHashMap</code>转化而来，Json转化驱动可以是<code>jackjson</code>、<code>fastjson</code>，需要添加maven依赖。</p>
<pre><code class="hljs java"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ModelAndView(<span class="hljs-keyword">new</span> FastJsonJsonView(), map);</code></pre>
</li>
<li>
<p>字符串</p>
<p>方法上标注<code>@ResponseBody</code>表示返回值直接写入response的content。Json也可以作为字符串直接返回，使用json驱动转化。</p>
</li>
<li>
<p>对象或集合</p>
<p>通过配置消息转换器，可以直接返回集合或者对象自动转化成Json字符串，同时要在方法上标注<code>@ResponseBody</code>。</p>
<ul>
<li>
<p>XML</p>
<p>配置<code>RequestMappingHandlerAdapter</code>bean标签，把Json转化驱动注入<code>messageConverters</code>中。</p>
</li>
<li>
<p>注解、类配置</p>
<p>在Mvc配置类中继承<code>WebMvcConfigurer</code>接口，实现以下方法</p>
<pre><code class="hljs java"><span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configureMessageConverters</span><span class="hljs-params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> </span>&#123;
    <span class="hljs-comment">// 此处配置FastJson</span>
    FastJsonConfig config = <span class="hljs-keyword">new</span> FastJsonConfig();
    FastJsonHttpMessageConverter converter = <span class="hljs-keyword">new</span> FastJsonHttpMessageConverter();
    config.setSerializerFeatures(
        SerializerFeature.DisableCircularReferenceDetect,
        SerializerFeature.WriteMapNullValue,
        SerializerFeature.WriteNullStringAsEmpty
    );
    converter.setFastJsonConfig(config);
    converters.add(converter);
&#125;</code></pre>
</li>
</ul>
<p><em>*返回Map集合时，最好使用<strong>LinkedHashMap</strong>来保证Json内数据顺序不会乱掉</em></p>
</li>
</ol>
<h5 id="获得请求参数"><a class="header-anchor" href="#获得请求参数">○</a>获得请求参数</h5>
<ol>
<li>
<p>spring自动注入方法的参数中</p>
<p>限制：基本类型、数组和 Javabea(POJO)。集合对象（List等）需要包装到Bean中才能自动注入。当方法参数名与请求参数名一致时不需要加<code>@RequestParam</code></p>
</li>
<li>
<p><code>@RequestBody</code>直接接收request的参数数据</p>
<p>注释在参数上，一般用于非表单的数据，如<code>application/json</code>、<code>application/xml</code></p>
<p>用Json格式的数组作为<strong>请求参数</strong>，可以通过该标签直接注入到集合类型的<strong>方法参数</strong>中。</p>
</li>
<li>
<p>获得<a href="#Restful">Restful</a>风格的请求参数</p>
<p>使用<code>@PathVariable</code>获取，具体使用如下</p>
<pre><code class="hljs java"><span class="hljs-meta">@RequsetMapping(&quot;/api/&#123;id&#125;/&#123;name&#125;&quot;)</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testController</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> <span class="hljs-keyword">int</span> id, <span class="hljs-meta">@PathVariable(&quot;name&quot;)</span> Stirng name)</span> </span>&#123;&#125;</code></pre>
</li>
<li>
<p>获取<strong>请求头</strong></p>
<p>使用<code>@RequstHeader(name)</code>在方法参数中注入。</p>
<p><code>@CookieValue</code>直接获取Cookie数据。</p>
</li>
</ol>
<h5 id="文件上传"><a class="header-anchor" href="#文件上传">○</a>文件上传</h5>
<p>Post Content类型为 <code>Multipart/form-data</code>时，需要借助第三方工具简化获取参数的过程。</p>
<p>导入maven依赖 <code>commons-io</code>、<code>commons-fileupload</code></p>
<p>SpringMvc获取到上传的文件时，会打包成<code>MulitpartFile</code>对象，因此用于获取文件的Controller方法需要有此类型的参数。</p>
<p><strong>MultipartFile</strong></p>
<ul>
<li><code>getOriginFilename()</code>获取文件名</li>
<li><code>transferTo(File)</code>通过IO保存本地或其他服务器</li>
</ul>
<h5 id="自定义类型转换器"><a class="header-anchor" href="#自定义类型转换器">○</a>自定义类型转换器</h5>
<p>实现 <code>Convert&lt;S,D&gt;</code> 接口，并配置到SpringMvc中。接口泛型分别为转换前类型和转换后类型。</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;converters&quot;</span>&gt;</span>
    	<span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span>
        	<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span> <span class="hljs-attr">conversion-service</span>=<span class="hljs-string">&quot;&quot;</span>/&gt;</span></code></pre>
<h4 id="静态资源访问"><a class="header-anchor" href="#静态资源访问">○</a>静态资源访问</h4>
<p>当 spring-mvc 的 dispatcher-servlet 路径配置为<code>/</code>，访问资源时也会去寻找Handler，无法访问到资源文件。解决方法有两种，第一种是配置资源文件的映射，第二种是交由tomcat来寻找资源文件。</p>
<ul>
<li>
<p>XML配置</p>
<pre><code class="hljs xml"><span class="hljs-comment">&lt;!--1.配置资源文件的映射--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">mvc:resource</span> <span class="hljs-attr">mapping</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;path&quot;</span> /&gt;</span>
<span class="hljs-comment">&lt;!--2.启用默认servlet-handler管理资源文件--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">mvc:default-servlet-handler</span> /&gt;</span></code></pre>
</li>
<li>
<p>注解、类配置</p>
<p>在Mvc配置类中继承<code>WebMvcConfigurer</code>接口，实现以下方法</p>
<pre><code class="hljs java"><span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configureDefaultServletHandling</span><span class="hljs-params">(DefaultServletHandlerConfigurer configurer)</span> </span>&#123;
    configurer.enable();
&#125;</code></pre>
</li>
</ul>
<h4 id="Session管理"><a class="header-anchor" href="#Session管理">○</a>Session管理</h4>
<p>SpringMvc可以使用注解对Session进行一些简单的管理操作，如向session域中存入数据等。</p>
<ol>
<li>
<p><strong>方法一：</strong></p>
<p>在Controller方法中使用HttpSession对象作为参数，Spring会自动注入。HttpSession能够同时完成添加、删除、查询Attribute的功能。</p>
</li>
<li>
<p><strong>方法二：</strong></p>
<p>在Controller类上使用<code>@SessionAttributes</code>并指定参数为该类需要使用的AttributeNames，然后方法上的参数就可以使用<code>@ModelAttribute(name)</code>注入Session域的数据。在方法参数中使用Model类型，Spring会把该类的所有Session注入到Model对象中，因此也能够获取Session中的值，同时能够<strong>向Session中添加值</strong>。需要注意的是，使用该方法清除Session时，需要使用SessionStatus（作为方法参数，spring自动注入）的<code>SetComplete()</code>来清除，并且只会清除<code>@SessionAttributes</code>中标记的键值对。</p>
</li>
</ol>
<p>✋<em>Spring官方文档中提出，对于用户登录验证的session最好使用<strong>方法一</strong></em></p>
<h4 id="拦截器-Interceptor"><a class="header-anchor" href="#拦截器-Interceptor">○</a>拦截器 Interceptor</h4>
<p>与Filter过滤器类似，用于预处理和后处理，原理为<a href="#AOP">AOP</a>。<strong>只对控制器方法进行拦截，不拦截资源访问</strong></p>
<h5 id="自定义拦截器"><a class="header-anchor" href="#自定义拦截器">○</a>自定义拦截器</h5>
<p>实现<code>HandlerInterceptor</code>接口，并进行配置。</p>
<ul>
<li>
<p>类配置</p>
<pre><code class="hljs java"><span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span></span>&#123;
    registry.addInterceptor(interceptor).addPathPatterns(<span class="hljs-string">&quot;/&quot;</span>);
&#125;</code></pre>
</li>
<li>
<p>xml配置</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptors</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptor</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">mvc:mapping</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;&quot;</span>/&gt;</span>
    	<span class="hljs-tag">&lt;<span class="hljs-name">bean</span>/&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptor</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptors</span>&gt;</span></code></pre>
</li>
<li>
<p><strong>HandlerInterceptor</strong></p>
<pre><code class="hljs java"><span class="hljs-comment">// 执行前拦截</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(req, resp, handler)</span></span>;	
<span class="hljs-comment">// 执行后，返回前拦截</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postHandle</span><span class="hljs-params">(req,resp, handler, modelAndView)</span></span>;
<span class="hljs-comment">// 流程完毕后拦截</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterCompletion</span><span class="hljs-params">(req, resp, handler, exception)</span></span></code></pre>
<ol>
<li><code>preHandle</code>返回为 <code>True</code> 时，后续操作才能执行。</li>
<li><code>Handler</code>为控制器方法执行对象（Method）</li>
</ol>
</li>
</ul>
<h5 id="拦截器执行顺序"><a class="header-anchor" href="#拦截器执行顺序">○</a>拦截器执行顺序</h5>
<p>多个拦截器执行时，并非串行，而是嵌套的，也就是说拦截器执行链最后执行的方法时第一个拦截器的<code>afterCompletion</code>。执行的顺序与配置的顺序有关，先配置先执行。</p>
<h4 id="异常处理机制"><a class="header-anchor" href="#异常处理机制">○</a>异常处理机制</h4>
<p>把异常处理抽取出来，通过异常处理组件统一解决，在SpringMvc中异常处理可以由<code>DispatcherServlet</code>调用响应组件处理。</p>
<h5 id="异常处理器"><a class="header-anchor" href="#异常处理器">○</a>异常处理器</h5>
<p><em>HandlerExceptionResolver</em></p>
<ul>
<li>
<p><strong>SimpleMappingExceptionResolver</strong></p>
<p>框架自带的实现类。Mapping——发生异常时跳转到异常视图，映射关系通过配置完成。</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.xx.x.SimpleMappingExceptionResolver&quot;</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;defalutErrorView&quot;</span> <span class="hljs-attr">vlaue</span>=<span class="hljs-string">&quot;&quot;</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;exceptionMappings&quot;</span>&gt;</span>
    	<span class="hljs-tag">&lt;<span class="hljs-name">map</span>&gt;</span>
        	<span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;&quot;</span>/&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">map</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre>
</li>
</ul>
<h5 id="自定义异常处理器"><a class="header-anchor" href="#自定义异常处理器">○</a>自定义异常处理器</h5>
<ul>
<li>
<p>异常处理方法</p>
<p>使用注解<code>@ExceptionHanlder</code>标注在方法上时，该方法为所在类的异常处理方法。</p>
</li>
<li>
<p>异常处理类</p>
<p>使用注解<code>@ControllerAdvice</code>标注在类上时，该类为全局的异常处理类。类内的方法使用<code>@ExceptionHandler</code>标注的方法将用于处理发生的异常。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
<th>参数</th>
</tr>
</thead>
<tbody>
<tr>
<td>@ExceptionHanlder</td>
<td>用于方法上，异常处理方法</td>
<td>可以指定异常类，表示只处理个别异常</td>
</tr>
<tr>
<td>@ControllerAdvice</td>
<td>用于类上，全局的异常处理类</td>
<td>无</td>
</tr>
</tbody>
</table>
<p><em>*异常处理方法，会被当做一个Controller处理，因此其返回值最终会包装成ModelAndView对象，所以可以使用 <code>@ResponseBody</code>注解</em></p>
<h4 id="在Junit中使用MockMvc"><a class="header-anchor" href="#在Junit中使用MockMvc">○</a>在Junit中使用MockMvc</h4>
<p>由于SpringMvc面向web层，因此无法直接调用Controller组件进行测试。</p>
<h5 id="使用方法-v3"><a class="header-anchor" href="#使用方法-v3">○</a>使用方法</h5>
<ol>
<li>在Junit测试类上注解<code>@WebAppConfiguration</code>引入Web层配置文件</li>
<li>使用IOC注入<code>WebApplicationContext</code>对象</li>
<li>使用<strong>MockMvcBuilders</strong>创建<strong>MockMvc</strong>对象，需要传入WebApplicationContext初始化</li>
<li>使用MockMvc进行测试</li>
</ol>
<h5 id="MockMvc"><a class="header-anchor" href="#MockMvc">○</a>MockMvc</h5>
<p>MockMvc主要使用<code>perform()</code>方法向Controller发出请求，无需启动Tomcat服务器。<code>perfrom</code>方法的参数由<code>MockMvcRequestBuilders</code>创建，并返回一个<code>ResultActions</code>对象。</p>
<ul>
<li><code>MockMvcRequestBuilders</code>：创建一个模拟请求，有get或post类型，能够设置请求体和请求头参数</li>
<li><code>ResultActions</code>：通常使用<code>andDo</code>方法输出请求和响应的所有信息，执行<code>andReturn</code>返回<code>MvcResult</code>结果对象</li>
<li><code>MvcResult</code>：结果对象，包含request和response信息</li>
</ul>
<p><strong>测试样例：</strong></p>
<pre><code class="hljs java"><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;
    MvcResult res = mockMvc.perform(
        MockMvcRequestBuilders
        .post(<span class="hljs-string">&quot;/user/login&quot;</span>)
        .contentType(MediaType.APPLICATION_FORM_URLENCODED)
        .characterEncoding(<span class="hljs-string">&quot;UTF-8&quot;</span>)
        .param(<span class="hljs-string">&quot;userName&quot;</span>, <span class="hljs-string">&quot;zhangsan&quot;</span>)
        .param(<span class="hljs-string">&quot;password&quot;</span>, <span class="hljs-string">&quot;123&quot;</span>)
    ).andDo(MockMvcResultHandlers.print()).andReturn();
    System.out.println(res.getResponse().getContentAsString());
&#125;</code></pre>
<h3 id="Mybatis-Spring"><a class="header-anchor" href="#Mybatis-Spring">○</a>Mybatis-Spring</h3>
<p><strong>前置</strong>-关于Mybatis的详细内容：<a href="https://blog.pressed.top/myBatis">Mybatis原始教程</a></p>
<p><strong>Maven</strong>：mybatis-spring</p>
<h4 id="IOC注入"><a class="header-anchor" href="#IOC注入">○</a>IOC注入</h4>
<p>将Mybatis的<code>SqlSessionFactory</code>等对象配置到SpringIOC容器中。</p>
<ol>
<li>
<p>配置<code>SqlSessionFactory</code>，主要是配置其数据源<code>dataSource</code>和核心配置文件<code>configLocation</code>（非必须）</p>
</li>
<li>
<p>mapper组件扫描</p>
<p>注解方式：</p>
<ul>
<li><code>@MapperScan(basepackage=&quot;&quot;)</code></li>
</ul>
<p>简洁方式：</p>
<ul>
<li><code>&lt;mybatis:scan base-package=&quot;&quot; /&gt;</code>，这个方式不需要额外注解，但是也支持配置自定义注解来限制其扫描范围，指定<code>annotation</code>为自定义的注解即可。以上两种方法将映射器(DAO)z注入到SpringIOC时，默认使用首字母小写作为Bean的名称，可以在自定义注解中设置<code>org.springframework.stereotype.Component</code> 这样的注解既可以作为标记，也可以作为一个名字提供器来使用了。</li>
</ul>
<p>经典方式（不推荐使用了）：</p>
<ul>
<li>
<pre><code class="language-xml">&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;
	&lt;property name=&quot;basePackage&quot; value=&quot;xx.xx&quot;/&gt;
&lt;/bean&gt;
</code></pre>
</li>
</ul>
</li>
</ol>
<p>配置完毕后即可使用依赖注入直接创建<code>DAO/Mapper</code>接口对象。</p>
<h4 id="事务控制"><a class="header-anchor" href="#事务控制">○</a>事务控制</h4>
<p>配置事务管理器<code>transactionManager</code>和事务增强，同样可以使用注解，<a href="#Spring%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6">同上文</a>。配置完成后就可以像使用JdbcTempelate一样进行事务管理。</p>
<h3 id="ExtraDetail-v2"><a class="header-anchor" href="#ExtraDetail-v2">○</a>ExtraDetail</h3>
<h4 id="Properties-ResourceBundle"><a class="header-anchor" href="#Properties-ResourceBundle">○</a>Properties/ResourceBundle</h4>
<p>properties是一种键值对<code>key=value</code>储存文件，Java中自带的Properties类可以简单的读写properties文件，但是ResourceBundle类更好的支持了不同的语言，比前者要好一点。</p>
<h4 id="Restful"><a class="header-anchor" href="#Restful">○</a>Restful</h4>
<p>Restful是一种软件架构、设计风格，提供了一些原则和约束，可以帮助软件设计变得更加简介有层次，更易于实现缓存机制等。Restful风格表现为“url+请求方式”来表现一次HTTP请求，特点是请求参数用<code>/</code>接在url后面，而不再使用<code>?</code>来表示请求参数。如：<code>http://url/api?id=1</code>使用restful风格后应该是<code>http://url/api/1</code>。</p>
<p>Restful规定请求方式具有如下几个含义:</p>
<ul>
<li>GET 表示获取</li>
<li>POST 表示新建</li>
<li>PUT 表示更新</li>
<li>DELETE 表示删除</li>
</ul>
<h4 id="FastJson"><a class="header-anchor" href="#FastJson">○</a>FastJson</h4>
<p>由阿里巴巴开发的Json转化驱动。其中<code>FastJsonHttpMessageConverter</code>可以用于SpringMvc的消息转换器中。</p>
<ul>
<li><code>@JSONType</code>: 可以标注在类上，通过指定orders参数可以决定转化该类时解析属性的顺序。</li>
<li><code>@JSONFiled</code>: 标注在成员变量上，可以指定转化后名称以及转化顺序</li>
</ul>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>被代理的类 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>目标对象被增强的方法 <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p>pointCut 目标对象的方法 <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>

        </div>

        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/2021/03/12/myBatis/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">MyBatis</span>
                                <span class="post-nav-item">上一篇</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/2021/02/21/springTxError/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">关于Spring事务管理失效问题</span>
                                <span class="post-nav-item">下一篇</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
            <div class="comment-container">
                <div class="comments-container">
    <div id="comment-anchor"></div>
    <div class="comment-area-title">
        <i class="fas fa-comments">&nbsp;评论</i>
    </div>
    

        
            
    <div id="gitalk-container"></div>
    <script data-pjax
            src="//cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js"></script>
    <script data-pjax>

        function loadGitalk() {
            let __gitalk__pathname = decodeURI(location.pathname);
            const __gitalk__pathnameLength = __gitalk__pathname.length;
            const __gitalk__pathnameMaxLength = 50;
            if (__gitalk__pathnameLength > __gitalk__pathnameMaxLength) {
                __gitalk__pathname = __gitalk__pathname.substring(0, __gitalk__pathnameMaxLength - 3) + '...';
            }

            try {
                Gitalk && new Gitalk({
                    clientID: '2982aa7bca818df9e147',
                    clientSecret: '45eb0ac1328bfbca8db8c0340439fcce7e73d936',
                    repo: '838239178.github.io',
                    owner: '838239178',
                    admin: ['838239178'],
                    id: __gitalk__pathname,
                    language: 'zh-CN'
                }).render('gitalk-container');

            } catch (e) {
                window.Gitalk = null;
            }
        }

        if ('true') {
            const loadGitalkTimeout = setTimeout(() => {
                loadGitalk();
                clearTimeout(loadGitalkTimeout);
            }, 1000);
        } else {
            window.addEventListener('DOMContentLoaded', loadGitalk);
        }
    </script>



        
    
</div>

            </div>
        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2020</span>&nbsp;-&nbsp;
            
            2021&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">ShiJh</a>
        </div>
        
            <script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        访问人数&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
                    <span id="busuanzi_container_site_pv">
                        总访问量&nbsp;<span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动&nbsp;|&nbsp;主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.1</a>
        </div>
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
            <li class="go-comment">
                <i class="fas fa-comment"></i>
            </li>
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fas fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-text">JavaWeb-Spring</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E2%80%8B%E3%80%81%F0%9F%9A%B6JavaSE"><span class="nav-text">一​、🚶JavaSE</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%F0%9F%90%B4JSP-Servlet"><span class="nav-text">二、🐴JSP&#x2F;Servlet</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JSP"><span class="nav-text">JSP</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JSTL"><span class="nav-text">JSTL</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Servlet"><span class="nav-text">Servlet</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#EL%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">EL表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ExtraDetail"><span class="nav-text">ExtraDetail</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ProxyMode"><span class="nav-text">ProxyMode</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MVC%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F"><span class="nav-text">MVC开发模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84"><span class="nav-text">三层架构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Bootstrap-JQuery-AJAX"><span class="nav-text">Bootstrap&#x2F;JQuery&#x2F;AJAX</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E2%80%8B%E3%80%81%F0%9F%9A%B2JDBC-SQL"><span class="nav-text">三​、🚲JDBC&#x2F;SQL</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL"><span class="nav-text">MySQL</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1"><span class="nav-text">事务</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="nav-text">基本介绍</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9B%9B%E5%A4%A7%E7%89%B9%E5%BE%81"><span class="nav-text">四大特征</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-text">隔离级别</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JDBC"><span class="nav-text">JDBC</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-text">使用方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E5%AF%B9%E8%B1%A1%E8%AF%A6%E8%A7%A3"><span class="nav-text">常用对象详解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86"><span class="nav-text">事务管理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95-v2"><span class="nav-text">使用方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0"><span class="nav-text">数据库连接池</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8E%9F%E7%90%86"><span class="nav-text">原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="nav-text">实现方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Spring-JdbcTemplete"><span class="nav-text">Spring JdbcTemplete</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Junit4"><span class="nav-text">Junit4</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%A8%E8%A7%A3"><span class="nav-text">注解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95"><span class="nav-text">测试方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-Jedis"><span class="nav-text">Redis&#x2F;Jedis</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%F0%9F%9A%97SSM"><span class="nav-text">四、🚗SSM</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring"><span class="nav-text">Spring</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#IOC"><span class="nav-text">IOC</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#ioc%E5%AE%B9%E5%99%A8"><span class="nav-text">ioc容器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#XML%E5%BC%8F%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5"><span class="nav-text">XML式依赖注入</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B3%A8%E8%A7%A3%E5%BC%8F%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5"><span class="nav-text">注解式依赖注入</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AOP"><span class="nav-text">AOP</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5"><span class="nav-text">概念</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#XML%E9%85%8D%E7%BD%AE%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="nav-text">XML配置动态代理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B3%A8%E8%A7%A3%E9%85%8D%E7%BD%AE%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="nav-text">注解配置动态代理</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Spring%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6"><span class="nav-text">Spring事务控制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BC%96%E7%A8%8B%E5%BC%8F%E6%8E%A7%E5%88%B6"><span class="nav-text">编程式控制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#XML%E5%A3%B0%E6%98%8E%E5%BC%8F%E6%8E%A7%E5%88%B6"><span class="nav-text">XML声明式控制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B3%A8%E8%A7%A3%E5%A3%B0%E6%98%8E%E5%BC%8F%E6%8E%A7%E5%88%B6"><span class="nav-text">注解声明式控制</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Spring-Junit"><span class="nav-text">Spring-Junit</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Spring-JdbcTemplate"><span class="nav-text">Spring-JdbcTemplate</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Spring-web"><span class="nav-text">Spring-web</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SpringMVC"><span class="nav-text">SpringMVC</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%84%E4%BB%B6%E8%A7%A3%E6%9E%90"><span class="nav-text">组件解析</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8E%9F%E7%90%86%E5%9B%BE%E8%A7%A3"><span class="nav-text">原理图解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%84%E4%BB%B6%E8%AF%A6%E8%A7%A3"><span class="nav-text">组件详解</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#XML%E9%85%8D%E7%BD%AE"><span class="nav-text">XML配置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%A8%E8%A7%A3%E9%85%8D%E7%BD%AE"><span class="nav-text">注解配置</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B3%A8%E8%A7%A3%E9%85%8D%E7%BD%AEweb-xml"><span class="nav-text">注解配置web.xml</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94"><span class="nav-text">数据响应</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC"><span class="nav-text">页面跳转</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9B%9E%E5%86%99%E6%95%B0%E6%8D%AE"><span class="nav-text">回写数据</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%8E%B7%E5%BE%97%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0"><span class="nav-text">获得请求参数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0"><span class="nav-text">文件上传</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%99%A8"><span class="nav-text">自定义类型转换器</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE"><span class="nav-text">静态资源访问</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Session%E7%AE%A1%E7%90%86"><span class="nav-text">Session管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8B%A6%E6%88%AA%E5%99%A8-Interceptor"><span class="nav-text">拦截器 Interceptor</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="nav-text">自定义拦截器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8B%A6%E6%88%AA%E5%99%A8%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="nav-text">拦截器执行顺序</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6"><span class="nav-text">异常处理机制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%99%A8"><span class="nav-text">异常处理器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%99%A8"><span class="nav-text">自定义异常处理器</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8Junit%E4%B8%AD%E4%BD%BF%E7%94%A8MockMvc"><span class="nav-text">在Junit中使用MockMvc</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95-v3"><span class="nav-text">使用方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#MockMvc"><span class="nav-text">MockMvc</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Mybatis-Spring"><span class="nav-text">Mybatis-Spring</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#IOC%E6%B3%A8%E5%85%A5"><span class="nav-text">IOC注入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6"><span class="nav-text">事务控制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ExtraDetail-v2"><span class="nav-text">ExtraDetail</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Properties-ResourceBundle"><span class="nav-text">Properties&#x2F;ResourceBundle</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Restful"><span class="nav-text">Restful</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#FastJson"><span class="nav-text">FastJson</span></a></li></ol></li></ol></li></ol></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>



<script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.1/source/js/utils.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.1/source/js/main.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.1/source/js/header-shrink.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.1/source/js/back2top.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.1/source/js/dark-light-toggle.js"></script>


    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.1/source/js/local-search.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.1/source/js/code-copy.js"></script>




<div class="post-scripts pjax">
    
        <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.1/source/js/left-side-toggle.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.1/source/js/libs/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.1/source/js/toc.js"></script>
    
</div>


    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.1/source/js/libs/pjax.min.js"></script>
<script>
    window.addEventListener('DOMContentLoaded', () => {
        const pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });
</script>



</body>
</html>
