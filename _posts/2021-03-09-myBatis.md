---
layout: post
cover: 'assets/images/shiroAlice.png'
title: MyBatis
date: 2021-03-09
tags: java web
author: sjh
description: 由JavaWeb-Spring分支出来，主要讲述原始Mybatis的用法
---

# :bird:MyBatis

mybatis是一个优秀的持久层框架，通过配置的方式即可对数据库进行持久化操作。

> 推荐IDEA插件[FreeMyBatisPlugin](https://plugins.jetbrains.com/plugin/8321-free-mybatis-plugin)。

## 配置详解

**Maven坐标**

```xml
<dependency>
  <groupId>org.mybatis</groupId>
  <artifactId>mybatis</artifactId>
  <version>x.x.x</version>
</dependency>
```

### XML核心配置

#### 运行环境配置

运行环境需要指定数据库连接池和事务管理类型。完成以下配置即可完成最简单的持久化操作。

- 数据源环境

  ```xml
  <environments default="id">
      <environment id="">
          <transactionManager type="JDBC"/>
          <dataSource type="POOLED">
              <property name="" value="${}"/>
          </dataSource>
      </environment>
  </environments>
  ```

  数据源环境可以配置多个，其中指定一个ID为默认运行环境，配置DataSource的方法与Spring配置相似，同样可以使用properties文件。

- 加载映射文件

  ```xml
  <mappers>
  	<mapper resource="xml-url"/>
  </mappers>
  ```

#### 详细配置

- **environment**

  `transactionManager`：事务管理器类型，分为 JDBC、MANAGED

  `dataSource`：连接池类型，分为UNPOOLED、POOLED、JNDI，**也可以指定一个实现`UnpooledDataSourceFactory`的类作为type，如果要使用第三方连接池就需要这么做**

  `JDBC`和`POOLED`是最常用的，其他功能不做解释。

- **mapper**

  加载映射器可以使用多种方式，如以下三种：

  `resource`：相对类路径，相当于`classpath:`，用于加载映射器配置文件

  `class`：加载类，通过全限定类名加载，用于加载实现映射器接口的类（注解配置）

  `packagename`：加载包名下所有的类，同样是用于注解配置

- **properties**

  加载配置文件，使用`resource="path"`加载类下路径的文件，不需要加classpath

- **typeAliases**

  定义类型别名，用于简化全限定类名，创建别名和真名的映射关系。Mybatis内部将Java基础类型与包装器类型映射起来了，所以使用`int`、`double`等名称时，对应的是包装器类名。
  
- **typeHanlder**

  配置[自定义类型转处理器](#typeHandler)，需要包裹在`typeHanlders`中，通过属性`handler="类全限定名"`配置一个处理器。


### XML映射关系配置

#### 命名空间

每个映射文件对应一个命名空间，需要在标签内指定。命名空间的作用同Java包，使用映射关系时，需要以命名空间为开头的路径。

```xml
<mapper namespace="spaceName"></mapper>
```

#### sql语句配置

`id`是语句的标识符，sql语句可以直接写在标签中。

- SELECT

  ```xml
  <!--resultType是返回结果的类型，指定一个类Mybatis能够自动封装-->
  <select id="" resultType="">sql</select>
  ```

- UPDATE

  `<update id="" parameterType="">sql</update>`

- DELETE

  `<delete id="" >sql</delete>`

- INSERT

  `<insert id="" >sql</insert>`

##### 使用占位符

mybatis中占位符用`#{name}`表示，这个占位符是安全的，与Jdbc的`?`一样。在符号内部可以填写多个属性，如限定这个占位符的类型等，更多属性的设置请到官方文档中查询。

```sql
#{id, javaType=int, jdbcType=NUMERIC}
```

**用实体对象作为占位符参数**

Mybatis具备将复杂对象的属性配置到占位符中的功能，其中对象的属性名需要和占位符内`name`的参数名保持一致，mybatis即可自动的配置到占位符中。

sql标签使用`parameterType`属性可以指定该条语句所需要的参数对象类型，在缺省的情况下Mybatis能够自动推断。

#### ResultMap

[测试用例子](https://github.com/838239178/SpringStudy/tree/master/mybatis_study/src)

结果映射，通过`resultType`指定的类型，能够被mybatis自动创建并设置其中的属性值，当列名和属性名匹配上时，不需要额外配置，而复杂情况下可以通过显式配置`resultMap`的方式完成映射，大多数情况下ResultMap在配置一对一、一对多、多对多关联查询时使用。

1.  配置一个所需的resultMap

   ```xml
   <resultMap  id="" type="class">
       <!--把class的属性名同列名关联起来-->
       <id property="" column=""/>
   	<result property="name" column="name"/>
       <!--一对一关系映射-->
       <assosiation property="" javaType="class"></assosiation>
       <!--一对多/多对多关系映射-->
       <collection property="" ofType="class"></collection>
   </resultMap>
   ```

   主键一般使用`<id>`标签来配置。

2.  将sql语句的`resultType`更换为`resultMap`

   ```xml
   <select resultMap="mapId">sql</select>
   ```

[更加复杂的高级结果映射请看官方文档](https://mybatis.org/mybatis-3/zh/sqlmap-xml.html#Result_Maps)包含多表关系查询需要的复杂嵌套映射

#### 缓存优化

当一条语句被调用时，mybatis能够将其返回结果缓存起来，若有多次查询则可以使用缓存直接返回。

Select语句默认是打开缓存的，缓存开启方式如下：

在sql语句标签中添加属性`useCache="true"`即可开启，当使用属性`flushCache="true"`时，调用sql会刷新缓存区，默认为`false`

### 注解配置

## 动态SQL

在配置映射关系时，Mybatis提供了一系列标签，使得sql语句能够动态的生成。根据参数不同，在同一个标签下能够生成不同语句。

###  动态标签

动态标签是用于`select`等标签内部，用来动态生成sql语句的标签。

- `<where>`

  用于包裹其他动态标签，防止不使用条件判断时造成sql语法问题，当`where`标签内没有生成任何sql语句时，不会在原有sql上加入where字段，反之则加上where字段。*（实际上是添加一个' where 1=1 '）*

- `<if>`

  ```xml
  <if test="bool表达式">
      sql
  </if>
  ```

- `<foreach>`

  ```xml
  <foreach collection="集合类型" open="开始字段" close="结束字段" item="name" separator="分隔符">
  	sql，使用#{name}引用item
  </foreach>
  ```
  
- `<trim>` 与where用法相似

  ```xml
  <trim perfix="" suffix="" prefixOverrides="" suffixOverrides="">
  	sql
  </trim>
  ```

  |      属性       |                             描述                             |
  | :-------------: | :----------------------------------------------------------: |
  |     perfix      |                     给sql语句拼接的前缀                      |
  |     suffix      |                     给sql语句拼接的后缀                      |
  | prefixOverrides | 去除sql语句前面的关键字或者字符，该关键字或者字符由prefixOverrides属性指定，假设该属性指定为"AND"，当sql语句的开头为"AND"，trim标签将会去除该"AND" |
  | suffixOverrides | 去除sql语句后面的关键字或者字符，该关键字或者字符由suffixOverrides属性指定 |

### 片段抽取

`<sql>`片段标签，使用这个标签可以抽取重复片段，并使用标签id作为变量代替。

**创建sql片段**

```xml
<sql id="">sql</sql>
```

**引用sql片段**

```xml
<include refid="sqlId"/>
```

## Plugins

使用第三方插件或自己开发的插件对Mybatis的功能进行拓展

### 配置Plugin

```xml
<plugins>
	<plugin interceptor="类全限定名">
        <property name="" value=""/>
    </plugin>
</plugins>
```

### 常用插件

- [pageHelper](https://search.maven.org/artifact/com.github.pagehelper/pagehelper/)

  非常好用的分页插件，简单的参数设定，简单的数据获取。

  ```xml
  <dependency>
    <groupId>com.github.pagehelper</groupId>
    <artifactId>pagehelper</artifactId>
  </dependency>
  ```

### 自定义插件

实现`Interceptor`接口，主要实现三个方法

1. 核心方法，通过`invocation`参数能够获得映射好的sql语句，该方法的返回值是invocation对象proceed方法的返回值，与[Proxy代理模式](https://blog.pressed.top/javaweb#proxymode)一样。

   ```java
   public Object intercept(Invocation invocation) throws Throwable {}
   ```

2. 主要用来将对象封装成代理对象，确保`interceptI()`能够被调用

   ```java
   public Object plugin(Object target) {
   	// 一般都是通过该方法封装
       return Plugin.wrap(target, this);
   }
   ```

3. 提供插件自定义属性，这个方法的属性能够在配置阶段进行注入

   ```java
     public void setProperties(Properties properties) {}
   ```

#### 配置拦截注解

在自定义插件类完成后，需要使用注解`@Intercepts`来表明该插件需要拦截的方法签名。

Mybatis只允许拦截以下类中的方法：

- Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)
- ParameterHandler (getParameterObject, setParameters)
- ResultSetHandler (handleResultSets, handleOutputParameters)
- StatementHandler (prepare, parameterize, batch, update, query)

```java
@Intercepts({@Signature(
  type= Executor.class,
  method = "update",
  args = {MappedStatement.class,Object.class})})
```

- `@Singnature`：表示一个构造一个方法签名
  - type：被拦截类名
  - method：被拦截类中的方法名
  - args：被拦截方法的参数

## JAVA-API   

使用mybatis提供的java开发包，用java对数据库进行持久化操作。

### 快速入门

快速入门演示了mybatis-api的一个基本使用流程

```java
//1. 加载核心配置
InputStream configStream = Resources.getResourcesAsStream("sqlMapConfig.xml");
//2. 获得SqlSession工厂对象
SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(configStream);
//3. SqlSession对象
SqlSession session = factory.openSession();
//4. 执行sql语句
List<Object> list = session.selectList("mapping-parttern");
// 提交事务
session.commit();
//5. 释放SqlSession
session.close();
```

### 常用对象详解

- SqlSession

  mybatis主要的java接口，一切数据库操作都是由这个对象完成的。其地位类似于JdbcTemplate，在使用spring时也能通过IOC进行注入。

  主要方法有`selectXxx()`、`update()`、`delete()`以及事务管理的`commit、rollback`等

- SqlSessionFactoryBuilder

  用于创建SqlSessionFactory的对象，其中构建方法为`build()`，支持使用`InputStream`加载配置文件来创建工厂对象。

- SqlSessionFactory

  创建SqlSession对象的工厂类，用`openSession()`方法创建，可以使用其重载来设置SqlSession的一些属性，如是否自动提交事务以及事物的隔离级别等。

  引用官方文档的一段话

  > SqlSessionFactory 有六个方法创建 SqlSession 实例。通常来说，当你选择其中一个方法时，你需要考虑以下几点：
  >
  > - **事务处理**：你希望在 session 作用域中使用事务作用域，还是使用自动提交（auto-commit）？（对很多数据库和/或 JDBC 驱动来说，等同于关闭事务支持）
  > - **数据库连接**：你希望 MyBatis 帮你从已配置的数据源获取连接，还是使用自己提供的连接？
  > - **语句执行**：你希望 MyBatis 复用 PreparedStatement 和/或批量更新语句（包括插入语句和删除语句）吗？

### DAO层接口代理

Mybatis能够将编写的`Mapper.xml`通过Java的接口进行动态代理，使得开发人员调用dao接口就能完成mapper中定义的数据库操作。使用接口代理的有以下的条件约束：

1. mapper中**namesapce**属性的值需要为所需接口的全限定名。
2. mapper中每个定义的sql语句**id**属性需要与接口中的方法名一一对应。
3. sql语句的参数类型、结果类型即为接口方法的参数和返回值。
4. 接口的设计不能使用重载。

:information_source:*使用IDEA插件能够根据数据库关系自动生成实体和接口*

#### API

通过`SqlSession`的`getMapper(dao.class)`获得接口的代理对象，直接使用接口即可。

### typeHandler

类型处理器，在Mybatis生成`PreparedStatement`或获取结果时会调用类型处理器来转化sql所需的参数。Mybatis默认使用了许多转换器，在使用时能够自动推断类型使用响应转换器，也能事先通过`parameterType`、`resultType`指明参数类型。

#### 自定义typeHandler

类型转换器需要实现`TypeHandler`接口或继承`BaseTypeHandler<T>`类，泛型为需要自定义转化的Java类。

- parameter转化逻辑

  当mybatis设置数据到数据库时调用，使用这个方法来自定义参数转化逻辑

  ```java
  @Override
  public void setNonNullParameter(PreparedStatement preparedStatement, int i, T obj, 
                                  JdbcType jdbcType) {
      //直接使用preparedStatement的set方法设置参数'obj'，参数的index为'i'
  }
  ```

- result转化逻辑

  从数据库取出数据时调用的转化方法

  ```java
  //从三类不同的结果集取出给定的数据并转化成Java数据，第二个参数即为结果集中所需参数的位置
  @Override
  public T getNullableResult(ResultSet resultSet, String s) {}
  
  @Override
  public T getNullableResult(ResultSet resultSet, int i) {}
  
  @Override
  public T getNullableResult(CallableStatement callableStatement, int i) {}
  ```