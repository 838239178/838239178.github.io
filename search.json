[{"title":"背包问题2","url":"/2019/12/15/bagProblem2/","content":"这道题是一道动态规划(dp)算法的基础题，有两种实现方式，分别是递归和递推（迭代），前者比后者好理解。\n\n\n题目来源：LintCode\n\n有 i 个物品和一个总容量为 j 的背包. 给定数组 weight 表示每个物品的重量和数组 value 表示每个物品的价值，求最大价值。（物品不能分割）\n\n\n背包问题II\n这道题是一道动态规划(dp)算法的基础题，有两种实现方式，分别是递归和递推（迭代），前者比后者好理解。\n○解题思路\n首先，题目的要求是找出最大价值，所以我们要想，怎么存放才能让他的价值最大呢？因为物品具有重量，背包容量也有限，所以我们不能每次都放入最大价值的物品，举个例子，假设背包容量为 12，现在有三个物品对应价值和重量的关系如下表\n\n\n\n物品\n质量\n价值\n\n\n\n\nA\n10\n8\n\n\nB\n6\n5\n\n\nC\n5\n4\n\n\n\n显然我们就要选B和C,然后有人可能就会灵光一闪，那全都选择性价比（价值/质量）最大的不就行了（贪心算法），但是题目还有要求“物品不能分割”，所以实际上我们不能使用贪心算法。\n我们可以从最普通的思考方式得到一个动态规划的递推式子。我们有i个物品，考虑到重量的情况下，按照通常人类的想法就是找出各种组合，然后依次比较这些组合的价值，选最大的那个就行了，所以我们线性遍历i个物品的时候就有两种选择，“要”和“不要”，\n每个物品都经历这两个选择，最终就是产生全部的组合方式。当轮到第i个物品的时候，我们的最大价值就是这样一个式子：maxvalue = max(value[i],value[i-1]) （并考虑每次选择背包能不能装得下）,意思就是要第i个物品和不要第i个物品那个情况得到的价值最大，因为判断i个物品我们需要知道i-1个时的最大价值，所以这个式子会一直传递到背包满了或者物品都确认完了，所以可以想到用递归来解决这个过程。\n○递归算法实现\n我们需要让程序知道每个物品的信息，因此需要两个数组来储存每个物品对应的信息（也可用一个结构体数组），分别是value[],weight[]。递归程序需要有会变化的参数，物品的价值和重量时不会变的，显然会变的是物品的数量和背包的剩余容量，所以可以写一个函数bag（前i个物品，剩余背包容量j);\n\n找到递归出口\n上文提到的，背包无剩余空间或者物品算完了，即（j==0||i==0)，此时它返回的最大价值应该是0；\n递推关系\n这个关系有两种，比较容易想到的是 ``maxvalue = max(bag(i-1,j),bag(i-1,j-weight[i])+value[i]) 前一个是“不要”，后一个是“要”； 还有一种情况是 当j!=0但是当前选择的物品的重量weight[i]`比剩下空间j多了，我们就要跳过这个物品，即强制选择“不要”。\n完成这两部我们就能初步得到递归的算法啦！\n\nint bag(int i, int j)  //递归实现\n&#123;\n\tif (i == 0 || j == 0)\n\t\treturn 0;\n\tif (weight[i] &gt; j)\n\t\treturn bag(i-1,j);\n\telse &#123;\n\t\tint res = max(bag(i - 1, j), bag(i - 1, j - weight[i]) + value[i]);\n\t\treturn res;\n\t&#125;\n        //max函数可以自己判断每一种情况下的最大价值（TIPS：对于递归程序不能刻意去思考它的过程，主要理解它的方向）\n&#125;\n然而这个还不能称为DP,因为这个效率极差，我们发现它计算几百种情况，难免会出现重复的，重复的节点可能是物品为i,重量为j，所以可以建立一个用来记录的二维数组maxdata[i][j]，每个i，j都是一种情况，储存这种情况下的最大价值，这样效率就能大大提高\nint bag(int i, int j)  //递归实现\n&#123;\n    if (maxdata[i][j] != EOF)   //一开始让每个点都等于EOF（-1），如果不是-1证明这个情况已经算过了，可以直接return\n        return maxdata[i][j];\n    if (i == 0 || j == 0)\n        return 0;\n    if (weight[i] &gt; j)\n        return bag(i-1,j);\n    else &#123;\n        int res = max(bag(i - 1, j), bag(i - 1, j - weight[i]) + value[i]);\n        maxdata[i][j] = res;     //没算过就存一下\n        return res;\n    &#125;\n&#125;\n○迭代算法\n迭代算法和递归算法有一个本质的区别，递归我们是从i个物品一直找到剩下1个，而迭代算法则恰恰相反，要从一个开始找出最大价值，并逐步向上得到i个物品能得到的最大价值，而我们要记录的是前i种物品在各种重量下的最大价值。（这是比较难理解的点）\n但是具体的判断方法仍然是“要”和“不要”的问题。因为是从1个开始，所以我们每轮递推的关键点在于重量，递推式还是那个样子max(maxdata[j],max[j-weight[i]]+value[i]);但是我们是根据数组中储存的前一轮的数据进行判断的。\n然后再来分析一下这个递推式，假如现在正计算i种物品，maxdata[j]则是i-1种物品对应j重量的最大价值，如果我们“不要”第i个物品，那么最大价值还是i-1个物品对应的最大价值，如果我们“要”第i个物品，那么要对应前i-1个物品在容量扣除weight[i]时的最大价值，然后加上value[i]。这两个数值哪个大就选哪个作为这一轮的最大价值，因为判断完成后上一轮对应的数据就没有用了 所以我们新的数据就可以覆盖在对应的位置，即maxdata[j] = max(maxdata[j],maxdata[j-weight[i]]+value[i]);\n核心代码奉上\n//递推（迭代） 滚动数组\nint f[100] = &#123; 0 &#125;;    //f[j]储存前一轮各个重量下最大价值\nfor (int i = 1; i &lt;= n; i++) &#123;       //枚举种类j\n    for (int  j = totalweight; j &gt;= 0; j--)&#123;   //算前n种的各个重量下最大价值\n        int next_w = j - weight[i];      //“要”这个物品的情况下对应的下标\n        if (next_w &lt; 0) next_w = 0;   //防止下标越界\n        if (weight[i] &gt; j)data\n            f[j] = f[j];    //超重则最大价值等于前一轮对应容量下的最大价值，直接“不要”\n        else \n            f[j] = max(f[j], f[next_w] + value[i]);\n        if(i==n) break;      //最后一个物品只需要算一个totalweight的就够了\n    &#125;\n&#125;//最终得到的f[totalweight]就是n个物品用整个背包去装能得到的最大价值。\n理解这个程序，只要搞懂i = 1 到 i = 2 的过程就能理解全部了。可以随便举个例子：假设背包容量为 12\n\n\n\n编号\n物品\n质量\n价值\n\n\n\n\n1\nA\n10\n8\n\n\n2\nB\n6\n5\n\n\n3\nC\n5\n4\n\n\n\n\n从第1个A开始，我们发现容量大于等于10的时候最大价值就是8，其他的都是0，此时f[]内的数据全是零，于是大于等于10以后的式子都会是f[j] = max(0,0+8),所以就能得到新的f[]；\nf[] = &#123;0 0 0 0 0 0 0 0 0 0 8 8 8 ……&#125;\n然后在看第二个物品B,\n在总容量为12时，有f[12] = max(f[12],f[12-6]+5) f[12]从前一轮得出等于8，f[6] = 0, 所以显然在这个容量的限制下，我们会选择“不要”。\n以此类推，我们可以发现直到 5&lt;j&lt;10 我们才会选择&quot;要”，因此可以得到这一轮的f[] = &#123;0 0 0 0 0 0 6 6 6 6 8 8 8……&#125;\n如果还没理解就，继续看下第三个物品C\n跟前一轮完全相同的想法，当j=12的时候，f[12] = max(f[12],f[12-5]+4) 我们发现 f[12] = 8 &lt; f[7]+5 = 11; 所以我们选择“要”\n因为这是最后一个了所以继续往下算已经没用了，我们已经得到3个物品，12容量下的最大价值则为 11 ；\n到这里迭代算法就算讲解完了！！\n\n○迭代算法的流程图\n\n○闲话\n第一次写这种博客，感觉还挺有趣的，最重要的是还能让自己复习学过的知识，本篇内容是按自己的理解写的，可能存在逻辑错误或者漏洞，如果发现问题还请评论指教。\n动态规划的学习可以参考mooc上郭伟的《算法与程序设计》，最简单的dp问题有 数字金字塔 等。动态规划太灵活了，没有固定的模板，要根据问题具体分析\n\n完整代码参考我的GitHub\n\n","tags":["algorithm","c/c++"]},{"title":"角色与地图遮挡","url":"/2020/05/12/roleAndMap/","content":"曾经学习CocosCreater引擎时遇见的问题，现在已经放弃学习了\n\n○前言\n2d地图与角色的互相遮挡是我在短暂的学习过程中遇到的第一个难点，即使cocos creator（以下简称 cc）的TiledMap组件提供了addUserNode这个方法，但是实际效果不尽人意，经常穿模。在官方社区寻找解决办法的时候我了解到了一种比较高级的做法，大概就是动态的提取和加载地图块来形成互相遮挡，但是实现难度较大，涉及cc引擎的修改，于是乎我就自己想了这个方法。\n○实现原理\n这个方法很简单就是利用addUserNode把角色添加到地图的某一层中，但是那一层的图片本身不能让角色碰撞到，不然还是会穿模。在该层中的图片（包括添加进去的角色）都是遵循Tiledmap里面图层之间的关系的，所以可以把地图总体的分成三个部分，一个是需要被角色遮挡的部分，一个是需要遮挡角色的部分，以及角色所在的部分，这三个的顺序是固定的如图所示。\n\n○实现方法\n首先就是要把地图按照这个模式去制作，然后重点是如上图所示的npc层要在地图均匀的添加2~4个地图块（尽可能的替换其他层中不会与角色产生碰撞的地方）不然游戏中添加进去的角色无法显示在在地图上层，具体原因不明，涉及addUserNode的算法。然后如果你是使用如上图的meta层去记录障碍物信息的话  最好把角色的Anchor设为（0.5,0）以免发生如下情况：\nAnchor为（0.5,0.5）：\n\nAnchor为（0.5,0）：\n\n图片中建筑的上部分为（cover）层，下部分为（becover）层且有meta障碍物信息。\n如果使用碰撞体组件的就不会有这种情况。\n○缺点和瑕疵\n如果使用的时meta层判断障碍物的话会放生以下比较尴尬的情况：\n1.因为Anchor的x是图片中间，判断的时候是使用Anchor的坐标\n\n2.当Anchor的位置产生阻挡时角色似乎念在了墙壁上\n\n以上情况使用碰撞体组件时都不会发生，如果改进meta层判断的算法可能可以避免\n本人是初学者，如有错误和改进方法还请指出\n","tags":["cocos","tiledmap"]},{"title":"城市间紧急救援","url":"/2020/05/18/cityRescue/","content":"来自PTA的一道最短路径算法题\n\n○题目要求\n作为一个城市的应急救援队伍的负责人，你有一张特殊的全国地图。在地图上显示有多个分散的城市和一些连接城市的快速道路。每个城市的救援队数量和每一条连接两个城市的快速道路长度都标在地图上。\n当其他城市有紧急求助电话给你的时候，你的任务是带领你的救援队尽快赶往事发地，同时，一路上召集尽可能多的救援队。\n○输入格式:\n输入第一行给出4个正整数N、M、S、D，其中N（2≤N≤500）是城市的个数，顺便假设城市的编号为0 ~ (N−1)；M是快速道路的条数；S是出发地的城市编号；D是目的地的城市编号。\n第二行给出N个正整数，其中第i个数是第i个城市的救援队的数目，数字间以空格分隔。随后的M行中，每行给出一条快速道路的信息，分别是：城市1、城市2、快速道路的长度，中间用空格分开，数字均为整数且不超过500。输入保证救援可行且最优解唯一。\n○输出格式:\n第一行输出最短路径的条数和能够召集的最多的救援队数量。第二行输出从S到D的路径中经过的城市编号。数字间以空格分隔，输出结尾不能有多余空格。\n○输入样例:\n4 5 0 3\n20 30 40 10\n0 1 1\n1 3 2\n0 3 3\n0 2 2\n2 3 2\n○输出样例:\n2 60\n0 1 3\n○解题思路\n利用Dijsktra算法进行变式，因为题目要求的权值有两种，且长度优先级大于救援人数，因此自定义一个类/结构体来表示dist[]，并按照需求重载操作符。\nclass node\n&#123;\npublic:\n\tint dis;\n\tint manNum;\n\tnode(int a = INF, int b = 0):dis(a),manNum(b)&#123;&#125;\n\tbool operator &lt; (const node &amp; a) &#123;\n\t\tif (dis == a.dis)\n\t\t\treturn manNum &gt; a.manNum;\n\t\telse\n\t\t\treturn dis &lt; a.dis;\n\t&#125;\n\tbool operator &gt; (const node&amp; a) &#123;\n\t\treturn !(*this &lt; a);\n\t&#125;\n\tnode operator + (const node&amp; a) &#123;\n\t\treturn node&#123; dis + a.dis, manNum + a.manNum &#125;;\n\t&#125;\n&#125;;\n本题重点是最短路径条数，要想到如 a-&gt;b-&gt;c , a-&gt;c的条数等于a-&gt;b的条数加上b-&gt;c的条数这个递推思想，具体实现方法就是数组再每次遍历邻接点的时候进行判断。\n//entry 入口\n//pathchoice entry-&gt;每个点的最短路径条数\npathchoice[entry] = 1;\n//访问v的每一个邻接点w\nfor (int w = 0; w &lt; n; w++) &#123;\n\tif (!visted[w] &amp;&amp; mg[v][w] != INF) &#123;\n\t\tnode temp = node&#123; mg[v][w],rescue[w] &#125;;\t\t\t\t\n\t\tif (dist[w].dis == temp.dis + dist[v].dis)            //1.如果entry-&gt;w的最短距离和entry-&gt;v-&gt;w的距离相等，则entry-&gt;w的条数就要进行递推\n\t\t\tpathchoice[w] += pathchoice[v];\n\t\tif (dist[w] &gt; dist[v] + temp) &#123;\n\t\t\tdist[w] = dist[v] + temp;\n\t\t\tpath[w] = v;\n\t\t\tpathchoice[w] = max(pathchoice[w],pathchoice[v]);      //2.真正要保留的是最短路径的条数\n\t\t&#125;\t\t\t\t\n\t&#125;\n&#125;\n这里要解释一下为什么1，2两点是分开且顺序不能颠倒。因为最短路径条数不同于最优路径，最短路径不需要考虑救援人数，如果颠倒了顺序就可能会导致最短路径条数因为最优路径的关系先一步发生变化。\n然后2的地方用了一个max()，是因为即使满足1也有可能进入这个if(详见claass node中重载的运算符), 本来pathchoice[w] = pathchoice[v] 应该是第一次遍历到做的赋值，但是可能在前几次遍历中已经经过了1，\n所以应该保留最大的哪个数才是最短路径的条数。\nAC代码参考: github\n","tags":["algorithm","c/c++"]},{"title":"使用BaiduOcr识别图片文字","url":"/2021/02/14/signUpBaiduOcr/","content":"百度AI平台提供了很多AI接口，大部分都提供了免费的调用额度，如果是个人使用可以获得很大的便利，这里将介绍如何使用百度提供的文字识别接口。包含注册申请以及使用例！\n\n使用BaiduOcr识别图片文字\n百度AI平台提供了很多AI接口，大部分都提供了免费的调用额度，如果是个人使用可以获得很大的便利，这里将介绍如何使用百度提供的文字识别接口。\n○注册并申请使用权\nBaiduAI官网进入后点击右上角控制台进行登录\n○注册百度账号\n百度账号注册这里不再赘述，进入控制台登陆时即可注册。\n○实名认证\n\n\n登入控制台后会要求填写以下信息来激活账号，只需要填写*号信息栏。\n\n\n\n完成后点击左侧工具栏的文字识别，如下图所示\n\n\n\n点击立即认证，填入姓名和身份后点击下一步，无需刷脸验证，直接返回上一步的页面即可\n\n\n\n○创建文字识别应用\n\n\n回到控制台后点击 创建应用，填一些信息，不需要包名并选择所属为个人\n\n\n\n创建完成后点击 应用详情 ，进入页面后请记住API Key和Secret Key\n\n\n\n○调用API识别图\n○获取Token\n每隔一段时间使用前都需要获取Token，一个Token的有效期为30分钟\n通过发送HTTP Get请求token：\n\n\nurl：https://aip.baidubce.com/oauth/2.0/token?grant_type=client_credentials&amp;client_id=&#123;API_Key&#125;&amp;client_secret=&#123;Secret_Key&#125;\n\n\n请求中携带参数API_key和Secret_key替换为你刚才申请的两个值，当然&#123;&#125;需要删除！\n\n\n请求成功将获得一串Json，例如\n&#123;\n  \"refresh_token\": \"25.b55fe1d287227ca97aab219bb249b8ab.315360000.1798284651.282335-8574074\",\n  \"expires_in\": 2592000,\n  \"scope\": \"public wise_adapt\",\n  \"session_key\": \"9mzdDZXu3dENdFZQurfg0Vz8slgSgvvOAUebNFzyzcpQ5EnbxbF+hfG9DQkpUVQdh4p6HbQcAiz5RmuBAja1JJGgIdJI\",\n  \"access_token\": \"24.6c5e1ff107f0e8bcef8c46d3424a0e78.2592000.1485516651.282335-8574074\",\n  \"session_secret\": \"dfac94a3489fe9fca7c3221cbf7525ff\"\n&#125;\n我们只需要获取access_token即可\n若返回失败则会得到包含error_description的Json信息\n\n\n○调用所需接口\n文字识别分为通用文字识别、通用文字识别（高精度），不同的接口有不同的免费额度\n通过发送HTTP POST上传图片数据或者地址进行文字识别\n\n\nurl：https://aip.baidubce.com/rest/2.0/ocr/v1/&#123;ocr_type&#125;?access_token=&#123;token&#125;\n此处ocr_type根据不同的识别方式变化，可以用“general_basic”或者“accurate_basic”替换.\ntoken是上一步获取的access_token\n\n\npost的请求体为表单类型，分为两种方式\n\n\n图片数据\n图片数据必须使用Base64编码，并用以下格式作为请求体\n\n\n\nkey\nvalue\n\n\n\n\nimage\nbase64数组\n\n\n\n\n\n图片地址\n\n\n\nkey\nvalue\n\n\n\n\nurl\nurl字符串\n\n\n\n仅general_basic支持用网络图片\n\n\n\n\n请求完成后将返回 Json 数据\n&#123;\n    \"log_id\": 2471272194,\n    \"words_result_num\": 2,\n    \"words_result\": [\n        &#123;\"words\": \" example\"&#125;,\n        &#123;\"words\": \"helloworld\"&#125;\n    ]\n&#125;\n出错则会返回包含err_msg的 Json 数据，具体错误类型可见官方文档\n\n\n○Python使用例\n点此到Github中查看上述介绍的内容分别对应def _get_token()和def general_ocr(img_b64)\n○额外选择\n百度ocr还包含很多种类型具体请查看 官方文档，调用api时也可传入其他参数，如是否检测图片方向、图片需要识别的语言等，这里就不多介绍，入门后看官方文档就没有任何问题了。\n","tags":["web","ai"]},{"title":"Java Simple Calculator","url":"/2020/11/18/JavaSimpleCalculator/","content":"swing ui 编写、功能简单且存在一点瑕疵的计算器程序\n\n简易计算器\n○程序解释\n○原理详解\n从类的设计的角度上来讲，计算器应该是界面与操作分离，由界面程序获取操作数并传递给计算程序，从计算程序中获取结果。\n○类的设计\n\n\nCalculator\n用于计算的类，传入操作数和操作符后可获取结果，运算错误抛出异常。\n\n\nCalculator Frame\n计算器的界面类，提供操作数和操作符。\n\n\n○结构解析\nCalculator类采用两个堆栈分别存放运算数和操作符，在计算时从中抛出操作数与操作符。对小数和负数，采用标记位进行判断。\n小数：当输入了小数点“.“后，记录接下来输入数字的个数，在数字输入结束后（即输入操作符）时，将栈中的第一位数抛出并转化为小数\n负数：当输入了”neg&quot;标记后，同上，在同一时刻转化成负数\n输入数字或者操作符后，自动检查堆栈元素进行计算，因此这个简易计算器在按下“=”前，在特定情况下，会先计算部分算式；\n另一种思路：输入的任何符号都先记录起来等按下“=”时再进行读取数字和操作符进行运算\n○缺点\n因为即时运算的原因，计算器无法实现单步删除功能，只能直接清空重置计算器。代码可拓展性差，添加新的操作符运算可能需要改动部分原有逻辑。\n要不要改？卧槽，我懒啊！\n○源码展示\n○Calculator.java\npackage calculator;\n\nimport com.sun.xml.internal.ws.api.ha.StickyFeature;\n\nimport java.math.BigDecimal;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\n\npublic class Calculator &#123;\n    private final HashMap&lt;String, Integer&gt; operatorPriority;\n\n    private final LinkedList&lt;Double&gt; numberStack;\n    private final LinkedList&lt;String&gt; operatorStack;\n\n    /**\n     * 是否开始输入下一个数字\n     */\n    private boolean nextNum;\n    /**\n     * 是否已经完成了一次计算\n     */\n    private boolean calculated;\n    /**\n     * 是否输入了小数\n     */\n    private boolean decimal;\n    private int decimalDigits;\n    /**\n     * 是否输入了负数\n     */\n    private boolean negative;\n\n    public Calculator() &#123;\n        operatorPriority = new HashMap&lt;&gt;();\n        numberStack = new LinkedList&lt;&gt;();\n        operatorStack = new LinkedList&lt;&gt;();\n\n        List&lt;String&gt; level1 = Arrays.asList(&quot;+&quot;, &quot;-&quot;);\n        List&lt;String&gt; level2 = Arrays.asList(&quot;*&quot;, &quot;/&quot;, &quot;%&quot;);\n        level1.forEach(op -&gt; operatorPriority.put(op, 1));\n        level2.forEach(op -&gt; operatorPriority.put(op, 2));\n\n\n        reset();\n    &#125;\n\n    public void reset() &#123;\n        calculated = true;\n        numberStack.clear();\n        operatorStack.clear();\n        numberStack.push(0.0);\n        nextNum = true;\n        negative = false;\n        decimal = false;\n        decimalDigits = 0;\n    &#125;\n\n    /**\n     * 是否已经完成了一次计算\n     */\n    public boolean isCalculated() &#123;\n        return this.calculated;\n    &#125;\n\n    /**\n     * 获得计算结果\n     *\n     * @return 计算结果\n     * @throws ArithmeticException 如果输入不合法运算公式则抛出这个异常\n     */\n    public double getResult() throws ArithmeticException &#123;\n        tryDecimal();\n        tryNegative();\n\n        while (!numberStack.isEmpty() &amp;&amp; !operatorStack.isEmpty()) &#123;\n            double num2 = numberStack.pop();\n            double num1 = numberStack.pop();\n            String operator = operatorStack.pop();\n            numberStack.push(calculate(num1, num2, operator));\n        &#125;\n\n        calculated = true;\n\n        if (numberStack.isEmpty()) &#123;\n            return 0.0;\n        &#125; else &#123;\n            return numberStack.peek();\n        &#125;\n    &#125;\n\n    /**\n     * 输入一个操作数\n     *\n     * @param value 整数\n     */\n    public void inputNum(int value) &#123;\n        double number = value;\n        if (!nextNum) &#123;\n            number = numberStack.pop();\n            number = number * 10 + value;\n            if (decimal) decimalDigits++;\n        &#125;\n        numberStack.push(number);\n\n        //开始输入当前这个数字\n        nextNum = false;\n        //还未完成一次计算\n        calculated = false;\n    &#125;\n\n    /**\n     * 输入一个运算符号\n     *\n     * @param op 运算符号，目前仅支持“+、-、*、/“，支持小数和负数\n     * @throws ArithmeticException 如果输入不合法运算公式则抛出这个异常\n     */\n    public void inputOperator(String op) throws ArithmeticException &#123;\n        //输入运算符时意味着正在进行运算（即未完成）\n        calculated = false;\n\n        if (op.equals(&quot;.&quot;)) &#123;\n            decimal = true;\n            return;\n        &#125;\n\n        if(op.equals(&quot;neg&quot;))&#123;\n            negative = !negative;\n            return;\n        &#125;\n\n        tryDecimal();\n        tryNegative();\n\n        while (!operatorStack.isEmpty() &amp;&amp; compareOperator(op, operatorStack.peek()) &lt; 0) &#123;\n            Double num2 = numberStack.pop();\n            Double num1 = numberStack.pop();\n            String operator = operatorStack.pop();\n            numberStack.push(calculate(num1, num2, operator));\n        &#125;\n\n        operatorStack.push(op);\n\n        //输运算符后意味着开始输入下一个数字\n        nextNum = true;\n    &#125;\n\n    /**\n     * 检验是否输入了小数\n     */\n    private boolean tryDecimal() &#123;\n        //如果刚刚输入的数字（即栈顶）是小数\n        if (decimal) &#123;\n            double top = numberStack.pop();\n            top *= Math.pow(10, -1 * decimalDigits);\n            numberStack.push(top);\n\n            //下一个数字不一定是小数，重置小数参数\n            decimal = false;\n            decimalDigits = 0;\n\n            return true;\n        &#125;\n        return false;\n    &#125;\n\n    private boolean tryNegative() &#123;\n        if(negative)&#123;\n            double top = numberStack.pop();\n            numberStack.push(-top);\n\n            //重置标记\n            negative = false;\n\n            return true;\n        &#125;\n        return false;\n    &#125;\n\n    private double calculate(double num1, double num2, String op) &#123;\n        //使用string类型消除double精度误差\n        BigDecimal bigNum1 = new BigDecimal(String.valueOf(num1));\n        BigDecimal bigNum2 = new BigDecimal(String.valueOf(num2));\n        BigDecimal result;\n        switch (op) &#123;\n            case &quot;+&quot;:\n                result = bigNum1.add(bigNum2);\n                break;\n            case &quot;-&quot;:\n                result = bigNum1.subtract(bigNum2);\n                break;\n            case &quot;*&quot;:\n                result = bigNum1.multiply(bigNum2);\n                break;\n            case &quot;/&quot;:\n                result = bigNum1.divide(bigNum2, BigDecimal.ROUND_HALF_UP);\n                break;\n            default:\n                throw new ArithmeticException();\n        &#125;\n\n        return result.doubleValue();\n    &#125;\n\n    private int compareOperator(String op1, String op2) &#123;\n        int op1Level = 0, op2Level = 0;\n\n        op1Level = operatorPriority.get(op1);\n        op2Level = operatorPriority.get(op2);\n\n        return op1Level - op2Level;\n    &#125;\n\n&#125;\n○CalculatorFrame.java\npackage calculator;\n\nimport javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\n\npublic class CalculatorFrame extends JFrame &#123;\n    //region -JComponents-\n    private JPanel northPanel;\n    private JPanel centerPanel;\n    private JPanel numberPanel;\n    private JPanel operatorPanel;\n    private JPanel southPanel;\n    private JPanel westPanel;\n    private JPanel eastPanel;\n    private JTextField textArea;\n    private JButton[] numberBtn;\n    private JButton[] operatorBtn;\n    private JButton point;\n    private JButton delete;\n    private JButton neg;\n    //endregion\n\n    private Calculator calculator;\n\n    private void initComponent() &#123;\n        this.setLayout(new BorderLayout(10, 10));\n\n        centerPanel = new JPanel(new BorderLayout(10, 6));\n        numberPanel = new JPanel(new GridLayout(4, 4, 10, 10));\n        operatorPanel = new JPanel(new GridLayout(6, 1, 10, 6));\n\n        northPanel = new JPanel();\n        southPanel = new JPanel();\n        eastPanel = new JPanel();\n        westPanel = new JPanel();\n\n        textArea = new JTextField(&quot;0&quot;, 1);\n\n        numberBtn = new JButton[10];\n        operatorBtn = new JButton[5];\n        delete = new JButton(&quot;AC&quot;);\n        point = new JButton(&quot;.&quot;);\n        neg = new JButton(&quot;neg&quot;);\n\n        textArea.setEditable(false);\n        textArea.setFont(new Font(&quot;微软雅黑&quot;, Font.BOLD, 24));\n        textArea.setHorizontalAlignment(SwingConstants.TRAILING);\n\n        point.setFont(new Font(&quot;黑体&quot;, Font.BOLD, 18));\n        delete.setFont(new Font(&quot;黑体&quot;, Font.BOLD, 15));\n\n        delete.addActionListener(event -&gt; &#123;\n            textArea.setText(&quot;0&quot;);\n            calculator.reset();\n        &#125;);\n        point.addActionListener(new OperatorButtonListener(&quot;.&quot;));\n        neg.addActionListener(new OperatorButtonListener(&quot;neg&quot;));\n\n        for (int i = 0; i &lt; 10; i++) &#123;\n            numberBtn[i] = new JButton(String.valueOf(i));\n            numberBtn[i].addActionListener(new NumberButtonListener(i));\n            numberBtn[i].setFont(new Font(&quot;黑体&quot;, Font.BOLD, 18));\n            numberPanel.add(numberBtn[i]);\n        &#125;\n\n        numberPanel.add(point);\n        numberPanel.add(delete);\n\n        operatorPanel.add(neg);\n\n        String[] temp = &#123;&quot;+&quot;, &quot;-&quot;, &quot;*&quot;, &quot;/&quot;, &quot;=&quot;&#125;;\n        for (int i = 0; i &lt; operatorBtn.length; i++) &#123;\n            operatorBtn[i] = new JButton(temp[i]);\n            operatorBtn[i].setFont(new Font(&quot;黑体&quot;, Font.BOLD, 18));\n            operatorBtn[i].addActionListener(new OperatorButtonListener(temp[i]));\n            operatorPanel.add(operatorBtn[i]);\n        &#125;\n\n\n        centerPanel.add(BorderLayout.NORTH, textArea);\n        centerPanel.add(BorderLayout.CENTER, numberPanel);\n        centerPanel.add(BorderLayout.EAST, operatorPanel);\n\n        this.add(BorderLayout.NORTH, northPanel);\n        this.add(BorderLayout.CENTER, centerPanel);\n        this.add(BorderLayout.SOUTH, southPanel);\n        this.add(BorderLayout.EAST, eastPanel);\n        this.add(BorderLayout.WEST, westPanel);\n\n        this.pack();\n        this.setSize(300, 300);\n    &#125;\n\n    public CalculatorFrame() &#123;\n        initComponent();\n\n        this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n        this.setLocationRelativeTo(null);\n        this.setVisible(true);\n        this.setTitle(&quot;简易计算器&quot;);\n\n        calculator = new Calculator();\n    &#125;\n\n    private class NumberButtonListener implements ActionListener &#123;\n        private final int value;\n\n        public NumberButtonListener(int value) &#123;\n            this.value = value;\n        &#125;\n\n        @Override\n        public void actionPerformed(ActionEvent e) &#123;\n            if (calculator.isCalculated()) &#123;\n                calculator.reset();\n                textArea.setText(String.valueOf(value));\n            &#125; else &#123;\n                textArea.setText(textArea.getText() + value);\n            &#125;\n\n            calculator.inputNum(value);\n        &#125;\n    &#125;\n\n    private class OperatorButtonListener implements ActionListener &#123;\n        private final String value;\n\n        public OperatorButtonListener(String value) &#123;\n            this.value = value;\n        &#125;\n\n        @Override\n        public void actionPerformed(ActionEvent e) &#123;\n            try &#123;\n                if (value.equals(&quot;=&quot;)) &#123;\n                    textArea.setText(String.valueOf(calculator.getResult()));\n                &#125; else &#123;\n                    if (value.equals(&quot;neg&quot;) &amp;&amp; calculator.isCalculated()) &#123;\n                        textArea.setText(“neg”);\n                    &#125; else &#123;\n                        textArea.setText(textArea.getText() + value);\n                    &#125;\n                    calculator.inputOperator(value);\n                &#125;\n            &#125; catch (ArithmeticException arithmeticException) &#123;\n                calculator.reset();\n                textArea.setText(&quot;Error Input&quot;);\n            &#125;\n        &#125;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        new CalculatorFrame();\n    &#125;\n&#125;\n","tags":["java","swing"]},{"title":"关于Spring事务管理失效问题","url":"/2021/02/21/springTxError/","content":"spring事务管理与AOP中的神坑\n\n关于Spring事务管理失效问题\n○前言\n学习 Java Web学到了Spring的事务管理，在实际使用过程中发现，@Transcational与 @EnableTranscationManagement 组合使用时，出现了事务管理失效、无法回滚的问题，在网上搜索一番依然无法得到答案，后来在自己的冥思苦想下联想起Spring事务管理本质时AOP的结论时恍然大悟，于是通过逐个注释来测试其他切面的方法终于得到答案——环绕通知导致了无法进行事务回滚！\n○原因分析\n得知无法进行事务管理的原因是环绕通知时，我开始思考原因，通过查阅网上资料，得知Spring执行AOP切面遵循着一定的顺序，而这个顺序是由 Order 属性决定的！然后我就通过更改Order的方式对环绕通知的切面和事务管理切面进行测试，最终得出原因为事务切面的优先级高于环绕通知切面的优先级时，事务管理无法执行（回滚）\n○解决办法\n○快速解决办法\n解决办法由上文非常容易得知，需要通过以下方法修改Order的值，需要注意的是该值越大，优先级越低，而事务切面默认值为Integer.MAX_VALUE，默认是优先级最低的，但是同样的其他Aspect默认值也是Integral.MAX_VALAUE，具体原因本人愚昧未知。所以说以下配置可以忽略事务管理切面的优先级Order的配置，只更改其他Aspect的Order。\n○XML式配置\n在以下两个标签中添加配置order属性值\n&lt;aop:advisor order=&quot;&quot; /&gt;\n&lt;aop:around order=&quot;&quot; /&gt;\n○注解式配置\n普通切面类通过@Order 注释传入一个int值即可\n@Component\n@Aspect\n@Order(10086)\npublic class MyAspect &#123;&#125;\n事务管理切面需要在@EnableTranscationManagement中配置order参数\n@EnableTransactionManagement(order = 1008611)\n@Configuration\npublic class SpringConfiguration &#123;&#125;\n○优雅的解决办法\n如果按照以上方法配置Order难免会在项目越来越大的情况变得难以管理，因为是耦合在代码上的所以不利于管理，所以我们最优雅的解决办法是使用.properties配置文件。\n○XML配置\n这个就是引用properties罢了，没什么好讲的，学过Spring XML配置都应该知道如何引入properties文件然后通过$&#123;keyName&#125;访问。\n○注解配置\n因为注解配置使用的是Java代码，且本人暂未发现Spring框架本身对Order批量管理的支持，所以只好自己想一套简单但又良好的方法，从贴合框架啊本身的角度来讲，使用XML配置更符合🍃Spring框架的生态。\n\n\n创建properties文件，并在配置类中使用@PropertySource加载\n\n\n让你的Aspect类继承org.springframework.core.Ordered接口并按照如下来实现接口方法\n@Component\n@Aspect\npublic class MyAspect implements Ordered &#123;\n    @Value(&quot;$&#123;keyName&#125;&quot;)\n    private int order;\n\n    @Override\n    public int getOrder() &#123;\n        return this.order;\n    &#125;\n&#125;\n\n\n○关于解决方法\n注解配置的解决方法可能不够完美，但是也很好的进行解耦了，还有一些比较方便的方法但是实现难度较大，比如动态代理注解，用类名代替注解内的参数，来避免每次创建类都要用@Value注入order，然后就可以再配置文件中直接使用类名作为key配置Order了，目前动态代理注释的方法仍不清楚，所以暂时放弃这种方案。\n","categories":["问题"],"tags":["web","java"]},{"title":"LinkGame","url":"/2020/12/18/LinkGame/","content":"Java课设作品，完成度较高，这里贴出设计方案！\n\n《连连看》 Java课程设计方案\n\n项目已开源，请点击：GithubHomePage\n\n○Swing界面组成\n○需求分析\n○1.核心界面\n位于窗口中央，核心界面由n*n的方块组成，同种方块成对出现，并且是乱序的。每个方块一张图片，同类方块图片相同。方块间留足间隙满足观赏性。方块点击后应有方框标记。\n○2.信息栏\n位于窗口上方，提示栏包括游戏的标题和游戏的具体信息，包括游戏剩余时间(s)，时间进度条(%)和得分情况。\n得分：根据时间、重置次数、消去方块得出。其中消去方块分最多为(n^4/2)分，在此基础上除以消耗时间/(n/4)*重置次数*(提示次数*5)*0.1。\n○3.菜单栏\n位于窗口最上方横条，菜单栏应包含游戏暂停、游戏重开、游戏退出、方块再次打乱、提示方块和“关于”界面的选项，应使用菜单和子菜单组合。游戏退出后显示欢迎界面。\n○4.关于界面\n新的对话框，由菜单栏启动，内容应包含该项目的基本信息，包括作者、时间、项目名称、源码地址等。\n○5.欢迎界面\n可切换的界面，用于打开主界面。界面中应包括游戏标题、开始按钮、关于按钮和退出按钮。开始按钮点击后应显示难度选择按钮。\n○6.结算界面\n可切换的界面，显示得分和总消耗时间。包括退出、重开按钮。退出后显示欢迎界面。\n○界面结构图\n\n○类的封装\n○GameClient\nextends JFrame\n界面程序的本体，用于联络各个组件，控制游戏开始结束。\n功能：\n\n创建菜单栏、信息栏、游戏界面、关于界面、欢迎界面、结算界面。\n订阅组件的监听器，实现各种页面的切换。页面切换使用CardLayout实现。\n开始游戏和重开游戏，设定各个组件的初始参数。\n\n○EntryPanel\nextends JPanel\n退出或者开始。记录选择的难度（地图规模、方块类数）。\n功能：\n\n提供获取所选难度的方法\n切换界面&gt;(GamePanel+MessagePanel)\n\n○OverPanel\nextends JPanel\n结算界面，显示成功或者失败信息。\n功能：\n\n\n重开游戏&gt;GameClient(reopen)\n\n\n切换界面&gt;EntryPanel\n\n\n获取从MessagePanel中获取游戏信息\n\n\n○MessagePanel\nextends JPanel\n显示信息栏界面的内容。主要用于记录分数和时间。\n功能：\n\n各种参数的getter/setter方法。\n当时间耗尽时调用自定义监听器\n\n○GamePanel\nextends JPanel\n使用Block对象填充GridLayout。根据GameMap对象提供的数据绘制Block，方块相消判定成功后绘制连线，记录数量。\n功能：\n\n为每一个Block添加MouseClicked监听器：被点击时传递自身的引用给GamePanel。\n使用GameMap判断两个坐标是否能连通后，若成功则画线并检测是否消除完全，失败则改变所选取的Block状态，并删除其引用。\n画线：\n\n直接连通：直接使用两方块坐标画线\n单拐点：两方块坐标以及一个拐点，用三个点画线段。\n双拐点：两方块坐标以及两个拐点，用四个点画线段，应注意线段总是在X或Y轴方向上。\n\n\n刷新GameMap后，遍历Blocks，重置Blocks状态\n提示两个可以相消的方块。\n当消除一次方块后调用自定义监听器。\n\n○Block\nextends JComponent\n保存方块在Map上的下标。\n功能：\n\n重置方块，包括图片、ID、状态（利用BlockFactory）\n被选取时，绘制方框\nid的getter\n\n○BlockFactory\n单例工厂类，用enum类型。\n功能：\n\n通过方块的id，生成一个带图片的Block对象。\n通过方块id，重置一个现成的Block对象。\n\n○Sound\n音效对象，实现多线程播放音效。\n○AboutDialog\nextends JDialog\n显示关于该游戏以及该项目的信息。\n○ScaleIcon\nimplements Icon\n实现图片随容器大小变化而变化\n○UMP类图\n\n○游戏逻辑构建\n游戏逻辑主要在于方块数据处理和判断两个方块是否能消去。\n○需求分析\n假设地图规模大小为n*n，方块种类为i种\n○1.记录方块分布数据\n一个二维数组，不同的ID对应不同的方块，同一个ID应成对出现。空白方块使用特殊标记。\n○2.操作方块分布数据\n重新打乱二维数组中的数据，应注意只能打乱非空白方块的数据，空白的位置应保持不变。\n判断两个方块是否能够相消，以何种方式相消。\n遍历查找两个可连通的点。\n传出和修改对应点的方块ID。\n○3.生成方块分布数据\n根据地图大小，创建一个二维数组，并在里面随机添加方块的ID。每种类型的方块添加(n*n)/i个，共(n*n)/2i组。根据需求i == n\n○核心算法\n按照连连看规则——可连接的两个方块之间最多用三条直线相连——可以分类为三种判定方式。在判定过程中应注意边界问题。\n○1.直接连通\n即两个方块间可以用一条直线连接。处在同一行或者同一列且中间没有其他方块。\n○2.单拐点连通\n即两个方块间可以用两条线段连接。以两个方块为顶点得到一个矩形，矩形的另外两个顶点中，任意一个可以空白顶点，与这两个方块都可以直接连通，则可连接。\n○3.双拐点连通\n即两个方块间可以用三条线段连接。搜索其中一个方块周围四个方向空白的点，若任意一个可以直接连通点，能与另一个方块单拐点连通，则能够连通。\n○4.寻找连通点\n○方案一\n暴力求解，不推荐\n四重循环，遍历每一个方块，起点遍历一次，终点遍历一次，判断起点和终点的连通性。\n○方案二\n广搜\n对每个方块进行广搜判断，两种判断方法\n\n方向改变不大于三次内可以找到的终点即可以连通，连通类型根据方向改变次数可以得出，拐点和方向改变次数每一次搜索都需要记录。（稍微麻烦，但速度快一点）\n对找到的终点进行连通性判断，不需要额外记录。（简单，相对慢一点，推荐）\n\n○5.数据随机\n将所有决定好的方块ID放入一个容器中进行混排，每次随机从容器中抛出一个ID设置在Map上，容器内的ID不能重复抛出。\n○判断流程图\n\n○连通示意图\n\n○类的封装\n○LinkType\n枚举类型，表示四种方块的连通方式（包括一种无法连通）。\n\nSTRAIGHT_LINK\nSINGLECORNER_LINK\nDOUBLECORNER_LINK\nNO_LINK\n\n○GameMap\n保存方块数据的类。负责判断连通，提供数据和信号给界面程序。构造时应指定地图大小和方块ID最大值。\n接口：\n\n判断是否连通的方法，并记录所有拐点，返回LinkResult。\n地图数据的getter方法，返回方块ID。\n清空指定两个点的方法。\n判断并清空两个点的方法，返回布尔类型。\n重新随机地图的方法。\n自动寻找两个可相消的点。成功返回一个LinkResult，失败抛出RuntimException（或自定义一个Exception）。\n\n○LinkResult\n自定义封装类，用于返回五个参数（初始化为null），为每个参数设置一个getter/setter。\n\nfristPoint\nsecondPoint\nfirstCorner\nsecondCorner\nlinkType\n\n○UMP类图\n\n","tags":["java","swing"]},{"title":"MyBatis","url":"/2021/03/12/myBatis/","content":"mybatis是一个优秀的持久层框架，通过配置的方式即可对数据库进行持久化操作。主要讲述原始Mybatis的用法，偏入门向\n\n🐦MyBatis\nmybatis是一个优秀的持久层框架，通过配置的方式即可对数据库进行持久化操作。\n\n推荐IDEA插件FreeMyBatisPlugin。\n\n○配置详解\nMaven坐标\n&lt;dependency>\n  &lt;groupId>org.mybatis&lt;/groupId>\n  &lt;artifactId>mybatis&lt;/artifactId>\n  &lt;version>x.x.x&lt;/version>\n&lt;/dependency>\n○XML核心配置\n○运行环境配置\n运行环境需要指定数据库连接池和事务管理类型。完成以下配置即可完成最简单的持久化操作。\n\n\n数据源环境\n&lt;environments default=\"id\">\n    &lt;environment id=\"\">\n        &lt;transactionManager type=\"JDBC\"/>\n        &lt;dataSource type=\"POOLED\">\n            &lt;property name=\"\" value=\"$&#123;&#125;\"/>\n        &lt;/dataSource>\n    &lt;/environment>\n&lt;/environments>\n数据源环境可以配置多个，其中指定一个ID为默认运行环境，配置DataSource的方法与Spring配置相似，同样可以使用properties文件。\n\n\n加载映射文件\n&lt;mappers>\n\t&lt;mapper resource=\"xml-url\"/>\n&lt;/mappers>\n\n\n○详细配置\n\n\nenvironment\ntransactionManager：事务管理器类型，分为 JDBC、MANAGED\ndataSource：连接池类型，分为UNPOOLED、POOLED、JNDI，也可以指定一个实现UnpooledDataSourceFactory的类作为type，如果要使用第三方连接池就需要这么做\nJDBC和POOLED是最常用的，其他功能不做解释。\n\n\nmapper\n加载映射器可以使用多种方式，如以下三种：\nresource：相对类路径，相当于classpath:，用于加载映射器配置文件\nclass：加载类，通过全限定类名加载，用于加载实现映射器接口的类（注解配置）\npackagename：加载包名下所有的类，同样是用于注解配置\n\n\nproperties\n加载配置文件，使用resource=&quot;path&quot;加载类下路径的文件，不需要加classpath\n\n\ntypeAliases\n定义类型别名，用于简化全限定类名，创建别名和真名的映射关系。Mybatis内部将Java基础类型与包装器类型映射起来了，所以使用int、double等名称时，对应的是包装器类名。\n\n\ntypeHanlder\n配置自定义类型转处理器，需要包裹在typeHanlders中，通过属性handler=&quot;类全限定名&quot;配置一个处理器。\n\n\n○XML映射关系配置\n○命名空间\n每个映射文件对应一个命名空间，需要在标签内指定。命名空间的作用同Java包，使用映射关系时，需要以命名空间为开头的路径。\n&lt;mapper namespace=\"spaceName\">&lt;/mapper>\n○sql语句配置\nid是语句的标识符，sql语句可以直接写在标签中。\n\n\nSELECT\n&lt;!--resultType是返回结果的类型，指定一个类Mybatis能够自动封装-->\n&lt;select id=\"\" resultType=\"\">sql&lt;/select>\n\n\nUPDATE\n&lt;update id=&quot;&quot; parameterType=&quot;&quot;&gt;sql&lt;/update&gt;\n\n\nDELETE\n&lt;delete id=&quot;&quot; &gt;sql&lt;/delete&gt;\n\n\nINSERT\n&lt;!--后面三个属性表示返回插入的主键id并使用指定的映射关系！-->\n&lt;insert id=\"\" useGeneratedKeys=true keyProperty=\"\" keyColumn=\"\">sql&lt;/insert>\n\n\n○使用占位符\nmybatis中占位符用OGNL#&#123;name&#125;表示，这个占位符是安全的，与Jdbc的?一样。在符号内部可以填写多个属性，如限定这个占位符的类型等，更多属性的设置请到官方文档中查询。\n#&#123;id, javaType=int, jdbcType=NUMERIC&#125;\n○OGNL表达式\nognl只能对应数据库存在的值类型，但是它能够解析数组和POJO\n\n\n数组\n#&#123;listName[index].propertyName&#125;\n\n\nPOJO(JavaBean)\n#&#123;propertyName&#125;\n直接使用POJO内的属性名，如果是数组则需参照1\n\n\n\n⚠️当使用注解编写Mapper时，要注意多个参数时，应使用@Param注解指定参数对应OGNL表达式中的属性名，且对于数组类型的参数将默认使用**“list”**\nℹ️EL表达式$&#123;&#125;会将参数直接作为字符串插入，属于不安全操作\n\n用实体对象作为占位符参数\nMybatis具备将复杂对象的属性配置到占位符中的功能，其中对象的属性名需要和占位符内name的参数名保持一致，mybatis即可自动的配置到占位符中。\nsql标签使用parameterType属性可以指定该条语句所需要的参数对象类型，在缺省的情况下Mybatis能够自动推断。\n○ResultMap\n测试用例子\n结果映射，通过resultType指定的类型，能够被mybatis自动创建并设置其中的属性值，当列名和属性名匹配上时，不需要额外配置，而复杂情况下可以通过显式配置resultMap的方式完成映射，大多数情况下ResultMap在配置一对一、一对多、多对多关联查询时使用。\n\n配置一个所需的resultMap\n\n   &lt;resultMap  id=\"\" type=\"class\">\n    &lt;!--把class的属性名同列名关联起来-->\n    &lt;id property=\"\" column=\"\"/>\n\t&lt;result property=\"name\" column=\"name\"/>\n    &lt;!--一对一关系映射-->\n    &lt;assosiation property=\"\" javaType=\"class\">&lt;/assosiation>\n    &lt;!--一对多/多对多关系映射-->\n    &lt;collection property=\"\" ofType=\"class\">&lt;/collection>\n&lt;/resultMap>\n主键一般使用&lt;id&gt;标签来配置。\n\n将sql语句的resultType更换为resultMap\n\n   &lt;select resultMap=\"mapId\">sql&lt;/select>\n更加复杂的高级结果映射请看官方文档包含多表关系查询需要的复杂嵌套映射\n○SelectKey\n该标签用在增删改语句中，能够完成一次子查询并封装到参数中。\n&lt;selectKey keyProperty=\"\" keyColumn=\"\" resultType=\"\" order=\"\">sql&lt;/selectKey>\n\nkeyProperty、keyColumn 配置映射关系，结果将保存到keyProperty对应参数中（可以是对象中的属性）\nresultType 返回结果对应的JavaType\norder 指定为BEFORE/AFTER，意为在主查询之前还是之后进行这个子查询\n\nSelectKey需要注意order属性，像Mysql一类支持自动增长类型的数据库中，order需要设置为after才会取到正确的值\n\n⚠️如果是需要获取自增长的主键ID，推荐使用insert标签中的useGeneratorKeys模式，如果是注解方法，请使用@Options配置相同的内容。mssql中，用SelectKey且使用SCOPE_IDENTITY()来获取主键的话是无法获取的（null）但使用@@IDENTITY能够正确获取\n\n○缓存优化\n当一条语句被调用时，mybatis能够将其返回结果缓存起来，若有多次查询则可以使用缓存直接返回。\nSelect语句默认是打开缓存的，缓存开启方式如下：\n在sql语句标签中添加属性useCache=&quot;true&quot;即可开启，当使用属性flushCache=&quot;true&quot;时，调用sql会刷新缓存区，默认为false\n○注解配置\n\n\n\n常用注解\n说明\n\n\n\n\n@Insert, @Update, @Delete,   @Select\n增删改查语句，填写sql语句，参数通用#&#123;&#125;\n\n\n@Result\n映射封装结果，相当于xml中的id/result，使用column和property配置映射关系，使用@One/@Many作为参数配置复杂映射，参数id=true表明为主键\n\n\n@Results\n封装多个结果，相当于xml中的resultMap，可指定属性id，组合多个@Result标签\n\n\n@One\n实现一对一查询封装，调用其他接口，完成子查询操作，返回单一的对象\n\n\n@Many\n实现一对多、多对多查询封装，调用其他接口，完成子查询操作，返回集合对象\n\n\n@ResultMap\n给@Select提供&lt;resultMap&gt;/@Results的id，复用resultMap，参数为一个int数组\n\n\n@Options\n配置对应方法的sql属性，如useGeneratorKey、useCahce等，无法指定空值，所以一旦使用就受所有默认值的支配。\n\n\n@SelectKey\n提供在insert、update、delete时进行二次查询，并返回某些属性。参数keyProperty、keyColumn指定映射关系，statement指定sql语句，before代替order属性，使用bool决定，还有其他参数同上文\n\n\n\n\n\n一对一查询\n原理是进行两次查询，第二次查询的条件取决于第一次查询得到的外键\n@Results(&#123;\n    @Result(id=true,column=\"\",property=\"\"),\n    // 进行一次子查询封装\n   \t@Resutl(\n        property=\"\",javaType=class,\n        column=\"下一次查询使用哪一列的值\"\n    \tone=@One(select=\"接口方法全限定名\")\n    )\n&#125;)\n@Select(\"sql\")\n\n\n一对多、多对多查询\n@Result(\n    @Result(\n\t\t/*省略相同部分*/\n        many=@Many(select=\"\")\n    )\n)\n@Select(\"sql\")\n\n\n○动态SQL\n在配置映射关系时，Mybatis提供了一系列标签，使得sql语句能够动态的生成。根据参数不同，在同一个标签下能够生成不同语句。\n○动态标签\n动态标签是用于select等标签内部，用来动态生成sql语句的标签。\n\n\n&lt;where&gt;\n用于包裹其他动态标签，防止不使用条件判断时造成sql语法问题，当where标签内没有生成任何sql语句时，不会在原有sql上加入where字段，反之则加上where字段。（实际上是添加一个’ where 1=1 '）\n\n\n&lt;if&gt;\n&lt;if test=\"bool表达式\">\n    sql\n&lt;/if>\n\n\n&lt;foreach&gt;\n&lt;foreach collection=\"集合类型\" open=\"开始字段\" close=\"结束字段\" item=\"name\" separator=\"分隔符\">\n\tsql，使用#&#123;name&#125;引用item\n&lt;/foreach>\n\n\n&lt;trim&gt; 与where用法相似\n&lt;trim perfix=\"\" suffix=\"\" prefixOverrides=\"\" suffixOverrides=\"\">\n\tsql\n&lt;/trim>\n\n\n\n属性\n描述\n\n\n\n\nperfix\n给sql语句拼接的前缀\n\n\nsuffix\n给sql语句拼接的后缀\n\n\nprefixOverrides\n去除sql语句前面的关键字或者字符，该关键字或者字符由prefixOverrides属性指定，假设该属性指定为&quot;AND&quot;，当sql语句的开头为&quot;AND&quot;，trim标签将会去除该&quot;AND&quot;\n\n\nsuffixOverrides\n去除sql语句后面的关键字或者字符，该关键字或者字符由suffixOverrides属性指定\n\n\n\n更多标签详见官方文档\n\n\n○片段抽取\n&lt;sql&gt;片段标签，使用这个标签可以抽取重复片段，并使用标签id作为变量代替。\n创建sql片段\n&lt;sql id=\"\">sql&lt;/sql>\n引用sql片段\n&lt;include refid=\"sqlId\"/>\n○注解使用动态SQL\nMybatis对注解方式的SQL也有动态功能的支持，一共有两种方法。\n\n\n方法一\n在sql字符串内使用&lt;script&gt;把sql语句包裹起来，在&lt;script&gt;内部就能够使用上面讲到的标签了，用法相同，但需要注意内部的引号”“需要使用转义字符！\n\n\n方法二\n使用@XXXProvider标签，XXX包括Select、Insert等，如：\n@SelectProvider(type=A.class, method=\"mySelect\")\ntype指定一个类，method指定一个方法的名称，该方法的参数应与接口方法参数相同方便判空，并返回一个String对象作为为Sql字符串。所以我们需要在方法中实现Sql的动态生成！\n在这个方法中，Sql如何动态生成完全取决于我们自己，我们可以使用自己定义的逻辑来完成这个工作。但是Mybatis也为我们提供了一种选择——使用SQL对象构建sql语句。\n\n\n○SQL对象\nSQL对象是一个构建Sql的工具类，可以很方便的构造一个Sql语句，使用其提供的SELECT()、WHERER()、JOIN()等方法来拼接字符串，且无需担心语法问题。\n简单用例（来自官方文档）\n// 匿名内部类风格\npublic String deletePersonSql() &#123;\n  return new SQL() &#123;&#123;\n    DELETE_FROM(\"PERSON\");\n    WHERE(\"ID = #&#123;id&#125;\");\n  &#125;&#125;.toString();\n&#125;\n\n// Builder / Fluent 风格\npublic String insertPersonSql() &#123;\n  String sql = new SQL()\n    .INSERT_INTO(\"PERSON\")\n    .VALUES(\"ID, FIRST_NAME\", \"#&#123;id&#125;, #&#123;firstName&#125;\")\n    .VALUES(\"LAST_NAME\", \"#&#123;lastName&#125;\")\n    .toString();\n  return sql;\n&#125;\n\n// 动态条件（注意参数需要使用 final 修饰，以便匿名内部类对它们进行访问）\npublic String selectPersonLike(final String id, final String firstName, final String lastName) &#123;\n  return new SQL() &#123;&#123;\n    SELECT(\"P.ID, P.USERNAME, P.PASSWORD, P.FIRST_NAME, P.LAST_NAME\");\n    FROM(\"PERSON P\");\n    if (id != null) &#123;\n      WHERE(\"P.ID like #&#123;id&#125;\");\n    &#125;\n    if (firstName != null) &#123;\n      WHERE(\"P.FIRST_NAME like #&#123;firstName&#125;\");\n    &#125;\n    if (lastName != null) &#123;\n      WHERE(\"P.LAST_NAME like #&#123;lastName&#125;\");\n    &#125;\n    ORDER_BY(\"P.LAST_NAME\");\n  &#125;&#125;.toString();\n&#125;\n\n使用Provider时，Mapper接口上的@Param将无法对应到在SQL构造器方法中的参数，一定要在构造器方法的参数上使用@Param\n\n○Plugins\n使用第三方插件或自己开发的插件对Mybatis的功能进行拓展\n○配置Plugin\n&lt;plugins>\n\t&lt;plugin interceptor=\"类全限定名\">\n        &lt;property name=\"\" value=\"\"/>\n    &lt;/plugin>\n&lt;/plugins>\n○常用插件\n\n\npageHelper\n非常好用的分页插件，简单的参数设定，简单的数据获取。\n&lt;dependency>\n  &lt;groupId>com.github.pagehelper&lt;/groupId>\n  &lt;artifactId>pagehelper&lt;/artifactId>\n&lt;/dependency>\n\n\n○自定义插件\n实现Interceptor接口，主要实现三个方法\n\n\n核心方法，通过invocation参数能够获得映射好的sql语句，该方法的返回值是invocation对象proceed方法的返回值，与Proxy代理模式一样。\npublic Object intercept(Invocation invocation) throws Throwable &#123;&#125;\n\n\n主要用来将对象封装成代理对象，确保interceptI()能够被调用\npublic Object plugin(Object target) &#123;\n\t// 一般都是通过该方法封装\n    return Plugin.wrap(target, this);\n&#125;\n\n\n提供插件自定义属性，这个方法的属性能够在配置阶段进行注入\npublic void setProperties(Properties properties) &#123;&#125;\n\n\n○配置拦截注解\n在自定义插件类完成后，需要使用注解@Intercepts来表明该插件需要拦截的方法签名。\nMybatis只允许拦截以下类中的方法：\n\nExecutor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)\nParameterHandler (getParameterObject, setParameters)\nResultSetHandler (handleResultSets, handleOutputParameters)\nStatementHandler (prepare, parameterize, batch, update, query)\n\n@Intercepts(&#123;@Signature(\n  type= Executor.class,\n  method = \"update\",\n  args = &#123;MappedStatement.class,Object.class&#125;)&#125;)\n\n@Singnature：表示一个构造一个方法签名\n\ntype：被拦截类名\nmethod：被拦截类中的方法名\nargs：被拦截方法的参数\n\n\n\n○JAVA-API\n使用mybatis提供的java开发包，用java对数据库进行持久化操作。\n○快速入门\n快速入门演示了mybatis-api的一个基本使用流程\n//1. 加载核心配置\nInputStream configStream = Resources.getResourcesAsStream(\"sqlMapConfig.xml\");\n//2. 获得SqlSession工厂对象\nSqlSessionFactory factory = new SqlSessionFactoryBuilder().build(configStream);\n//3. SqlSession对象\nSqlSession session = factory.openSession();\n//4. 执行sql语句\nList&lt;Object> list = session.selectList(\"mapping-parttern\");\n// 提交事务\nsession.commit();\n//5. 释放SqlSession\nsession.close();\n○常用对象详解\n\n\nSqlSession\nmybatis主要的java接口，一切数据库操作都是由这个对象完成的。其地位类似于JdbcTemplate，在使用spring时也能通过IOC进行注入。\n主要方法有selectXxx()、update()、delete()以及事务管理的commit、rollback等\n\n\nSqlSessionFactoryBuilder\n用于创建SqlSessionFactory的对象，其中构建方法为build()，支持使用InputStream加载配置文件来创建工厂对象。\n\n\nSqlSessionFactory\n创建SqlSession对象的工厂类，用openSession()方法创建，可以使用其重载来设置SqlSession的一些属性，如是否自动提交事务以及事物的隔离级别等。\n引用官方文档的一段话\n\nSqlSessionFactory 有六个方法创建 SqlSession 实例。通常来说，当你选择其中一个方法时，你需要考虑以下几点：\n\n事务处理：你希望在 session 作用域中使用事务作用域，还是使用自动提交（auto-commit）？（对很多数据库和/或 JDBC 驱动来说，等同于关闭事务支持）\n数据库连接：你希望 MyBatis 帮你从已配置的数据源获取连接，还是使用自己提供的连接？\n语句执行：你希望 MyBatis 复用 PreparedStatement 和/或批量更新语句（包括插入语句和删除语句）吗？\n\n\n\n\n○DAO层接口代理\nMybatis能够将编写的Mapper.xml通过Java的接口进行动态代理，使得开发人员调用dao接口就能完成mapper中定义的数据库操作。使用接口代理的有以下的条件约束：\n\nmapper中namesapce属性的值需要为所需接口的全限定名。\nmapper中每个定义的sql语句id属性需要与接口中的方法名一一对应。\nsql语句的参数类型、结果类型即为接口方法的参数和返回值。\n接口的设计不能使用重载。\n\nℹ️使用IDEA插件能够根据数据库关系自动生成实体和接口\n○API\n通过SqlSession的getMapper(dao.class)获得接口的代理对象，直接使用接口即可。\n○typeHandler\n类型处理器，在Mybatis生成PreparedStatement或获取结果时会调用类型处理器来转化sql所需的参数。Mybatis默认使用了许多转换器，在使用时能够自动推断类型使用响应转换器，也能事先通过parameterType、resultType指明参数类型。\n○自定义typeHandler\n类型转换器需要实现TypeHandler接口或继承BaseTypeHandler&lt;T&gt;类，泛型为需要自定义转化的Java类。\n\n\nparameter转化逻辑\n当mybatis设置数据到数据库时调用，使用这个方法来自定义参数转化逻辑\n@Override\npublic void setNonNullParameter(PreparedStatement preparedStatement, int i, T obj, \n                                JdbcType jdbcType) &#123;\n    //直接使用preparedStatement的set方法设置参数'obj'，参数的index为'i'\n&#125;\n\n\nresult转化逻辑\n从数据库取出数据时调用的转化方法\n//从三类不同的结果集取出给定的数据并转化成Java数据，第二个参数即为结果集中所需参数的位置\n@Override\npublic T getNullableResult(ResultSet resultSet, String s) &#123;&#125;\n\n@Override\npublic T getNullableResult(ResultSet resultSet, int i) &#123;&#125;\n\n@Override\npublic T getNullableResult(CallableStatement callableStatement, int i) &#123;&#125;\n\n","categories":["后端"],"tags":["web","java"]},{"title":"Java Web","url":"/2021/03/12/javaweb/","content":"从零开始学JAVA web，我学了些什么，这篇文章将会记录这一段学习历程。(暂告一段落)\n\nJavaWeb-Spring\n\nGitHub：Spring学习过程中创建的项目，包含一些例子\n\n○一​、🚶JavaSE\n\n[x] Java语言基础内容，已经掌握\n\n○二、🐴JSP/Servlet\n主要以理解Tomcat中Servlet的运行原理为重点\n○JSP\nJsp本质是servlet，约等于分不清前后端，耦合性太强，已经被时代抛弃，大概了解即可，直接跳过学习。\n○JSTL\nJavaServer Pages Tag Library ：JSP标准标签库\n用于简化和替换jsp页面上的java 代码\n○Servlet\n\n\nServlet:\n注解声明@WebServlet(&quot;path&quot;)\ntomcat服务器的核心，主要是理解Http协议、HttpServletRequest以及HttpServletResponse原理。req可以进行转发forward（服务器内servlet间转发），resp可以进行重定向redirect(由浏览器发送第二次请求，可跨服务器)\n\n\nFilter：\n注解声明@WebFilter(&quot;path&quot;)\n过滤器，拦截request和response，可以对req和resp进行判断是否放行。\n\n\nListener：\n注解声明@WebListener\n监听器，ServletContextListener监听ServletContext对象的创建（服务器启动）和销毁（服务器关闭），该接口主要用于加载资源和释放资源等操作。除此之外还有其他监听器。\n\n\nServletContext：\n服务器内的一个全局上下文，可以从servlet或req中获取（单例类）。作用是获取服务器真实路径getRealPath()、设置和获取服务器内共享的数据域set/getAttribute()和获取Content-typegetMimeType(filename)，通过配置&lt;context-param&gt;可以用getInitParam()来加载资源文件\n\n\nCookie：保存于浏览器的数据，用来识别身份，保存sessionid等。可以设置存活周期。\n\n\nSession：保存于服务器的数据，用来记录每个浏览器特定的信息，由一个id对应。可以设置存活周期，服务器关闭后会钝化，再次开启后活化\n\n\n○EL表达式\n语法：$&#123;expression&#125;\n\n\n运算\n算数运算、比较运算、逻辑运算、判空运算empty\n\n\n获取值\n从域对象中获取值$&#123;域名称.keyName&#125;、$&#123;keyName&#125;\n\n\n\n域名称\n说明\n\n\n\n\npageScope\n从pageContext获取\n\n\nrequestScope\n从request中获取\n\n\nsessionScope\n从session中获取\n\n\napplicationScope\n从ServletContext获取\n\n\n\n\n\n○ExtraDetail\n这里记录在学习这个模块的过程中额外学习到的内容。\n○ProxyMode\n代理模式，软件设计模式的一种，通过中间代理执行方法，来达到增强的目的。后续框架中经常使用该模式。\n动态代理在Java中使用\nclass Proxy&#123;\n    public static Object newProxyInstance(ClassLoader loader, Class&lt;?>[] interfacies, InvocationHandler h)&#123;&#125;\n&#125;\n其中InvocationHandler是抽象类，需实现\n@Override\npublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;&#125;\n通过在该方法中调用method.invoke(obj,args)来执行被代理的对象的方法。可以修改返回值或者参数等手段来增强该方法，也可以在方法调用前和调用后增加其他类的方法。\n实例化的对象即代理对象，通过强制转化为传入的某个接口可以直接调用接口方法，且是通过InvocationHandler执行。\n○MVC开发模式\n\n\nM: Model 模型 JavaBean\n完成业务逻辑操作，如查询数据库、封装数据\n\n\nV: View 视图 jsp\n展示数据\n\n\nC: Controller 控制器 servlet\n分发工作，获取客户端的输入然后调用模型，将数据交给视图。\n\n\n○三层架构\n\n\n界面层（表示层 web）SpringMVC\n用户能够通过界面的组件和服务器进行交互，调用Service完成请求处理，转发jsp页面完成显示。\n\n控制器：servlet，接受用户请求并封装参数信息到Servic层\n视图：JSP，接受控制器提供的数据并展示出来给用户\n\n\n\n业务逻辑层 (service) Spring\n处理业务逻辑，组合DAO层的简单方法，组成各种复杂的业务功能。\n\n\n数据访问层 (dao) MyBatis\n操作数据存储文件，定义了对数据库最基本的CRUD操作\n\n\n○Bootstrap/JQuery/AJAX\n皆为前端框架\n\n\nBoostrap\n提供丰富的html标签和css样式，具有响应式布局，配合JQuery/Vue使用。\n\n\nJQuery\n对js的封装，提供了选择器等许多丰富API来帮助编写js动态生成页面。\n\n\nAJAX\n异步的JavaScript和XML，用于向服务器发送异步请求，可以在JQuery/Vue中便捷使用。\n\n\n○三​、🚲JDBC/SQL\n两者是数据库的重要内容，SQL有MySQL、SQLserver等，JDBC则是Java操作数据库SQL的重要API，都应熟练掌握并理解原理。\n○MySQL\n学会数据库增删查改等操作，熟练运用操控数据库的高级技巧，重点理解数据库原理，学会优化数据库。\n○事务\n○基本介绍\n事务指的是一个包含多个步骤的业务操作，如果这个操作被事务管理，则要么同时成功，要么同时失败。事务可以提供回滚操作，撤销出错的影响。\n\nＳＴＡＲＴ　ＴＲＡＮＳＡＣＴＩＯＮ　开启事务管理\nＲＯＬＬＢＡＣＫ　回滚\nＣＯＭＭＩＴ　提交事务\n\nSELECT @@autocommit 查看是否为自动提交，修改后可以改变默认管理方式\n○四大特征\n\n原子性：数据库操作中不可分割的最小单位，要么同时成功，要么同时失败\n持久性：事务提交或回滚后，数据会持久化保存在数据库中\n隔离性：多个事务之间相互独立\n一致性：事务操作前后，数据总量不变\n\n○隔离级别\n多个事务操作同一批数据会引发一些问题，通过设置隔离级别可以解决这些问题。\n\n脏读：一个事务，读取到另一个事务中没有提交的数据。\n不可重复读：同一个事务中，两次读取到的数据不一样（可能被另一个事务修改了）MySql-MVCC原理\n幻读：一个事务(同一个read view)在前后两次查询同一范围的时候，后一次查询看到了前一次查询没有看到的行。\n\n\n\n\n级别\n说明\n安全性\n\n\n\n\nread uncommitted\n读未提交，允许读取未提交的数据\n0\n\n\nread committed\n当前读、读已提交，只有已经提交的数据才能被读取\n1\n\n\nrepeatable read\n可重复读，使一个事务周期内的数据不受其他事务影响\n2\n\n\nserializable\n串行化，锁定一张表，相当于单线程执行事务\n3\n\n\n\n从小到大安全性越来越高，效率越来越低！不同的数据库隔离级别原理不同，如MySql的MMVC，因此能解决的问题也不同\n通过SELECT @@tx_isolation查询隔离级别，SET GLOBAL TRANSACTION ISOLATION LEVEL 级别名设置隔离级别\n○JDBC\nJDBC是Java用来操作数据库的接口，具体实现由不同数据库公司实现，他的实现类被称为**“驱动”（Driver）**。\n常见驱动类：\n\nMySql：“com.mysql.cj.jdbc.Driver”\nSqlServer：“com.microsoft.sqlserver.jdbc.SQLServerDriver”\n\n○使用方法\n\n\n注册驱动\n/*\n 通过该方法把类加载到内存\n 驱动类来自每个不同的数据库公司，以下是mysql的驱动类\n 该方法执行时，类的静态代码块会被执行，Driver会使用registerDriver方法注册DriverManager\n mysql5以上的版本可以省略这个注册过程\n*/\nClass.forName(\"com.mysql.cj.jdbc.Driver\");\n\n\n获取数据库连接对象\nimport java.sql.*;\n/*\n url: 数据库地址 jdbc:mysql://域名:端口/dbName\n user: 管理员用户名\n pwd: 管理员密码\n*/\nConnection conn = DriverManager.getConnection(url,user,pwd);\n\n\n定义sql语句String\n\n\n获取执行sql对象\nimport java.sql.*;\n//satement 可以执行sql语句\nStatement stat = conn.createStatement();\n\n\n执行sql获取返回结果\n//sqlStr 为数据库执行语句，如DML(insert、update、delete)、DDL(create、alter、drop)\n//返回影响的行数：可以通过这个值判断DML语句是否执行成功\nstat.excuteUpdate(sqlStr);\n\n\n释放资源\n//执行对象释放\nstat.close();\n//数据库连接释放\nconn.close();\n//结果对象释放\nresultSet.close();\n\n\n○常用对象详解\nConnection：\n\n\n获取sql对象\ncreateStatement()、preparedStatement(sqlStr)\n\n\n管理事务\n关闭自动提交事务的功能即可开启手动事务管理\n开启：setAutoCommit(false)、提交：commit()、回滚：rollback()\n\n\nStatement：\n\nexcuteUpdate(sql)：执行DML(insert、update、delete)、DDL(create、alter、drop)，返回影响的行数\nexecuteQuery(sql)：执行DQL(select)语句，返回ResultSet\n\nResultSet：\n\n\nnext()：移动游标到下一行，游标初始于第0行（表头），如果下一行没有数据则返回false\n\n\ngetXxx(int/str)\n获取当前行的数据，Xxx为数据类型名，返回类型为Xxx\n方法指定参数为int时，表示columIndex获取第几列的数据\n方法指定参数为str时，表示columName获取名为str的列的数据\n\n\nPreparedStatement：\n\n\n解决SQL注入问题\n某些sql特殊关键字参与字符串拼接会造成安全性问题，如WHERE后存在恒等式则表示没有约束作用\n\n\n预编译sql\nsql语句的参数使用？占位符，使用setXxx(pos, value)方法赋值，该方法传入占位符的位置（第几个）和值来进行sql参数补充，value类型为Xxx\n\n\nexcuteUpdate()\n\n\nexecuteQuery()\n\n\n○事务管理\n事务指的是一个包含多个步骤的业务操作，如果这个操作被事务管理，则要么同时成功，要么同时失败。\n\n开启 提交 回滚 使用Connection管理\n\n○使用方法\ntry &#123;\n    conn.setAutoCommit(false); //open\n    // TODO: do sql\n    conn.commit(); //commit if no exception occur\n&#125; catch (Exception e)&#123;\n    conn.rollback(); //rollback if has any exception \n&#125;\n当rollback()执行时，刚刚执行的sql操作都会撤销。\n○数据库连接池\n优化Connection操作，提高数据库访问性能\n○原理\n使用连接对象容器管理Connection，从容器中获取，归还到容器中去，由容器管理是否断开连接。\n○实现方法\n*Interface DataSource：*由Driver实现，Druid性能较高\n\n\nC3P0：ComboPooledDataSource\n使用classpath:c3p0.properties/c3p0-config.xml配置参数\n\n\nDruid：DruidDataSourceFactory\n使用druid.properties配置参数，需要手动加载。通常封装成工具类静态加载配置文件。\n\n\n○Spring JdbcTemplete\n由Spring封装的JDBCUtils，简化操作。详细见下文\n○Junit4\nJunit单元测试属于白盒测试的一种。\n○注解\n\n\n\n注解\n说明\n\n\n\n\n@Before\n在所有测试方法前执行\n\n\n@After\n在所有测试方法后执行，无论是否存在异常\n\n\n@Test\n标注方法为测试方法\n\n\n\n○测试方法\n所有测试方法都是无参的，测试方法内最好不要直接输出数值，应该尽量使用assert断言结果于预期是否相符合。对于测试期间出现的异常应该尽量捕获并写入文件中，标明异常方法和异常原因。\n○Redis/Jedis\n非关系型数据库，有缓存功能。。。\n○四、🚗SSM\nJavaWeb框架集合之一，由Spring+SpringMVC+Mybatis组成，适用于轻量级微服务开发，要深入理解原理。\n○Spring\nSpring框架属于Service层框架，但是也管理了Web层和DAO层\n○IOC\n○ioc容器\nBean容器，spring在内部创建Java类，我们或Spring可以从容器中取出Bean\n○XML式依赖注入\n对&lt;bean id=&quot;&quot; class=&quot;&quot;&gt;&lt;/bean&gt;对象的属性进行配置\n分别为：对象注入ref、普通数据类型注入value、集合类型\n\n\n集合类型：配置文件使用&lt;list&gt;&lt;value&gt;、&lt;map&gt;&lt;entry key=&quot;&quot; value-ref=&quot;&quot;&gt;、&lt;props&gt;&lt;prop key=&quot;&quot;&gt;组合使用\n\n\n构造方法：有参构造，配置文件中使用&lt;constructor-arg name=&quot;&quot; ref=&quot;&quot;/&gt;注入\n\n\nset方法：配置文件中使用&lt;property name=&quot;&quot; ref=&quot;&quot;/&gt;子标签标签设置属性值注入\n\n\n模块开发\n&lt;import resource=\"applicationContext-xxx.xml\" />\n○注解式依赖注入\n\n\n原始注解\n使用前须在配置文件中配置组件扫描，指定需要注解开发的包\n&lt;context:component-scan base-package=\"\">\n    &lt;!--用于排除不需要被扫描的类-->\n\t&lt;context:exclude-filter type=\"\" expression=\"\" />\n&lt;/context:component-scan>\n\n\n\n注解\n说明\n\n\n\n\n@Component\n类上实例化Bean，代替Bean标签\n\n\n@Controller\nweb层类上实例化Bean\n\n\n@Respository\ndao层上实例化Bean\n\n\n@Service\nservice层上实例化Bean\n\n\n@Autowired\n依赖注入标签，加在成员变量/setter/构造方法\n\n\n@Qualifier\n结合Autowired一起使用根据名称进行依赖注入\n\n\n@Resource\n相当于前两者的结合，是javaEE的注解，不是Spring的注解\n\n\n@Value\n注入普通属性（int等）\n\n\n@PostConstruct\n声明Bean的初始化方法\n\n\n@PreDestroy\n声明Bean的销毁方法\n\n\n@Scope\n标志Bean的范围，singleton/prototype\n\n\n\n\n\n新注解\n可以完全替代xml配置文件\n\n\n\n注解\n说明\n\n\n\n\n@Configuration\n指定类为配置类，创建容器时从该类上加载注解\n\n\n@ComponentScan\n指定要扫描的包，同&lt;context:componnet-scan&gt;，使用excludeFilters排除不需要被扫描的类\n\n\n@Bean\n标注方法的返回值储存于容器中\n\n\n@PropertySource\n用于加载.properties文件的配置\n\n\n@Import\n用于导入其他配置类\n\n\n\n\n\n○AOP\n○概念\n面向切面编程，是动态代理的规范化编程，动态代理如何增强方法见上文。SpringAOP底层使用的动态代理为以下两种：\n\n\nJava原生接口代理\n通过接口反射出代理对象，使用的是 ProxyMode\n\n\ncglib子类代理\n外部的工具库，已经集成在springframework-core中，使用的是Enhancer类。通过指定父类反射出代理对象。\n\n\n根据目标对象[1]是否有接口来选择其中一个方法。\n○XML配置动态代理\nmaven导入依赖aspectjweaver、spring-aop\n\n\n配置目标对象和切面对象Bean\n切面类和目标类都需要配置为Bean才能被Spring从IOC容器中取出来\n\n\n配置织入（前置、后置……）\n使用命名空间xmlns:aop\n&lt;aop:config>\n \t&lt;!--声明切面类-->   \n\t&lt;aop:aspect ref=\"beanName\">\n    \t&lt;!--配置切面：切点+通知-->\n        &lt;!--类似的还有aop:after等等-->\n        &lt;aop:before method=\"adviceName\" pointcut=\"execution('方法声明')\" />\n    &lt;/aop:aspect>\n&lt;/aop:config>\n切面标签\n\n\n\n名称\n标签\n说明\n\n\n\n\n前置通知\naop:before\n略\n\n\n后置通知\naop:after-returning\n略\n\n\n环绕通知\naop:around\n前后都执行，比前置更前，比后置更后\n\n\n异常抛出通知\naop:throwing\n出现异常时执行\n\n\n最终通知\naop:after\n最后执行，无论是否抛出异常\n\n\n\nℹ️环绕通知方法需要携带参数ProceedingJoinPoint表示连接点[2]对象，要在方法中执行该对象的proceed()方法并return该方法的返回值。\n⚠️环绕通知方法的返回值都为Object，表示被增强的方法会返回一个对象或者NULL，因此需要注意被增强的方法不能返回boolean、int等基础类型，需要用对应的包装类替换！\n\n\n切点表达式\nexecution([修饰符] 返回值 包名.类名.方法(参数))\n\n\n修饰符可以省略（public、private……）\n\n\n可以用通配符（*）代表任意\n\n\n参数可以用..表示任意个数，任意类型的参数列表（可变参数）\n\n\nex:\nexecution(* cn.test.*.*(..)) //cn.test包下任意类的任意方法\n**表达式抽取：**替换point-cut为point-cut-ref，引用&lt;aop:pointcut id=&quot;&quot; expression=&quot;&quot;/&gt;标签设定好的表达式id\nargs()\n限制并自动抽取切点的方法参数，可以使用..表示缺省，一般配合通知方法获取方法参数，如：\n@Before(\"pointCut() &amp;&amp; args(.., name)\")\npublic void before(String name) &#123;&#125;\n//表示pointCut限制下 要求“存在”参数【String name】\n\n\n○注解配置动态代理\n在配置文件中添加&lt;aop:aspect-autoproxy /&gt;自动代理aop\n或者在配置类上用@EnableAspectJAutoProxy标注\n\n\n\n注解\n说明\n\n\n\n\n@Aspect\n标注为切面类\n\n\n@Before\n标志为前置通知，参数为execution表达式\n\n\n@AfterReturning\n标志为后置通知，参数为execution表达式\n\n\n@Around\n标志为环绕通知，参数为execution表达式\n\n\n@AfterThrowing\n标志为异常抛出通知，参数为execution表达式\n\n\n@After\n标志为最终通知，参数为execution表达式\n\n\n\n**切点[3]表达式抽取：**在切面类中定义空实现方法，在方法上用@PointCut（’表达式‘）标注，引用时按照className.methodName()来描述\npublic class Aspect &#123;\n    @PointCut(\"excution(*.cn.shijh.*.*(..))\")\n    public void myPointCut()&#123;&#125;\n\n    @Before(\"Aspect.myPointCut()\")\n    public void beforeEnhance(JoinPoint jp)    \n&#125;\n// 所有通知方法都能使用JoinPoint作为参数，Spring自动注入\n○Spring事务控制\n底层基于AOP实现事务管理，一般在Service层进行。\n切点：Service方法\n通知：事务管理\n\n⚠️ ⚠️ ⚠️ 关于这个问题的详细说明\nSpring事务管理与AOP之间存在神坑，被环绕通知的方法是无法进行事务控制的！！！！坑了我两三个小时！原因是事务管理本身就是环绕通知！！解决办法：设定Aspect和advisor的Order，且事务控制的Order要比环绕通知的大，否则无法完成事务回滚\n\n○编程式控制\n\nPlatfromTransactionManager\n\nspring事务管理器的接口，依据不同Dao层技术使用不同的实现类。\n\nDataSourceTransactionManager\n\n Jdbc or MyBatis 对应的实现类。\n\n\nTransacitonDefinition\n\n事务的定义对象，封装事务的隔离级别、传播行为、超时时间等属性。\n\n\n隔离级别\nISOLATION_DEFAULT：数据库默认级别\nISOLATION_READ_UNCOMMITTED\nISOLATION_READ_COMMITTED\nISOLATION_REPEATABLE_READ\nISOLATION_SERIALIZABLE\n\n\n传播行为\nREQUIRED：默认值，防止嵌套的两个事务发生，后一个事务会加入到前一个事务中。\nSUPPORTS：后一个事务将不会开启\nMANDATORY：强制加进入前一个事务中，没有前一个事务就报错\n\n\n\n\nTransactionStatus\n事务的运行状态对象。是否完成、是否回滚等状态。\n\n\n○XML声明式控制\n&lt;!--配置事务管理的增强方法-->\n&lt;tx:advice id=\"\" transaction-manager=\"\">\n\t&lt;tx:attributes>\n        &lt;!--name可以使用通配符‘*’和字符串组合使用\n\t\t\t如‘update*’表示以update开头的所有方法名-->\n    \t&lt;tx:method name=\"methodName\" isolation=\"\" propogation=\"\"/>\n    &lt;/tx:attributes>\n&lt;/tx:advice>\n&lt;!--transactionManager需要注入到IOC容器中-->\n&lt;!--配置增强方法的织入，使用aop-->\n&lt;aop:config>\n    &lt;!--事务管理增强专用标签-->\n\t&lt;aop:advisor advice-ref=\"tx:advice\" pointcut=\"execution\"/>\t\n&lt;/aop:config>\n\n\n\n标签\n说明\n\n\n\n\ntx:advice\n配置事务管理的通知，需指定transactionManager\n\n\ntx:attributes\n配置事务的属性，具体由多个tx:method配置\n\n\ntx:method\n指定一个方法名，配置一个业务方法的属性，包括隔离级别等\n\n\naop:advisor\n用于事务管理的aop增强方法，引用配置好的tx:advice作为通知\n\n\n\n配置事务属性时，只需指定方法名，不需要指定包名类名等，具体位置在织入时配置\n○注解声明式控制\n\n\n\n注解\n说明\n\n\n\n\n@EnableTransactionManagement\n在配置类中标注，表示开启spring事务管理\n\n\n@Transactional\n在方法或者类上标注，表示类下的方法都会被spring事务进行管理，可以加参数来配置事务的属性\n\n\n\n使用注解配置时，driver会由spring自动配置，只需要将transactionManager放到IOC容器中\n○Spring-Junit\n通过注解集成Junit\n\n\n\n注解\n说明\n\n\n\n\n@RunWith\n指定使用Spring内置的测试类\n\n\n@ContextConfiguration\n指定Spring配置文件、配置类\n\n\n@AutoWired\n从IOC容器中注入测试对象\n\n\n\n○Spring-JdbcTemplate\n对JDBC API的封装，使调用更加简单\nmaven需要导入依赖spring-jdbc和spring-tx\n常用方法\n\n\nsetDataSource()：设置连接池对象\n\n\nupdate()、query()：执行sql语句\n\n\nRowMapper&lt;T&gt;可以自动完成数据封装的接口，是query()的方法参数，对应实现类有 BeanPropertyRowMapper&lt;T&gt;，需要构造参数：\nnew BeanPropertyRowMapper&lt;JavaBean>(JavaBean.class)\nquery()将返回List&lt;T&gt;类型的集合\n\n\nqueryForObject()同query()一样，但是只返回一个对象\n\n\n查询简单对象只需要传入Class&lt;T&gt;\n\n\n可以使用IOC容器来创建jdbcTemplate、dataSource对象，完成参数的注入。\n○Spring-web\n用于集成web环境的maven依赖spring-web，提供获取应用上下文（ApplicationContext）的工具类和监听器。获取的原理是在服务器启动时创建上下文并放入ServletContext域中，即可在服务器共享。方便在 Servlet中获取应用上下文，且可以避免多次创建带来的性能开销。\n\n\nweb.xml中配置监听器ContextLoaderListener\n\n\n配置&lt;context-param&gt;指定applicationContext.xml/.class的路径\n&lt;context-param>\n\t&lt;param-name>contextConfigLocation&lt;/param-name>\n    &lt;param-value>xx.xx.xx.ClassName&lt;/param-value>\n&lt;/context-param>\n&lt;!--如果使用类配置则一定要指定下面的参数-->\n&lt;context-param>\n\t&lt;param-name>contextClass&lt;/param-name>\n    &lt;param-value>org.springframework.web.context.support.AnnotationConfigWebApplicationContext&lt;/param-value>\n&lt;/context-param>\n\n\n使用WebApplicationContextUtils获取上下文\n\n\n○SpringMVC\nSpring+SpringMvc Demo\n属于web层框架，提供轻量级的MVC开发 ，核心是用servlet实现的前端控制器。该控制器执行servlet的共有行为，并调用特有行为servlet，称为 Controller\n○组件解析\n○原理图解\n\n○组件详解\n\n\nHandlerMapping\n\n\nHandlerAdaptor\n执行对应的Controller，并把Controller的返回值包装成ModelAndView对象。\n\n\nModelAndView\n\nsetViewName()设置页面跳转的页面名称\naddObject()设置request域中的参数\nnew ModelAndView(JsonView, ModelMap)用一个Map和JsonView对象创建Json数据视图\n\n\n\nViewResolver\n参考地址\n视图解析器，SpringMvc内部有很多解析器，默认使用的 InternalResourceViewResolver。主要作用是把一个ModelAndView解析为一个真正的视图。\n其中一种视图解析使用了一种拼接url的方式，内部规定了前缀(prefix)、后缀(suffix)，与视图的名称，如&quot;index&quot;，拼接后就得到视图URL了。url方式可以在ViewName中加上前缀指定，有&quot;redirect:“和&quot;forward:”，表示重定向和转发。视图解析器会把这些包装成View对象返回前端控制器。\n\n\nView\n由解析器产生的对象，分为URL(jsp, jstl)、文档(excel, pdf)、报表、JSON。\n\n\n○XML配置\n\n\n在web.xml中配置前端控制器DispatcherServlet\n&lt;servlet>\n    &lt;servlet-name>DispatcherServlet&lt;/servlet-name>\n    &lt;servlet-class>org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class>\n    &lt;!--设定SpringMVC配置文件的地址 使用类配置时要指定contextClass类型，同spring-web-->\n    &lt;init-param>\n        &lt;param-name>contextConfigLocation&lt;/param-name>\n        &lt;param-value>配置文件地址&lt;/param-value>\n    &lt;/init-param>\n    &lt;load-on-startup>1&lt;/load-on-startup>\n&lt;/servlet>\n\n&lt;servlet-mapping>\n    &lt;servlet-name>DispatcherServlet&lt;/servlet-name>\n    &lt;url-pattern>/&lt;/url-pattern>\n&lt;/servlet-mapping>\n\n\n使用独立的spring-mvc.xml配置SpringMVC的各种属性\n\n\n配置组件，ViewResolver、HandleAdapter等\n用&lt;bean&gt;标签配置，同Spring一样\n\n\n\n\n&lt;mvc:annotation-driven&gt; 自动配置一些组件的属性\n\n\n○注解配置\nSpring新注解也通用于SpringMVC\n\n\n\n注解\n说明\n参数\n\n\n\n\n@EnableWebMvc\n启用mvc注解驱动\n无\n\n\n@RequestMapping\n请求映射地址，用于类或方法中\nvalue：路径；method：请求方式；params：限定请求参数\n\n\n@GetMapping\nRequest的细分\nvalue：路径\n\n\n@PostMapping\n同上\n同上\n\n\n@ResponseBody\n标注返回值到content中\n无\n\n\n@RequestParam\n取request的参数\nvalue：所需参数的名称; require：强制要求？;defaultValue：默认值\n\n\n@RequestBody\n标注方法参数上，注入JSON请求参数\n无\n\n\n@PathVariable\n标注方法参数上，用于restful风格的参数\nvalue；require；defaultValue; 同RequestParam\n\n\n@RequstHeader\n获取请求头数据\nvalue; require;\n\n\n\nWebMvcConfigurer\nMvc配置类需要实现的接口，用于配置更多SpringMvc的属性，如资源解析、拦截器等。\n○注解配置web.xml\n配置web.xml的类需要实现接口AbstractAnnotationConfigDispatcherServletInitializer，并实现其中方法，Spring会自动查找该实现类来代替web.xml\n/**\n * 指定 ContextLoaderListener 所需的配置类\n */\n@Override\nprotected Class&lt;?>[] getRootConfigClasses() &#123;&#125;\n\n/**\n * 指定mvc的核心配置类\n */\n@Override\nprotected Class&lt;?>[] getServletConfigClasses() &#123;&#125;\n\n/**\n * 等同于设置 DispatcherServlet 的 url-pattern\n */\n@Override\nprotected String[] getServletMappings() &#123;&#125;\n\n/**\n * 配置过滤器\n */\n@Override\nprotected Filter[] getServletFilters() &#123;\n    return new Filter[]&#123;\n        new CharacterEncodingFilter(\"UTF-8\"),\n    &#125;;\n&#125;\n○数据响应\n服务的的数据响应分为页面跳转和回写数据。\n○页面跳转\n\n\n直接返回字符串，如页面的名称&quot;index&quot;，默认为转发\n\n\n返回ModelAndView对象\n通过setViewName()指定页面名称，addObject()保存数据供JSP调用\nModelAndView对象可以放在形参中，Spring会自动注入一个空的对象。\n\n\n○回写数据\n\n\nModelAndView\nJson数据内容由LinkedHashMap转化而来，Json转化驱动可以是jackjson、fastjson，需要添加maven依赖。\nreturn new ModelAndView(new FastJsonJsonView(), map);\n\n\n字符串\n方法上标注@ResponseBody表示返回值直接写入response的content。Json也可以作为字符串直接返回，使用json驱动转化。\n\n\n对象或集合\n通过配置消息转换器，可以直接返回集合或者对象自动转化成Json字符串，同时要在方法上标注@ResponseBody。\n\n\nXML\n配置RequestMappingHandlerAdapterbean标签，把Json转化驱动注入messageConverters中。\n\n\n注解、类配置\n在Mvc配置类中继承WebMvcConfigurer接口，实现以下方法\n@Override\npublic void configureMessageConverters(List&lt;HttpMessageConverter&lt;?>> converters) &#123;\n    // 此处配置FastJson\n    FastJsonConfig config = new FastJsonConfig();\n    FastJsonHttpMessageConverter converter = new FastJsonHttpMessageConverter();\n    config.setSerializerFeatures(\n        SerializerFeature.DisableCircularReferenceDetect,\n        SerializerFeature.WriteMapNullValue,\n        SerializerFeature.WriteNullStringAsEmpty\n    );\n    converter.setFastJsonConfig(config);\n    converters.add(converter);\n&#125;\n\n\n*返回Map集合时，最好使用LinkedHashMap来保证Json内数据顺序不会乱掉\n\n\n○获得请求参数\n\n\nspring自动注入方法的参数中\n限制：基本类型、数组和 Javabea(POJO)。集合对象（List等）需要包装到Bean中才能自动注入。当方法参数名与请求参数名一致时不需要加@RequestParam\n\n\n@RequestBody直接接收request的参数数据\n注释在参数上，一般用于非表单的数据，如application/json、application/xml\n用Json格式的数组作为请求参数，可以通过该标签直接注入到集合类型的方法参数中。\n\n\n获得Restful风格的请求参数\n使用@PathVariable获取，具体使用如下\n@RequsetMapping(\"/api/&#123;id&#125;/&#123;name&#125;\")\npublic void testController(@PathVariable(\"id\") int id, @PathVariable(\"name\") Stirng name) &#123;&#125;\n\n\n获取请求头\n使用@RequstHeader(name)在方法参数中注入。\n@CookieValue直接获取Cookie数据。\n\n\n○文件上传\nPost Content类型为 Multipart/form-data时，需要借助第三方工具简化获取参数的过程。\n导入maven依赖 commons-io、commons-fileupload\nSpringMvc获取到上传的文件时，会打包成MulitpartFile对象，因此用于获取文件的Controller方法需要有此类型的参数。\nMultipartFile\n\ngetOriginFilename()获取文件名\ntransferTo(File)通过IO保存本地或其他服务器\n\n○自定义类型转换器\nSpringMvc从Request中获取参数时会使用Converter进行类型转化来匹配Controller方法中的参数类型。\n实现 Convert&lt;S,D&gt; 接口，并配置到SpringMvc中。接口泛型分别为转换前类型和转换后类型。\n&lt;bean id=\"\" class=\"org.springframework.context.support.ConversionServiceFactoryBean\">\n\t&lt;property name=\"converters\">\n    \t&lt;list>\n        \t&lt;bean id=\"\" class=\"\">&lt;/bean>\n        &lt;/list>\n    &lt;/property>\n&lt;/bean>\n&lt;mvc:annotation-driven conversion-service=\"\"/>\n○静态资源访问\n当 spring-mvc 的 dispatcher-servlet 路径配置为/，访问资源时也会去寻找Handler，无法访问到资源文件。解决方法有两种，第一种是配置资源文件的映射，第二种是交由tomcat来寻找资源文件。\n\n\nXML配置\n&lt;!--1.配置资源文件的映射-->\n&lt;mvc:resource mapping=\"url\" location=\"path\" />\n&lt;!--2.启用默认servlet-handler管理资源文件-->\n&lt;mvc:default-servlet-handler />\n\n\n注解、类配置\n在Mvc配置类中继承WebMvcConfigurer接口，实现以下方法\n@Override\npublic void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) &#123;\n    configurer.enable();\n&#125;\n\n\n○Session管理\nSpringMvc可以使用注解对Session进行一些简单的管理操作，如向session域中存入数据等。\n\n\n方法一：\n在Controller方法中使用HttpSession对象作为参数，Spring会自动注入。HttpSession能够同时完成添加、删除、查询Attribute的功能。\n\n\n方法二：\n在Controller类上使用@SessionAttributes并指定参数为该类需要使用的AttributeNames，然后方法上的参数就可以使用@ModelAttribute(name)注入Session域的数据。在方法参数中使用Model类型，Spring会把该类的所有Session注入到Model对象中，因此也能够获取Session中的值，同时能够向Session中添加值。需要注意的是，使用该方法清除Session时，需要使用SessionStatus（作为方法参数，spring自动注入）的SetComplete()来清除，并且只会清除@SessionAttributes中标记的键值对。\n\n\n✋Spring官方文档中提出，对于用户登录验证的session最好使用方法一，实际上我们会使用安全框架来完成这个功能，如 Shiro\n○拦截器 Interceptor\n与Filter过滤器类似，用于预处理和后处理，原理为AOP。只对控制器方法进行拦截，不拦截资源访问\n○自定义拦截器\n实现HandlerInterceptor接口，并进行配置。\n\n\n类配置\n@Override\npublic void addInterceptors(InterceptorRegistry registry)&#123;\n    registry.addInterceptor(interceptor).addPathPatterns(\"/\");\n&#125;\n\n\nxml配置\n&lt;mvc:interceptors>\n\t&lt;mvc:interceptor>\n        &lt;mvc:mapping path=\"\"/>\n    \t&lt;bean/>\n    &lt;/mvc:interceptor>\n&lt;/mvc:interceptors>\n\n\nHandlerInterceptor\n// 执行前拦截\npublic boolean preHandle(req, resp, handler);\t\n// 执行后，返回前拦截\npublic void postHandle(req,resp, handler, modelAndView);\n// 流程完毕后拦截\npublic void afterCompletion(req, resp, handler, exception)\n\npreHandle返回为 True 时，后续操作才能执行。\nHandler为控制器方法执行对象（Method）\n\n\n\n○拦截器执行顺序\n多个拦截器执行时，并非串行，而是嵌套的，也就是说拦截器执行链最后执行的方法时第一个拦截器的afterCompletion。执行的顺序与配置的顺序有关，先配置先执行。\n○异常处理机制\n把异常处理抽取出来，通过异常处理组件统一解决，在SpringMvc中异常处理可以由DispatcherServlet调用响应组件处理。\n○异常处理器\nHandlerExceptionResolver\n\n\nSimpleMappingExceptionResolver\n框架自带的实现类。Mapping——发生异常时跳转到异常视图，映射关系通过配置完成。\n&lt;bean class=\"org.xx.x.SimpleMappingExceptionResolver\">\n\t&lt;property name=\"defalutErrorView\" vlaue=\"\"/>\n    &lt;property name=\"exceptionMappings\">\n    \t&lt;map>\n        \t&lt;entry key=\"\" value=\"\"/>\n        &lt;/map>\n    &lt;/property>\n&lt;/bean>\n\n\n○自定义异常处理器\n\n\n异常处理方法\n使用注解@ExceptionHanlder标注在方法上时，该方法为所在类的异常处理方法。\n\n\n异常处理类\n使用注解@ControllerAdvice标注在类上时，该类为全局的异常处理类。类内的方法使用@ExceptionHandler标注的方法将用于处理发生的异常。\n\n\n\n\n\n注解\n说明\n参数\n\n\n\n\n@ExceptionHanlder\n用于方法上，异常处理方法\n可以指定异常类，表示只处理个别异常\n\n\n@ControllerAdvice\n用于类上，全局的异常处理类\n无\n\n\n\n*异常处理方法，会被当做一个Controller处理，因此其返回值最终会包装成ModelAndView对象，所以可以使用 @ResponseBody注解\n○在Junit中使用MockMvc\n由于SpringMvc面向web层，因此无法直接调用Controller组件进行测试。\n○使用方法\n\n在Junit测试类上注解@WebAppConfiguration引入Web层配置文件\n使用IOC注入WebApplicationContext对象\n使用MockMvcBuilders创建MockMvc对象，需要传入WebApplicationContext初始化\n使用MockMvc进行测试\n\n○MockMvc\nMockMvc主要使用perform()方法向Controller发出请求，无需启动Tomcat服务器。perfrom方法的参数由MockMvcRequestBuilders创建，并返回一个ResultActions对象。\n\nMockMvcRequestBuilders：创建一个模拟请求，有get或post类型，能够设置请求体和请求头参数\nResultActions：通常使用andDo方法输出请求和响应的所有信息，执行andReturn返回MvcResult结果对象\nMvcResult：结果对象，包含request和response信息\n\n测试样例：\n@Test\npublic void test3() throws Exception&#123;\n    MvcResult res = mockMvc.perform(\n        MockMvcRequestBuilders\n        .post(\"/user/login\")\n        .contentType(MediaType.APPLICATION_FORM_URLENCODED)\n        .characterEncoding(\"UTF-8\")\n        .param(\"userName\", \"zhangsan\")\n        .param(\"password\", \"123\")\n    ).andDo(MockMvcResultHandlers.print()).andReturn();\n    System.out.println(res.getResponse().getContentAsString());\n&#125;\n○Mybatis-Spring\n前置-关于Mybatis的详细内容：Mybatis原始教程\nMaven：mybatis-spring\n○IOC注入\n将Mybatis的SqlSessionFactory等对象配置到SpringIOC容器中。\n\n\n配置SqlSessionFactory，主要是配置其数据源dataSource和核心配置文件configLocation（非必须）\n\n\nmapper组件扫描\n注解方式：\n\n@MapperScan(basepackage=&quot;&quot;)\n\n简洁方式：\n\n&lt;mybatis:scan base-package=&quot;&quot; /&gt;，这个方式不需要额外注解，但是也支持配置自定义注解来限制其扫描范围，指定annotation为自定义的注解即可。以上两种方法将映射器(DAO)z注入到SpringIOC时，默认使用首字母小写作为Bean的名称，可以在自定义注解中设置org.springframework.stereotype.Component 这样的注解既可以作为标记，也可以作为一个名字提供器来使用了。\n\n经典方式（不推荐使用了）：\n\n\n&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;\n\t&lt;property name=&quot;basePackage&quot; value=&quot;xx.xx&quot;/&gt;\n&lt;/bean&gt;\n\n\n\n\n\n配置完毕后即可使用依赖注入直接创建DAO/Mapper接口对象。\n○事务控制\n配置事务管理器transactionManager和事务增强，同样可以使用注解，同上文。配置完成后就可以像使用JdbcTempelate一样进行事务管理。\n○ExtraDetail\n○Properties/ResourceBundle\nproperties是一种键值对key=value储存文件，Java中自带的Properties类可以简单的读写properties文件，但是ResourceBundle类更好的支持了不同的语言，比前者要好一点。\n○Restful\nRestful是一种软件架构、设计风格，提供了一些原则和约束，可以帮助软件设计变得更加简介有层次，更易于实现缓存机制等。Restful风格表现为“url+请求方式”来表现一次HTTP请求，特点是请求参数用/接在url后面，而不再使用?来表示请求参数。如：http://url/api?id=1使用restful风格后应该是http://url/api/1。\nRestful规定请求方式具有如下几个含义:\n\nGET 表示获取\nPOST 表示新建\nPUT 表示更新\nDELETE 表示删除\n\n在前端中，form表单形式的请求是不支持PUT/DELETE的，需要使用隐藏的参数配合后端Filter完成请求映射，在spring-mvc使用自带的HiddenHttpMethodFilter来完成这个功能，通过指定隐藏参数的名自动从前端请求中获取Method值，但是前端显式的Method必须是&quot;POST&quot;形式。\n○FastJson\n由阿里巴巴开发的Json转化驱动。其中FastJsonHttpMessageConverter可以用于SpringMvc的消息转换器中。\n\n@JSONType: 可以标注在类上，通过指定orders参数可以决定转化该类时解析属性的顺序。\n@JSONFiled: 标注在成员变量上，可以指定转化后名称以及转化顺序\n@ResponseJSONP：标注在Controller类或方法上，并配置Bean:JsonpResponseAdvice，可实现注解方法返回Jsonp格式的数据，格式头取决于前端参数 callback，也可通过注解参数重新指定。(中文乱码问题)\n\n\n\n\n被代理的类 ↩︎\n\n目标对象被增强的方法 ↩︎\n\npointCut 目标对象的方法 ↩︎\n\n\n\n","categories":["后端"],"tags":["web","java"]},{"title":"Springboot快速入门","url":"/2021/03/16/springboot/","content":"从SSM过度——使用SpringBoot创建以Spring框架为基础的后端项目！\n\n🍃 SpringBoot\nSpringboot是一个极其方便的脚手架（CLI），从Springboot创建工程将变得非常容易，经过SSM的学习过渡到Springboot将会非常轻松，过度到Springboot需要掌握的知识主要是Springboot的配置方式 （yml/properties+注解），其中大部分内容都与SSM中相同。\n○IDEA build Springboot project\n使用idea新建项目中的Spring Initializer，按步骤即可创建 Springboot项目并导入其他框架的依赖。\n必备依赖：\n\nSpring Web\nJDBC API\nMySQL/SQLServer/Oracal等\n\n\nSpringboot的pom.xml默认继承Springboot父类，内部对spring-boot-*类型的jar包进行了版本管理dependenciesManager，因此我们只需要管理非springboot集成的jar包、\n○Springboot Config\nSpringboot的配置分为Application.class以及application.yml/.properties，yml具有更好的可读性和结构性。\n○Application\n使用注解@SpringBootApplication标注为入口类\n每个Springboot应用的入口类，类似于Spring的注解类，其注解已经配置好了一部分内容。我们需要在其中添加main方法：\npublic static main(String[] args) &#123;\n    SpringApplication.run(Application.class, args);\n&#125;\nSpringboot基本上使用注解进行配置，部分注解详见SSM篇\n○新注解\n&lt;!--注解处理器-->\n&lt;dependency>\n    &lt;groupId>org.springframework.boot&lt;/groupId>\n    &lt;artifactId>spring-boot-configuration-processor&lt;/artifactId>\n    &lt;optional>true&lt;/optional>\n&lt;/dependency>\n\n\n@ConfigurationProperties(prefix)\nprefix：寻找前缀为“prefix&quot;的属性，如jdbc\n该注解用于将application.properties/.yml中的配置项（某一项）读取到所注解的类中。类需要有&quot;同名&quot;[1]的属性，即可自动注入。\n⭐️该注解也可以应用在方法上，比如使用@Bean注释的方法上，文件中对应属性会注入到方法返回的对象（JavaBean）中\n\n\n@ConfigurationPropertiesScan\n一般标注在Application类上，标注后会能够自动扫描@ConfigurationProperties注解的类，注入到IOC中\n\n\n@EnableConfigurationProperties(class)\n标注在类上，标注后可以从指定的class中生成&quot;属性类&quot;[2]，注入到当前类中，作用类似@...Scan，只不过需要手动指定。\n\n\n@ServletComponentScan\n开启对@WebServlet、@WebFilter、@WebListener的支持。\n\n\n○application.yml\nSpringboot的核心配置文件，有且仅能使用该名称。该文件用于配置各种框架的参数，如jdbc、spring-mvc等一系列能够与Springboot集成的框架。能够被Springboot自动加载，不需要手动引入。\n○模块化\n以application-name.yml为格式的文件能够作为副配置文件，需要在主文件中“激活”\n# application.yml\nspring:\n  profiles:\n    active: &quot;name1,name2&quot;\n○Spring AOP\n&lt;dependency>\n    &lt;groupId>org.springframework.boot&lt;/groupId>\n    &lt;artifactId>spring-boot-starter-aop&lt;/artifactId>\n&lt;/dependency>\n不需要手动注解@EnableAspectJAutoProxy，即可使用AOP编程。\n○Springboot+SpringMvc\n通过application.yml可以直接配置Spring Mvc\n○新注解\n\n\n@RestController\n使用此注解标注的类中的方法不需要使用@ResponseBody，默认返回纯数据。\n\n\n@MatrixVariable\n获取请求中矩阵变量[3]的值，Springboot默认禁用了这个功能。Springboot对于请求路径的处理是使用了UrlPathHelper组件进行解析，其中对于;默认采用了**“截断”**的策略，因此无法获取分号后的内容，需要设置该组件中的removeSemicolonContent=false\n\n\n○静态资源访问\n**访问端口：**默认8080，通过application.yml指定server.port修改\nSpringboot默认会加载classpath:(/static)(/public)(/resource)(/META-INF/resources)下的文件作为静态资源。\n○配置拦截器、消息转换器等\n配置拦截器（包括视图解析器、消息转换器都一样）需要自定义一个配置类[4]并继承WebMvcConfigurer类，在SSM篇中有详细说明。\n\n⚠️Springboot默认为SpringMvc配置了许多内容，如果不希望覆盖默认的配置就不能使用@EnableWebMvc注解\n\n○数据类型转换器Converter\n自定义的数据类型转换器实现接口Converter&lt;S,D&gt;，并注解@Component即可完成自动装配。\n○字符集处理\n在SSM中我们需要配置过滤器CharacterEncodingFilter，但是在Springboot中我们不需要Web.xml文件，使用application.yml配置即可。\nserver:\n  servlet:\n    encoding:\n      charset: UTF-8\n○Springboot+Mybatis\n可以在IDEA项目创建阶段勾选SQL-&gt;Mybatis Framwork自动引入以下jar包\n&lt;dependency>\n    &lt;groupId>org.mybatis.spring.boot&lt;/groupId>\n    &lt;artifactId>mybatis-spring-boot-starter&lt;/artifactId>\n    &lt;version>2.1.4&lt;/version>\n&lt;/dependency>\n○连接池策略\n可以在IDEA项目创建阶段勾选SQL-&gt;JDBC API自动引入以下jar包\n&lt;dependency>\n     &lt;groupId>org.springframework.boot&lt;/groupId>\n     &lt;artifactId>spring-boot-starter-jdbc&lt;/artifactId>\n&lt;/dependency>\nspringboot默认使用HikariCP连接池，可以通过spring.datasource直接在配置文件中配置Jdbc参数。通过spring.datasource.type指定自己想要的连接池全限定类名即可更换，前提是需要手动导入相关依赖。\n○事务控制\nSpringboot不需要我们配置TransactionManager，只需要引入spring-boot-starter-jdbc即可使用注解@Transactional\n\n⚠️除非需要修改优先级（Order），否则不需要使用@EnableTransactionManagement\n\n○Mybatis配置\n\n\n配置文件\nmybatis的配置文件也同样直接在application.yml中编写，以mybatis前缀开头。\n\n\n@MapperScan\n使用方法与SSM篇中相同\n\n\n○Springboot Test\n&lt;dependency>\n    &lt;groupId>org.springframework.boot&lt;/groupId>\n    &lt;artifactId>spring-boot-starter-test&lt;/artifactId>\n    &lt;scope>test&lt;/scope>\n&lt;/dependency>\n测试类直接使用@SpringbootTest(class)注解并指定SpringbootApplication类，Springboot默认使用JUnit5！\n\n⚠️在单元测试中使用@Transactional注解就算执行成功也会自动回滚，如果需要提交事务请加上@Commit注解\n\n○Thymeleaf\nSpringboot对Thymeleaf模板引擎有很好的支持，但是也需要一些配置。\n○配置ViewController\n所有的thymeleaf文件都存放在resource/template中，无法当作静态资源进行访问的，需要通过SpringMvc的视图解析器进行访问，也就是说需要通过@Controller来访问View视图。\n\n\n方法一\n在Controller类中配置映射方法，并返回地址字符串，如return &quot;index&quot;表示访问resource/template/index.html\n\n\n方法二\n在SpringMvc配置类[4:1]中实现如下方法直接进行视图解析。\n@Override\npublic void addViewControllers(ViewControllerRegistry registry) &#123;\n    // 同一个View可以映射到多个地址上\n    registry.addViewController(\"/\").setViewName(\"index\");\n    registry.addViewController(\"/index\").setViewName(\"index\");\n    registry.addViewController(\"/index.html\").setViewName(\"index\");\n&#125;\n\n\n\n\n\n将中划线、下划线、驼峰等命名法视为同一个名称 详细描述 ↩︎\n\n使用@ConfigurationProperties注解标注的类 ↩︎\n\n在请求地址中使用;分割的变量称为矩阵变量 ↩︎\n\n使用@Configuration标注的类，在springboot中使用该注解的类会自动@Import到主配置类中，不需要手动引入 ↩︎ ↩︎\n\n\n\n","categories":["后端"],"tags":["web","java"]},{"title":"解决FastJson之JSONP中文乱码","url":"/2021/03/20/fastjsonperror/","content":"当SpringMvc使用fastjson的@ResponseJSONP返回jsonp给前端时，中文会出现乱码。\n\nJSONP中文乱码解决方法\n○问题描述\n在SpringMvc中使用fastjson提供的@ResponseJSONP注解返回JSONP数据时，会出现中文乱码问题，根本原因在于实际返回类型为application/javascript且没有指定charset=utf-8，即使设置@RequstMapping的producer属性为application/javascript;charset=utf-8也无法得到解决。关于此问题，Github上存在一个两年前的issue#1689，至今仍然OPEN，开发者仍不解决这个问题！\n○解决方法\n在issue中开发者提到：\n\nneil4dong commented on 12 Jul 2019\n@kakakeven 最终响应的Charset不取决于JSONPResponseBodyAdvice 的操作， JSONPResponseBodyAdvice 仅仅只是将返回结果做了封装， 实际响应Charset是取决于FastJsonHttpMessageConverter中的Charset配置。\n\n事实上，无论我怎么设置FastJsonHttpMessageConverter的Charset，事情也无法得到解决，因此只好重写JSONPResponseBodyAdvice ，因为通过HttpServletResponse指定ContentType是有效的！并且正好发现beforeBodyWriteInternal是个空实现的方法，并在返回JSONPObject之前调用了一次。\n实现类：\npublic class JsonpBodyAdvice extends JSONPResponseBodyAdvice &#123;\n    @Override\n    public void beforeBodyWriteInternal(JSONPObject jsonpObject, MediaType contentType, MethodParameter returnType, ServerHttpRequest request, ServerHttpResponse response) &#123;\n        ((ServletServerHttpResponse) response).getServletResponse().setContentType(\"application/javascript;charset=UTF-8\");\n    &#125;\n&#125;\n把上述类作为配置JSONP Advice时的类即可：\n@Configuration\npublic class SpringMvcConfig implements WebMvcConfigurer &#123;\n    @Bean\n    public JSONPResponseBodyAdvice jsonpResponseBodyAdvice() &#123;\n        return new JsonpBodyAdvice();\n    &#125;\n&#125;\n","categories":["问题"],"tags":["java"]},{"title":"在Springboot中使用Shiro","url":"/2021/03/26/springboot_shiro/","content":"Shiro总体来说还是很轻量的，也能够轻松的在Springboot项目中使用。\n\nSpringBoot-Shiro\n&lt;dependency>\n    &lt;groupId>org.apache.shiro&lt;/groupId>\n    &lt;artifactId>shiro-spring-boot-web-starter&lt;/artifactId>\n    &lt;version>1.7.1&lt;/version>\n&lt;/dependency>\n\n💬带web描述的依赖表示集成Web环境\n\n○简介\nShiro属于安全框架，通过Shiro可以轻松的实现登录认证、鉴权、授权、加密等常见的安全操作，Shiro框架的核心是SecurityManager、Realm和Subject，理解三者的关系以及作用即可完成Shiro的快速入门！\n\n\nSecurityManager\n框架的核心控制器，相当于Spring-mvc中的DispatcherManager，调度各种Realm并使用Authenticator进行认证和鉴权。\n\n\nRealm\n这是应用开发人员与框架的桥梁，最重要的的作用是向Shiro传递用户信息，包括账号密码，权限，角色也就是所谓的授权，用户的信息需要我们从数据库中获取，因此这个组件是我们使用Shiro中主要的自定义对象。\n\n\nSubject\n框架的使用入口，也相当于是一个会话对象Session，每个不同的用户访问Shiro都会提供不同的Subject，使用SecurityUtils进行获取。\n\n\n○执行流程图\n\n○快速入门\n○核心配置\n在SpringBoot使用Shiro需要三个完成最低限度的配置，分别是ShiroFilterChainDefinition、SessionsSecurityManager、DefaultAdvisorAutoProxyCreator，在@Configuration类中配置以下Bean\n\n\nSessionsSecurityManager\n@Bean\npublic SessionsSecurityManager securityManager(@Autowired Realm realm) &#123;\n    DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();\n    // 配置自定义的Realm\n    securityManager.setRealm(realm);\n    return securityManager;\n&#125;\n\n\nDefaultAdvisorAutoProxyCreator\n设置两个属性为true，解决Shiro与SpringAop的兼容问题\n@Bean\npublic static DefaultAdvisorAutoProxyCreator getDefaultAdvisorAutoProxyCreator()&#123;\n    DefaultAdvisorAutoProxyCreator defaultAdvisorAutoProxyCreator=new \t\t\tDefaultAdvisorAutoProxyCreator();\n    defaultAdvisorAutoProxyCreator.setUsePrefix(true);\n    defaultAdvisorAutoProxyCreator.setProxyTargetClass(true);\n    return defaultAdvisorAutoProxyCreator;\n&#125;\n\n\nShiroFilterChainDefinition\n为Shiro自带的Filter配置Pattern，能够配置多个，这是一个很重要的配置，关系到用户鉴权\n@Bean\npublic ShiroFilterChainDefinition shiroFilterChainDefinition() &#123;\n    DefaultShiroFilterChainDefinition chain = new DefaultShiroFilterChainDefinition();\n    // 配置所有请求路径都可以匿名访问 anno属于Shiro默认的过滤器\n    // 过滤顺序由添加的先后顺序决定\n    chain.addPathDefinition(\"/**\", \"anon\");\n    return chain;\n&#125;\n\n\n○编写基础Realm\nShiro内部实现了很多Realm，最主要的一个是AuthorizingRealm，因此我们自定义的对象也是它。\n@Component\npublic class Realm extends AuthorizingRealm &#123;\n\n    @Autowired\n    private UserService userService;\n\n    //授权\n    @Override\n    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) \t&#123;\n        User user = (User) principalCollection.getPrimaryPrincipal();\n        //添加权限信息（角色、权力）\n        SimpleAuthorizationInfo authorizationInfo = new SimpleAuthorizationInfo();\n        authorizationInfo.addRoles(user.getRoleList());\n        authorizationInfo.addStringPermission(user.getAllPermission());\n        return authorizationInfo;\n    &#125;\n\n    //认证\n    @Override\n    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123;\n        String username = (String) authenticationToken.getPrincipal();\n        User user = userService.findByName(username);\n        if (user == null) return null;\t//表示UnknownAccount异常\n        //返回认证信息\n        return new SimpleAuthenticationInfo (\n            user, user.getPassword(), getName()\n        );\n    &#125;\n&#125;\n\n💬第一次看到这个类一定会一头雾水，但是详细解读后将变得非常简单。\n\n○实现鉴权\n鉴权分为两条路径，一条是角色鉴定另一条是权力鉴定，一般我们使用Filter来鉴定角色，注解来鉴定权力。\n首先是使用注解@RequirePermission(value,logic)鉴定权限，value为权限名即上文代码中所述的StringPermission，属于数组，能够指定多个，logic是一个枚举，仅有AND、OR两种，表示多个value之间是且还是或的关系，默认为AND\n@RequirePermission(&#123;\"admin:read\",\"admin:write\"&#125;,Logic.AND)\npublic Object controllerMethod()&#123;&#125;\n其次是Filter，在上文中配置了/**表示任意路径，anon为匿名过滤器，允许未认证用户访问。还有其他过滤器以及我们自定义的过滤器都使用这种方式来配置，过滤器能通过用户所具有角色进行角色鉴定！\n\n💬无论是角色还是权限都能使用 Filter和注解，不过各有各的方便之处\n\n○Shiro原理解析\n○Subject\n代表当前会话的对象，从SecurityUtils中能够获得，最主要的方法就是login(token)方法，执行该方法后将进入Shiro框架的SecurityManager对象中，此时将会调用Realm中的doGetAuthenticationInfo()并传入从Login方法中获取的token进行验证。Login之后，当前会话的Subject中就会保存一个Principal，通过getPrincipal()方法获取。\n○Realm\ndoGetAuthenticationInfo方法用来验证传入的Token信息是否合法，判断逻辑由我们来编写，失败需要返回null，而成功需要返回认证信息，认证信息包括Principal、credentials、当前使用的RealmName以及用于MD5加密credentials的salt。\n\nShrio能够通过配置使用MD5加密Credentials\n对于credentialsSalt，在Shiro中为org.apache.shiro.util.ByteSource对象：\nByteSource credentialsSalt = ByteSource.Util.bytes(&quot;&quot;);\nByteSource提供了一个内部方法，可以将字符串转换为对应的盐值信息。一般情况下我们使用一个唯一的字符串作为盐值，这个salt需要同用户信息保存到数据库，再Realm中验证时需要使用同一个salt加密Token中的credential后进行比较验证。\n\n验证通过后会调用*doGetAuthorizationInfo()将当前会话的PrimaryPrincipal从principalCollection中取出，PrimaryPrincipal 由 doGetAuthenticationInfo 方法创建认证信息时指定。与Subject.Login传入的Token中的Principle不同，PrimaryPrincipal 将会代表整个会话。在这个阶段需要编写角色和权限获取的逻辑，并保存到一个授权信息对象中返回给SecurityManager\n\n⚠️Shiro使用单个Realm和多个Realm的策略是不同的，其中对异常的处理也是不同的，多Realm在认证失败的时候会很坑爹的抛出找不到对应Realm的异常，无法抛出自定义异常，详细情况和勉强的解决方法可以看这篇文章\nℹ️通过重写ModularRealmAuthenticator的doMultiRealmAuthentication可以改变多Realm调用策略，一种较好的方法是根据Token的类型使用唯一确定的Realm，然后调用doSingleRealmAuthentication方法\n\n○Filter\nFIlter是Shiro框架组成中的一个关键部分，Shiro所有鉴权和认证都是通过Filter进行的，内部实现了许多默认的Filter供开发人员配置，但是通过重写Shiro的FIlter类能够实现一套自定义的认证或鉴权逻辑，一般都会用来实现不同的认证，如token认证。\n○Filter详解\n○常用过滤器\n\n\n\n过滤器名\n作用\n对应注解\n\n\n\n\nanon\n允许匿名访问\n无\n\n\nauthc\n只允许认证用户访问\n@RequiresAuthentication\n\n\nroles\n只允许指定角色访问\n@RequiresRoles\n\n\nuser\n存在用户信息才可以访问\n@RequiresUser\n\n\nperms\n只允许拥有指定权限才能访问\n@RequiresPermission\n\n\nlogout\n清空访问用户的认证授权信息\n无\n\n\n\n\n⚠️roles和perms字符串末尾连接多个[name]来表示指定的角色或权限。\n\n○InvalidRequestFilter\n这是一个Shiro在springboot中默认配置的全局过滤器，作用是拦截过滤非法字符的Url，由于地方原因，这个过滤器会直接把中文字符是为非法，从而拦截请求，返回错误代码400。然而这种情况并不会影响有中文的QueryParameter请求，因为在过滤阶段，Shiro InvalidRequestFilter 将验证三种URL，其中我们可以从浏览器看到的Url中文会经过Url编码因此不会受到过滤器影响，而第二种则是来自Tomcat内部的ServerUrl这个表示除去QueryParameter的部分，且没有进行UrlDecode，对于普通的Get请求不存在中文映射则放行，而对于RESTFul风格的请求，如果有中文则会被拦截！\n○防止中文Restful请求被拦截\n从源码分析得出，只要替换掉InvalidRequestFilter则可以解决该问题。\n为了最大程度保留InvalidRequestFilter替我们实现好的的功能，我们直接复制一份源码修改其中用于判断字符的关键代码，然后配置到ShiroFilterFactoryBean中的globalFilter即可。\n贴出与原过滤器不同的部分，完整代码移步 GithubGist 复制粘贴。\n@Component\npublic class CNInvalidRequestFilter extends AccessControlFilter &#123;\n    //添加一个新的方法用于判断 Chinese Char\n    private static boolean isChinese(char c) &#123;\n        Character.UnicodeBlock ub = Character.UnicodeBlock.of(c);\n        return ub == Character.UnicodeBlock.CJK_UNIFIED_IDEOGRAPHS\n            || ub == Character.UnicodeBlock.CJK_COMPATIBILITY_IDEOGRAPHS\n            || ub == Character.UnicodeBlock.CJK_UNIFIED_IDEOGRAPHS_EXTENSION_A\n            || ub == Character.UnicodeBlock.CJK_UNIFIED_IDEOGRAPHS_EXTENSION_B\n            || ub == Character.UnicodeBlock.CJK_SYMBOLS_AND_PUNCTUATION\n            || ub == Character.UnicodeBlock.HALFWIDTH_AND_FULLWIDTH_FORMS\n            || ub == Character.UnicodeBlock.GENERAL_PUNCTUATION;\n    &#125;\n    private static boolean containsOnlyPrintableAsciiCharacters(String uri) &#123;\n        int length = uri.length();\n        for(int i = 0; i &lt; length; ++i) &#123;\n            char c = uri.charAt(i);\n            //将中文加入判断条件中\n            if ((c &lt; ' ' || c > '~') &amp;&amp; !isChinese(c)) &#123;\n                return false;\n            &#125;\n        &#125;\n        return true;\n    &#125;\n\n&#125;\n配置ShiroFilterFactoryBean\npublic ShiroFilterFactoryBean getShiroFilterFactoryBean(CNInvalidRequestFilter invalidRequestFilter) &#123;\n    ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean();\n    //...省略其他必须配置项，Cl为自用工具类，意思意思即可\n    shiroFilterFactoryBean.setFilters(\n        Cl.map().add(\"invalid\", invalidRequestFilter).castBuild()\n    );\n    shiroFilterFactoryBean.setGlobalFilters(\n        Cl.list(\"invalid\")\n    );\n    return shiroFilterFactoryBean;\n&#125;\n○自定义Filter\n最常见的是实现类AuthenticatingFilter，通过重写其onAccessDenied、createToken即可实现一个不同于Shiro默认的认证逻辑。\n\n推荐一篇文章，对Shiro各大Filter都进行了详细解读\n\n具体讲一讲AuthenticatingFilter这个认证过滤器。它默认实现了一个从请求中进行登录的功能 executeLogin(resq,resp)利用这个功能，我们能在用户会话失效认证失败后尝试进行自动登录，也就是再onAccessDenied中调用它，它将返回一个是否登录成功的布尔值，其中执行的逻辑是调用createToken从request或者response获取Token进入Realm中验证，因此我们可以利用这个性质在前后端通过一个唯一对应的值进行认证！也就是我们经常在抓包中经常见到的token字符串\nonAccessDenied方法会在默认的isAccessAllow返回False后调用作进一步的判断。默认的isAccessAllow其实是沿用了AccessControlFilter中的方法——对当前Subject对象进行判断是否处于认证状态来决定是否放行——并添加了一条isLoginRequest方法进行判断，该方法判断请求的连接是否是用于登录的连接，如果是则会放行，如果不是则最终调用onAccessDenied进行判断。\n○详细流程图\n\n","categories":["后端"],"tags":["web","java"]},{"title":"使用token完成Shrio鉴权认证","url":"/2021/03/27/shiro-token/","content":"用于前后端分离情况，需要使用token进行权限验证\n\n前后端分离——使用token完成Shrio鉴权认证\n○核心流程\n\n\n用户登录，保存token到数据库，并返回给前端\n用户访问资源并携带token，经过各种过滤器\n因为没有执行过Subject.login()所以访问限制资源是会被拦截失效\n失败后调用自定义Filter的onAccessDenied()，获取携带的token并执行登录(executeLogin)\n登陆时使用自定义的Realm验证token合法性和时效性，通过则返回认证信息\nShiro调用CredentialsMatcher验证输入的credentials与Realm中返回的认证信息是否匹配（需要自定义Mathcer）\n有了认证信息即可进行授权鉴权！！！\n\n\n○原理解析\n使用token进行登录认证，主要就是要求前端的请求需要合法token支持，所以这个token是前后端共享的，因此需要JWT进行加密，而设计Shiro认证时需要考虑到认证信息由默认的Username/Password转变成了自定义的Token，因此不能再使用原有的过滤器来控制认证鉴权，所以实现一个Filter是完成这个任务的一个至关重要的操作。\n○自定义Filter实现原理\n以不需要RememberMe为例，我们需要实现的 Filter Interface 为AuthenticatingFilter，实现几个关键的方法：\n\n\nAuthenticationToken createToken(request,response)\n这个方法将会在认证失败后尝试登录时调用（executeLogin），它返回的AuthenticationToken将作为Subject.login方法的参数，也就是**它将进入到我们自定义的Realm当中！**根据需求，此处创建AuthenticationToken 我们需要依赖于前端传递的token，因此我们是从request中获得的（请求头、请求体）\n无法获取怎么办呢？直接返回null即可，Shiro将会抛出IllegalStateException。\n\n\nboolean onAccessDenied(request,response)\n在请求被Filter验证失败时会调用此方法，该方法的返回值决定这个请求是否能够放行，在这个方法中我们才会执行登录操作！我们根据登录是否成功（Realm中返回认证信息）来决定是否放行，如何登录？就采用刚才所说的executeLogin方法，这是AuthenticatingFilter类已经实现了的方法，根据createToken返回的Token进行登录，如果登录成功即可返回true\n\n\n○自定义Realm实现原理\n使用Token方法进行验证的Realm其实与Username/Password的核心思想是相同的，只不过认证时通过前端的token从数据库中取出完整的token实体，对token本身的信息进行校验如是否失效等作为认证是否通过的依据。\n授权时，我们需要从Token实体中获取到用户对应的ID，通过ID从数据库中查找角色、权限进行然后正常的进行授权操作！\n○自定义Token\n这里要说的Token分为：\n\n\n\n前端能够获取到的token——String\n这个理应为一个加密后的字符串，也是认证流程中的核心。\n\n\nShiro进行认证的token—— AuthenticationToken\n实际上就是把String类型的token封装成实现接口的对象，其token作为Principal也作为Credentials\n\n\n保存于数据库中的token——JavaBean\n一个实体Entity类型的对象，与数据库设计有关，加密过的token应是其主要部分，此外，该token对应的用户与之是一对一关系，所以也可以保存对应用户的ID\n\n\n\n理清了各种Token，接下来要解决的就是Token如何加密的问题了，就如前面提到的，Token可以使用JWT，使用JWT可以方便的设置失效时间，节省数据库资源，也提供secret加密，能够进行二次验证，这里不再赘述使用方法。\n○自定义CredentialsMatcher\n@Override\npublic boolean doCredentialsMatch(AuthenticationToken authenticationToken, AuthenticationInfo authenticationInfo) &#123;&#125;\nToken是从前端获取的Token，Info是Realm返回的Info，在该方法中实现验证即可。\n\n😄自定义Matcher后需要注入到自定义的Realm中，通过setCredentialsMatcher方法\n\n","categories":["后端"],"tags":["web","java"]},{"title":"springboot+shiro整合redis","url":"/2021/04/18/shiroro-redis/","content":"将shiro的缓存交给redis管理，可以提高访问性能\n\nShiro快速整合Redis\n○安装Redis\n菜鸟教程-安装Redis(下载Github上的MSI安装包更加方便。)\n\n\n\nCMD命令\n功能\n\n\n\n\nredis-server\n启动redis服务\n\n\nredis-cli\n打开redis客户端\n\n\nget、set\n简单存取Key-Value\n\n\n\n\n部署在远程服务器的Redis，需要打开服务器:6379端口的防火墙，并配置redis.conf-protectmode no\n\n○Maven依赖\nSpringboot-Redis\n&lt;dependency>\n    &lt;groupId>org.springframework.boot&lt;/groupId>\n    &lt;artifactId>spring-boot-starter-data-redis&lt;/artifactId>\n&lt;/dependency>\nShiro-Redis\n&lt;dependency>\n    &lt;groupId>org.crazycake&lt;/groupId>\n    &lt;artifactId>shiro-redis-spring-boot-starter&lt;/artifactId>\n    &lt;version>$&#123;shiro-redis.version&#125;&lt;/version>\n&lt;/dependency>\n○配置ShiroConfig\n使用shiro-redis-spring-boot-starter将会自动配置Shiro的SessionSecurityManager，包括Realm、CacheManager和SessionManager，其中Realm为IOC容器中所有Realm的子类，而另外两个则是继承了父类并使用Redis作为缓存的类。\n由于通常情况下，我们需要配置Filter和filterMap等属性，所以只需要新配置ShiroFilterFactoryBean即可，通过参数注入框架为我们默认配置的对象并稍微修改即可正常使用。\n@Bean(\"shiroFilterFactoryBean\")\npublic ShiroFilterFactoryBean getShiroFilterFactoryBean(SessionsSecurityManager securityManager,\n                                                        Map&lt;String, Filter> filterMap,\n                                                        SelectiveRealmAuthenticator authenticator) &#123;\n    ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean();\n    //注入的manager已经配置好了Realm，如果没有重写authenticator则不需要进行修改\n    authenticator.setRealms(securityManager.getRealms());\n    securityManager.setAuthenticator(authenticator);\n    //设置安全管理器\n    shiroFilterFactoryBean.setSecurityManager(securityManager);\n    shiroFilterFactoryBean.setFilters(filterMap);\n    //spring自动注入的filterMap的key默认为class的simpleName\n    shiroFilterFactoryBean.setFilterChainDefinitionMap(\n        Cl.map().add(\"/**\",\"anon\")\n        .add(\"/user/info\", OAuth2Filter.class.getSimpleName())\n        .castBuild()\n    );\n    shiroFilterFactoryBean.setGlobalFilters(\n        Cl.list(CNInvalidRequestFilter.class.getSimpleName())\n    );\n    return shiroFilterFactoryBean;\n&#125;\n\n⚠️使用Redis存取的Object必须要实现Serializable接口\n\n○RedisTemplate\nspring为我们提供了一下两种对象，可直接注入使用：\n\n\nRedisTemplate&lt;Object,Object&gt;：Key-Value均为Object类型\n\n\n\n常用方法\n参数类型\n作用\n\n\n\n\ndelete\nObject... key\n删除一个或多个值\n\n\nexpire\nObject key，long timeout\n设置一个值的失效时间，使用getExpire可获取\n\n\nhaskey\nObject key\n查询是否存在值\n\n\nopsForValue().get()\nObject key\n获取值\n\n\nopsForValue().set()\nObject key，Object value\n设置值\n\n\nopsForXXX().XXX()\n省略\nRedis中包含多种数据结构，使用方法大致相同\n\n\n\n\n\nStringRedisTemplate：Key-Value均为String类型\n\n\n","categories":["后端"],"tags":["web","java"]},{"title":"C# PriorityQueue 优先队列","url":"/2021/04/23/donet-priorirtyqueue/","content":"基于可变长数组，使用异步编程优化的优先队列数据结构\n\nC# PriorityQueue 优先队列\n○Info\n○时间复杂度\n\n\n单次的输出，输入\n$$\nO(log(N))\n$$\n\n\n批量输入\n$$\nO(Nlog(N))\n$$\n\n\n\n○异步性\n对于批量输入、批量构造优先队列使用的是Task对象进行异步构造，通过在输入方法和输出方法中使用Wait防止并发问题。\n○比较器\n使用委托Comparison进行对象间比较\n○Github Gist\n","tags":["algorithm","c#"]},{"title":"mybatis-plus不好用？那就自己写！","url":"/2021/05/13/mybatisSqlBuilder/","content":"mybatisplus在设计上略有欠缺，导致整个框架有些笨重，因此决定抽出精华部分自己写\n\nMyBatis更加强大的动态SQL为什么不用MyBatis-PlusMP（mybatis-plus）是一个很便捷的框架，功能也很多，在大部分人眼中是一个超级好用的框架，事实上确实如此，只要不去在意其设计上的缺陷，但我偏偏就是有强迫症，就对MP的设计抱有疑问。\n\nMP本身不支持多表联查\nMP最吸引人的东西就是QueryWrapper，以及通过实体类的注解来自动的插入、更新数据，对于插入和更新没有问题，但是查询却只能在实体类上注解的TableName一张表上进行查询，让人有些遗憾。\n\nMP绑定的IService破坏了三层架构\n这就是我最疑惑的地方，在MP中只要不进行多表联查的话是不需要写Mapper的，因此对于条件查询使用的Wrapper是在Service层中进行的，这就必须涉及到在Service中写数据库的字段名，匹配哪些字段来进行查询——这个功能本身是由持久层完成的，不应该放在业务层中，如果数据库字段名出现更改，那么业务层中使用的方法，由于相同的查询可能写多次而导致修改的工作量变大，事实上对于一次查询的所有条件都包含在DTO内，因此只需要根据DTO内的值按规则进行查询即可，而规则对于一个DTO来说只有一个，也只需要编写一次。\n\n\n以上，可能由于我的无知造成误解\n实现动态SQLBuilder可以依赖于Mybatis自带的SQL进行二次封装。因此实现的Builder是用于Mybatis注解配置SQL的场景，在@XXXXProvider中使用。对框架没有任何本质增强，仅仅是简化动态生成SQL的代码量。\n自定义注解\n\n\n\n注解\n作用\n\n\n\n\n@UpdateField\n重命名实体对应表的名字，允许更新/插入\n\n\n@PrimaryField\n标注实体对应表的主键，可重命名\n\n\n\n\n/**\n * 带有此注解的 Field 即允许更新（包括插入），与数据库不同名可指定value值，默认同名不用赋值\n */\n@Target(ElementType.FIELD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface UpdateField &#123;\n    String value() default \"\";\n&#125;\n@Target(ElementType.FIELD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface PrimaryField &#123;\n    String value() default \"\";\n    /*是否自增*/\n    boolean auto() default true;\n&#125;\nInsertSQL对于插入语句的复杂场景无非就是批量插入，因此实现一个批量插入语句的构造器，依赖于自定义注解来保持规则。\npublic class InsertSQL extends BaseUpInSQL&lt;InsertSQL> &#123;\n    private final List&lt;?> data;\n\n    public InsertSQL(List&lt;?> batchData, String tableName) &#123;\n        this.data = batchData;\n        this.tableName = tableName;\n    &#125;\n\n    private String[] getIntoValueArray(String[] nameArray, int index) &#123;\n        String[] intoValueNames = new String[nameArray.length];\n        for (int i = 0; i&lt;intoValueNames.length; i++) &#123;\n            String cur = nameArray[i];\n            if (cur.matches(\".*\\\\$\")) &#123;\n                nameArray[i] = Str.removeEnd(cur);\n                //mybatis内部根据是否有L转化成长整形 此处无安全性风险可直接添加\n                intoValueNames[i] = String.valueOf(SqlBuilderConfig.snowFlake.generate());\n            &#125; else &#123;\n                intoValueNames[i] = Str.f(\"#&#123;list[&#123;&#125;].&#123;&#125;&#125;\",index, cur);\n            &#125;\n        &#125;\n        return intoValueNames;\n    &#125;\n\n    private String getFieldColumn(Field field, Annotation annotation) &#123;\n        String alias = field.getName();\n        if (annotation instanceof UpdateField) &#123;\n            UpdateField anno = (UpdateField) annotation;\n            alias = anno.value().isEmpty() ? alias : anno.value();\n        &#125;\n        else if (annotation instanceof PrimaryField) &#123;\n            PrimaryField anno = (PrimaryField) annotation;\n            alias = anno.value().isEmpty() ? alias : anno.value();\n        &#125;\n        if(isCamelToUnderscore()) alias = Str.toUnderscore(alias);\n        return alias;\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        INSERT_INTO(tableName);\n        if (data.size() == 0) return null;\n        Class&lt;?> dataClass = data.get(0).getClass();\n        Field[] fields = dataClass.getDeclaredFields();\n        List&lt;String> fieldNames = new ArrayList&lt;>(fields.length);\n        boolean hasFoundId = false;\n        for (Field field : fields) &#123;\n            //找主键 如果主键自增则跳过不插入主键\n            if (!hasFoundId) &#123;\n                PrimaryField anno = field.getDeclaredAnnotation(PrimaryField.class);\n                if (anno != null) &#123;\n                    hasFoundId = true;\n                    if (anno.snowFlake()) &#123;\n                        fieldNames.add(getFieldColumn(field,anno) + \"$\");\n                        continue;\n                    &#125; else if (anno.auto()) &#123;\n                        continue;\n                    &#125; else &#123;\n                        fieldNames.add(getFieldColumn(field,anno));\n                        continue;\n                    &#125;\n                &#125;\n            &#125;\n            //2 判断是否允许插入\n            UpdateField upAnno = field.getDeclaredAnnotation(UpdateField.class);\n            if (upAnno != null) &#123;\n                fieldNames.add(getFieldColumn(field, upAnno));\n            &#125;\n        &#125;\n        String[] names = fieldNames.toArray(Cl.emptyArr(String.class));\n        for (int i = 0; i &lt; data.size(); i++) &#123;\n            INTO_VALUES(getIntoValueArray(names, i));\n        &#125;\n        //雪花算法检测规则可能造成对 ID 列名的一些修改 需要处理后在INTO_COLUMNS 看起来不太优雅 但是性能比清晰的划分功能更高\n        INTO_COLUMNS(names);\n        return super.toString();\n    &#125;\n&#125;\nUpdateSQL更新语句主要在平时写的过程中主要时重复了“判空更新”的步骤，使用构造器简化代码。\n/**\n * 默认使用 &#123;@link PrimaryField&#125; 注解的属性作为 where 条件 &lt;br/>\n * 指定 &lt;b>keyFieldName&lt;/b> 则使用该值作为 where 条件 &lt;br/>\n * 也可使用方法 &lt;b>where()&lt;/b> 指定自己编写的 where 子句\n */\n@Slf4j\npublic class UpdateSQL extends SQL &#123;\n    private final Object data;\n    private final String tableName;\n    private String keyFieldName;\n    private String whereSql;\n\n    public UpdateSQL(Object data, String tableName) &#123;\n        this.data = data;\n        this.tableName = tableName;\n    &#125;\n\n    public UpdateSQL(Object data, String tableName, String keyFieldName) &#123;\n        this.data = data;\n        this.tableName = tableName;\n        this.keyFieldName = keyFieldName;\n    &#125;\n\n    public UpdateSQL where(String whereSql) &#123;\n        this.whereSql = whereSql;\n        return this;\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        UPDATE(tableName);\n        Field[] fields = data.getClass().getDeclaredFields();\n        String name = \"\";\n        String idFieldName = \"\";\n        String tableId = \"\";\n        String whereBy = \"\";\n        boolean hasFoundId = false;\n        try &#123;\n            for (Field field : fields) &#123;\n                name = field.getName();\n                //1 尝试找主键 主键不能更新\n                if (!hasFoundId) &#123;\n                    PrimaryField pAnno = field.getDeclaredAnnotation(PrimaryField.class);\n                    if (pAnno != null) &#123;\n                        hasFoundId = true;\n                        idFieldName = name;\n                        tableId = pAnno.value().isEmpty() ? name : pAnno.value();\n                        continue;\n                    &#125;\n                &#125;\n                UpdateField annotation = field.getDeclaredAnnotation(UpdateField.class);\n                //2 判断是否使用自定义的 where 条件\n                if (!Str.empty(keyFieldName) &amp;&amp; keyFieldName.equals(name)) &#123;\n                    whereBy = annotation == null || annotation.value().isEmpty() ? name : annotation.value();\n                &#125;\n                //3 判断是否需要更新\n                if (annotation == null) continue;\n                field.setAccessible(true);\n                String alias = annotation.value().isEmpty() ? name : annotation.value();\n                if (field.get(data) != null) &#123;\n                    SET(Str.f(\"&#123;&#125;=#&#123;&#123;&#125;&#125;\", name, alias));\n                &#125;\n            &#125;\n            if(Str.empty(whereSql)) &#123;\n                if (Str.empty(keyFieldName) || Str.empty(whereBy)) &#123;\n                    keyFieldName = idFieldName;\n                    whereBy = tableId;\n                &#125;\n                WHERE(Str.f(\"&#123;&#125;=#&#123;&#123;&#125;&#125;\", whereBy, keyFieldName));\n            &#125; else &#123;\n                WHERE(whereSql);\n            &#125;\n        &#125; catch (IllegalAccessException e) &#123;\n            log.error(\"update sql build failed, couldn't access &#123;&#125; of &#123;&#125;\", name, data.getClass().getSimpleName());\n            return null;\n        &#125;\n        return super.toString();\n    &#125;\n&#125;\nQuerySQL实现只写“字段名”来构造查询Sql，仅仅只填写字段然后获得语句，内部还是使用mybatis的SQL，判断DTO字段对应值是否为空来决定是否应用where语句，使用者无需进行判断。\n@SuppressWarnings(\"unchecked\")\npublic abstract class BaseQuerySQL&lt;T> &#123;\n    private final Object dto;\n    private final SQL sql;\n\n    public BaseQuerySQL(Object dto, String tableName) &#123;\n        this.dto = dto;\n        this.sql = new SQL();\n        sql.FROM(tableName);\n    &#125;\n\n    public T join(String... joinSql) &#123;\n        sql.JOIN(joinSql);\n        return (T)this;\n    &#125;\n\n    public T select(String... columns) &#123;\n        sql.SELECT(columns);\n        return (T)this;\n    &#125;\n\n    public T group(String... columns) &#123;\n        sql.GROUP_BY(columns);\n        return (T)this;\n    &#125;\n\n    public T having(String havingSql) &#123;\n        sql.HAVING(havingSql);\n        return (T)this;\n    &#125;\n\n    private void where(String whereSql, String column, String fieldName) &#123;\n        if (fieldName == null) fieldName = column;\n        if (isNotNULL(fieldName)) &#123;\n            sql.WHERE(Str.f(whereSql, column, fieldName));\n        &#125;\n    &#125;\n    \n    protected T unsafeWhere(String whereSql) &#123;\n        sql.WHERE(whereSql);\n        return (T)this;\n    &#125;\n    \n    //通过此方法复合一组条件实现 xxx AND (xx OR xx) 这种逻辑表达式\n    public T conditions(Condition... conditions) &#123;\n        StringBuilder stringBuilder = new StringBuilder();\n        stringBuilder.append(\"(\");\n        boolean isFst = true;\n        for (Condition condition : conditions) &#123;\n            if (isNotNULL(condition.getFieldName())) &#123;\n                if (isFst) &#123;\n                    condition.removeLogic();\n                    isFst = false;\n                &#125;\n                stringBuilder.append(\" \").append(condition.toString());\n            &#125;\n        &#125;\n        stringBuilder.append(\")\");\n        String s = stringBuilder.toString();\n        if (s.equals(\"()\")) &#123;\n            return (T) this;\n        &#125;\n        return unsafeWhere(s);\n    &#125;\n\n    private boolean isNotNULL(String fieldName) &#123;\n        try &#123;\n            Field field = dto.getClass().getDeclaredField(fieldName);\n            field.setAccessible(true);\n            return field.get(dto) != null;\n        &#125; catch (Exception e) &#123;\n            return false;\n        &#125;\n    &#125;\n\n    public T eq(String column, String fieldName) &#123;\n        where(\"&#123;&#125; = #&#123;&#123;&#125;&#125;\", column, fieldName);\n        return (T)this;\n    &#125;\n\n    public T neq(String column, String fieldName) &#123;\n        where(\"&#123;&#125; != #&#123;&#123;&#125;&#125;\", column, fieldName);\n        return (T)this;\n    &#125;\n\n    public T le(String column, String fieldName) &#123;\n        where(\"&#123;&#125; &lt;= #&#123;&#123;&#125;&#125;\", column, fieldName);\n        return (T)this;\n    &#125;\n\n    public T lt(String column, String fieldName) &#123;\n        where(\"&#123;&#125; &lt; #&#123;&#123;&#125;&#125;\", column, fieldName);\n        return (T)this;\n    &#125;\n\n    public T ge(String column, String fieldName) &#123;\n        where(\"&#123;&#125; >= #&#123;&#123;&#125;&#125;\", column, fieldName);\n        return (T)this;\n    &#125;\n\n    public T gt(String column, String fieldName) &#123;\n        where(\"&#123;&#125; > #&#123;&#123;&#125;&#125;\", column, fieldName);\n        return (T)this;\n    &#125;\n\n    public T or() &#123;\n        sql.OR();\n        return (T)this;\n    &#125;\n\n    public T like(String column, String fieldName, LikeType type) &#123;\n        switch (type) &#123;\n            case L: fieldName = \"%\" + fieldName;\n            case R: fieldName = fieldName + \"%\";\n            case LR: fieldName = \"%\" + fieldName + \"%\";\n        &#125;\n        where(\"&#123;&#125; like #&#123;&#123;&#125;&#125;\", column, fieldName);\n        return (T)this;\n    &#125;\n\n    public T regexp(String column, String fieldName) &#123;\n        where(\"&#123;&#125; regexp #&#123;&#123;&#125;&#125;\", column, fieldName);\n        return (T)this;\n    &#125;\n\n    @Override\n    public String toString() &#123;\n        return sql.toString();\n    &#125;\n&#125;\n","categories":["后端"],"tags":["web","java"]},{"title":"分布式日志（一）分布式事务管理","url":"/2021/06/19/distribute-transaction/","content":"分布式日志系列第一篇，关于分布式事务的学习与理解\n\n分布式事务管理\n解决不同进程/微服务同一个事务过程的管理问题，使物理上无关但逻辑上相关事务能够保证一致性、可用性、分区容忍性（CAP）\n○CAP理论\n\n\nC 即  一致性\n对于数据读取，每次要保证读取的数据是最新修改过的数据，允许调用失败。\n\n\nA 即 可用性\n对于服务访问必须得到回复，不允许调用失败，但允许不一致数据。\n\n\nP 即 分区容忍性\n允许部分服务出错，但是不能影响系统其他部分的可用性。相当于单体服务分割为微服务。\n\n\nCAP三者不可兼得，该如何取舍：\n\nCA: 优先保证一致性和可用性，放弃分区容错。 这也意味着放弃系统的扩展性，系统不再是分布式的，有违设计的初衷。\nCP: 优先保证一致性和分区容错性，放弃可用性。在数据一致性要求比较高的场合(譬如:zookeeper,Hbase) 是比较常见的做法，一旦发生网络故障或者消息丢失，就会牺牲用户体验，等恢复之后用户才逐渐能访问。\nAP: 优先保证可用性和分区容错性，放弃一致性。跟CP一样，放弃一致性不是说一致性就不保证了，而是逐渐的变得一致。\n\n○2PC原理\n对多个事务统一管理，即两段式提交。\n\n管理器向事务提交开始的请求，事务响应\n管理器像事务提交结束的请求，事务响应（成功或失败）\n\n若其中一个事务开启失败、提交失败则对所有事务进行回滚操作。该原理决定了2PC模式是一种强一致性的模式，能够满足CP要求，但是两次提交会造成较高的代价，性能低下，可能造成单点故障问题导致服务不可用。\n○XA方案\nXA方案是以2PC原理为基础的一个分布式事务解决方案，该方案依赖于数据库提供本地资源管理器接口，即XA接口的实现，然后通过统一的事务管理器对事务进行管理。\n具体过程与2PC原理相似。\n○BASE理论\nbase理论是对2PC理论的改进，具体体现在允许暂时的不一致性从而保证高可用性，最终逐渐达到一致性，与2PC相比，改进后的理论更具有实用性，因为它不在对已完成的事务加锁，从而提高了并发性能。\n○Seata-2pc方案\nseata是阿里巴巴开源的分布式事务管理框架，基于Base理论。在XA方案的基础上进行了改良，提高了并发性能。\nseata是由事务管理器、事务协调器和本地资源管理器构成。\n对于事务协调器（TC）能够独立的运行在一个服务器上。在seata中事务管理器不在承担所有功能，也不再使用数据库提供的XA接口。对于每一个相关事务一次提交后即释放锁，因此可能存在读写不一致的问题。\n\n\n事务协调器\n事务协调器执行事务管理器的通知（回滚或提交），记录全局事务与分支事务的关系。\n\n\n事务管理器\n开启全局事务、注册分支事务，嵌入到应用程序当中。\n\n\n○可靠消息最终一致性方案\n通过消息传递来控制事务的进行。\n\n\n可靠性\n当一个事务成功执行时需要保证一条成功执行的消息发送到消息队列中。同理事务失败时不可发送消息，即消息与事务具有原子性。\n\n\n最终一致性\n另一个事务要保证收到消息并成功执行事务。\n\n\n存在问题：最终一致性要求消息接收方事务必须执行成功，因为消息发送方事务无法进行回滚。\n○RocketMQ实现\n\n\n消息预发送\n事务执行前先发送下一个事务执行的消息但不投递，得到ACK回复后开始事务。\n\n\n消息确认\n\n\n事务成功\n事务执行成功后向消息队列发送确认消息，消息队列将消息投递\n\n\n事务失败\n事务执行失败则要求消息队列丢弃预发送的消息\n\n\n未收到确认\n由于其他不可控因素导致消息队列未收到进一步回复，需要对发起方的事务进行回查。\n\n\n\n\nRockectMQ相当于一个事务的协调器。通过RocketMQLocalTransactionListener接口可用于实现事务的回查。\n","categories":["分布式"],"tags":["web","java"]},{"title":"Vue自定义组件v-model","url":"/2021/06/23/vue-custom-vmodel/","content":"关于Vue.js中在自定义组件中使用 v-model 进行双向绑定的最佳实践\n\nVue自定义组件使用v-model\n○实现代码\n&lt;script&gt;\nexport default &#123;\n    data() &#123;\n        return &#123;\n            myData: this.modelValue\n        &#125;\n    &#125;,\n    props: [&#39;modelValue&#39;],\n    watch: &#123;\n        myData: (newVal, oldVal) &#x3D;&gt; &#123;\n            this.$emit(&#39;update:modelValue&#39;,newVal);\n        &#125;\n    &#125;\n&#125;\n&lt;&#x2F;script&gt;\n○简单解释\n\n\nVue.js 要求组件的props内的属性为单向数据流，即父组件对props内的数据修改后，组件内的prop也会响应改变，但是不允许组件直接对prop进行修改或作为组件内另一子组件的v-model。\n错误示范：\n&lt;template&gt;\n&lt;!--报错！！--&gt;\n&lt;input v-model&#x3D;&quot;propData&quot; &#x2F;&gt;\n&lt;&#x2F;template&gt;\n&lt;script&gt;\nexport default &#123;\n    props:[&#39;propData&#39;],\n    method: &#123;\n        myFunc() &#123;\n            &#x2F;&#x2F;报错！！\n            this.propData &#x3D; &#39;anyData&#39;\n        &#125;\n    &#125;\n&#125;\n&lt;&#x2F;script&gt;\n\n\nVue.js中自定义组件的v-model将会解析成:value=&quot;data&quot;和@update:model-value=&quot;data=$event&quot;，所以自定义组件必须要有名为value的props，并在需要改变时使用$emit调用update:modelValue方法。\n\n\n○问题补充\n前一段时间自定义组件时突然发现父组件更新子组件不更新的情况，加上反向监听后得以解决。\nwatch: &#123;\n    myData: (newVal, oldVal) => &#123;\n        this.$emit('update:modelValue',newVal);\n    &#125;,\n    modelValue(newVal,oldVal)=>&#123;\n        this.myData = newVal;\n    &#125;\n&#125;\n","categories":["前端"],"tags":["vue"]},{"title":"分布式日志（二）注册中心和配置中心","url":"/2021/08/07/distribute-registry-config/","content":"分布式日志系列第二篇，关于服务注册中心和配置中心的学习\n\n注册中心和配置中心\n注册中心是保存微服务地址的地方，配置中心是保存微服务配置文件的地方。\n○为何需要注册中心\n注册中心的功能很简单，微服务启动时向注册中心发送注册请求，需要调用其他微服务时通过服务名称从注册中心获取真实的IP:PORT。与直接使用真实地址相比有以下好处：\n\n通过注册中心控制台可以方便的下线故障或过时的微服务，防止其他微服务调用\n服务器更换后真实地址发生改变但服务名不变，降低微服务间的耦合性\n方便通过Ribbon等负载均衡器从集群中选择一台服务器。（最重要的特点）\n\n注册中心在集群环境下十分必要具体体现在1，3两点。\n○为何需要配置中心\n配置中心的功能也很简单，微服务注册时通过命名规范匹配配置中心中的文件，推送到对应的服务器上，相当于把application.yml从项目中分离出来，使得微服务的配置更新变得更加容易。\n\n不需要打开Jar包修改配置文件\n某些情况下不需要重启微服务\n\n○Nacos\n○简介\nnacos是SpringCloudAlibaba中的一个组成部分，承担注册中心和配置中心的角色。\n通过部署Nacos-server可以直接启动注册中心和配置中心，每个微服务相当于Nacos-client，配置Nacos-server的地址后即可注册微服务和获取配置文件。\n○配置\n对应依赖名称：\n&lt;dependency>\n\t&lt;groupId>com.alibaba.cloud&lt;/groupId>\n    &lt;artifectId>spring-cloud-starter-alibaba-nacos-discovery&lt;/artifectId>\n&lt;/dependency>\n&lt;dependency>\n\t&lt;groupId>com.alibaba.cloud&lt;/groupId>\n    &lt;artifectId>spring-cloud-starter-alibaba-nacos-config&lt;/artifectId>\n&lt;/dependency>\n\n启用配置中心后，项目的配置文件需改名为 bootstrap.yml并配置必要参数：\n\nspring.application.name\nspring.cloud.nacos.server-addr\nspring.cloud.nacos.username\nspring.cloud.nacos.password\nspring.cloud.nacos.config.file-extension\n\n\n○热更新\nNacos支持配置文件发布后进行热更新，须在类上标注@RefreshScpoe可实现引用配置项的热更新。\n","categories":["分布式"],"tags":["web","java"]},{"title":"Seata事务分组的正确实践","url":"/2021/08/17/seata-tx-group/","content":"关于Seata部署和配置中遇到的摸棱两可的场景\n\nSeata事务分组的正确实践\nseata的文档和github上的案例着实有点坑人了！\n○server端配置\nserver端根据文档中的 高可用部署 进行配置，其中修改config.txt 中的 service.vgroupMapping.my_test_tx_group 是一个错误的配置项，具体在github中 seata/seata-samples中的 springcloud-nacos下的文档中说明了 高版本的不可使用下划线 需使用上划线。（文档中却不说明）\nmy_test_tx_group 其实是一个分组名，可以自行决定！\nseata通过该分组名找到 seata-server 对应的集群名称，然后在找到该集群的服务列表。\n因此在配置config.txt时 service.vgroupMapping.xxxx后面的值为集群名称。在使用nacos进行注册时，该集群名称在registry.conf中的 nacos.cluster 决定。因此config.txt中的 service.xxxx.grouplist 是可以不用配置的（仅在文件模式下有效）。\n○client端配置\nseata-samples 有太多老样例没更新了，根本不能作为参考。\n在 application.yml 中可以配置 nacos 注册中心和配置中心的地址及参数，最重要的是配置 seata.tx-service-group该项对应了 server 端中的 service.vgroupMapping.xxxx 因此在同一个组内的微服务需要配置相同的分组名。\n1.4.2 clinet端默认在注册中心中找 SEATA_GROUP 下的seata-server集群，因此部署server端时需要更改nacos配置下的 group 为 SEATA_GROUP\n\n值得注意的是 spring.cloud.alibaba.seata.tx-service-group 也是配置分组名的选项 显然与seata中的选项重复了！ 在两年前的官方样例和目前官方文档之事务分组章节中使用的是改项，个人认为这是一个过时的选项 可以不用管它\n\n","categories":["分布式"],"tags":["web","java"]},{"title":"拓展SpringCache的功能（动态TTL+正则Evict）","url":"/2021/08/16/spring-cache/","content":"SpringCache的缓存框架存在一些功能上不完善的地方，本文记录通过重写CacheManager与Cache对功能进行增强。\n\nSpringCache拓展TTL、Evict\n拓展一个框架的的功能 首先需要找到框架的拓展点，一个成熟的框架总会留下几个接口能够方便开发人员拓展自定义的功能，SpringCache也不例外。\n○寻找拓展点\n寻找拓展点的方法如下：\n\n阅读源码\n阅读官方文档\nDebug调试\n参考网络实践者的经验\n\n通过以上四种方法 我把拓展点定位到了 RedisCacheManager 与 RedisCache 上\n○自定义RedisCacheManager实现动态TTL\nSpringCache通过CacheManager接口的getCache方法获取将要缓存到Redis中的对象。在AbstractCacheManager中实现了该方法\npublic Cache getCache(String name) &#123;\n    Cache cache = (Cache)this.cacheMap.get(name);\n    if (cache != null) &#123;\n        return cache;\n    &#125; else &#123;\n        Cache missingCache = this.getMissingCache(name);\n        if (missingCache != null) &#123;\n            synchronized(this.cacheMap) &#123;\n                cache = (Cache)this.cacheMap.get(name);\n                if (cache == null) &#123;\n                    cache = this.decorateCache(missingCache);\n                    this.cacheMap.put(name, cache);\n                    this.updateCacheNames(name);\n                &#125;\n            &#125;\n        &#125;\n\n        return cache;\n    &#125;\n&#125;\n而RedisCacheManager则是通过重写 getMissingCache 来实现RedisCache的拓展\nprotected RedisCache getMissingCache(String name) &#123;\n    return this.allowInFlightCacheCreation ? this.createRedisCache(name, this.defaultCacheConfig) : null;\n&#125;\n其中 allowInFlightCacheCreation 在默认情况下为真，因此最重要的方法便来到了 createRedisCache上\nprotected RedisCache createRedisCache(String name, @Nullable RedisCacheConfiguration cacheConfig) &#123;\n\treturn new RedisCache(name, this.cacheWriter, cacheConfig != null ? cacheConfig : this.defaultCacheConfig);\n&#125;\n可以发现RedisCache使用了RedisCacheConfiguration来作为缓存的参数载体，在最终保存时用到了配置对象中的TTL来作为失效时间。\n通过继承 RedisCacheManager 来进行拓展\npublic class RedisAutoCacheManager extends RedisCacheManager &#123;\n    //自定义缓存时间填写格式 通过 cacheName + #+时间 设定\n    private static final String SPLIT_FLAG = \"#\";\n    //校验值常量\n    private static final int CACHE_LENGTH = 2;\n    //自定义缓存时间单位\n    private static final String MINUS_UNIT = \"m\";\n    private static final String HOUR_UNIT = \"h\";\n    private static final String SECOND_UNIT = \"s\";\n    //以下两对象在父类中为private 因此需要记得在继承的构造方法中另外获取\n    private final RedisCacheWriter writer;\n    private final RedisCacheConfiguration defaultRedisConfig;\n\n    //constructor 省略构造函数\n\n    @Override\n    protected RedisCache createRedisCache(String name, RedisCacheConfiguration cacheConfig) &#123;\n        //未设置则走默认方法\n        if (name.isBlank() || !name.contains(SPLIT_FLAG)) &#123;\n            return getAutoRedisCache(name, cacheConfig);\n        &#125;\n\n        String[] cacheArray = name.split(SPLIT_FLAG);\n        //真实的cacheName\n        String curName = cacheArray[0];\n        //#后未填写时间走默认方法\n        if (cacheArray.length &lt; CACHE_LENGTH) &#123;\n            return getAutoRedisCache(curName, cacheConfig);\n        &#125;\n\n        if (cacheConfig != null) &#123;\n            String cacheTTL = cacheArray[1].toLowerCase();\n            Duration duration;\n            //获取缓存TTL\n            if (cacheTTL.contains(MINUS_UNIT)) &#123;\n                duration = Duration.ofMinutes(getTTL(cacheTTL, MINUS_UNIT, 1));\n            &#125; else if (cacheTTL.contains(HOUR_UNIT)) &#123;\n                duration = Duration.ofHours(getTTL(cacheTTL, HOUR_UNIT, 1));\n            &#125; else if (cacheTTL.contains(SECOND_UNIT)) &#123;\n                duration = Duration.ofSeconds(getTTL(cacheTTL, SECOND_UNIT, 1));\n            &#125; else &#123;\n                return getAutoRedisCache(curName, cacheConfig);\n            &#125;\n            log.info(\"generate cache with ttl &#123;&#125;-&#123;&#125;\", cacheTTL, duration);\n            //自定义缓存TTL\n            cacheConfig = cacheConfig.entryTtl(duration);\n        &#125;\n        return getAutoRedisCache(curName, cacheConfig);\n    &#125;\n\n    private RedisCache getAutoRedisCache(String name, RedisCacheConfiguration cacheConfig) &#123;]\n        //RedisAutoCache extends RedisCache\n        //如果没有cacheConfig则使用默认的redisCacheConfig\n        return new RedisAutoCache(name, this.writer, cacheConfig != null ? \n                                  cacheConfig : this.defaultRedisConfig);\n    &#125;\n\t\n    private long getTTL(String cacheTTL, String unit, long def) &#123;\n        String[] split = cacheTTL.split(unit);\n        if (split.length > CACHE_LENGTH) &#123;\n            return Long.parseLong(split[0]);\n        &#125;\n        return def;\n    &#125;\n&#125;\n○自定义Cache实现正则删除\n在 Cache 中 evict 用于执行缓存失效的方法，RedisCacheWriter 为具体执行单位，其中的 clear 方法即通过 keys pattern 获取符合表达式的 key 再执行批量方法\npublic class RedisAutoCache extends RedisCache &#123;\n    private final RedisCacheWriter cacheWriter;\n    protected RedisAutoCache(String name, RedisCacheWriter cacheWriter, RedisCacheConfiguration cacheConfig) &#123;\n        super(name, cacheWriter, cacheConfig);\n        this.cacheWriter = cacheWriter;\n    &#125;\n\n\n    /**\n     * 提供批量删除\n     * @param key 带 ‘*’ 的key\n     */\n    @Override\n    public void evict(Object key) &#123;\n        String cacheKey = this.createCacheKey(key);\n\t\t//如果包含通配符则使用批量删除\n        if (cacheKey.contains(\"*\")) &#123;\n            log.info(\"cache multi evict, pattern &#123;&#125;\",cacheKey);\n            cacheWriter.clean(this.getName(), this.serializeCacheKey(cacheKey));\n        &#125; else &#123;\n            super.evict(key);\n        &#125;\n    &#125;\n&#125;\n○自定义配置文件\nSpringCache对应的自动配置文件在获取不到 CacheManager对象时才会执行，自定义RedisCacheManager 后 需要自行编写配置文件：\n@Configuration(proxyBeanMethods = false)\n//获取application.yml中填写的配置信息 该对象仅在自动装配时注入 自定义时需自行引入\n@EnableConfigurationProperties(&#123;CacheProperties.class&#125;)\npublic class RedisConfig &#123;\n    \n    //注入自定义CacheManager\n    @Bean\n    public CacheManager redisAutoCacheManager(RedisCacheWriter writer, RedisCacheConfiguration defConfig) &#123;\n        return new RedisAutoCacheManager(writer,defConfig);\n    &#125;\n    \n\t//从静态方法中获取RedisCacheWriter \n    //nonlocking表示无锁，缓存操作将同时进行,性能较高但可能返回过时数据\n    //有提供 lockingRedisCacheWriter\n    @Bean\n    @ConditionalOnMissingBean\n    public RedisCacheWriter redisCacheWriter(RedisConnectionFactory redisConnectionFactory) &#123;\n        return RedisCacheWriter.nonLockingRedisCacheWriter(redisConnectionFactory);\n    &#125;\n\n    /**\n     * 注入自定义默认配置文件 spring将会使用此Bean作为RedisCacheManager配置文件\n     */\n    @Bean\n    public RedisCacheConfiguration redisCacheConfiguration(CacheProperties cacheProperties,\n                                                           RedisTemplate&lt;Object,Object> redisTemplate) &#123;\n        CacheProperties.Redis redisProperties = cacheProperties.getRedis();\n        RedisCacheConfiguration config = RedisCacheConfiguration\n                .defaultCacheConfig().serializeValuesWith(\n                        RedisSerializationContext\n                                .SerializationPair.fromSerializer(redisTemplate.getValueSerializer())\n                );\n\n        if (redisProperties.getTimeToLive() != null) &#123;\n            config = config.entryTtl(redisProperties.getTimeToLive());\n        &#125;\n\n        if (redisProperties.getKeyPrefix() != null) &#123;\n            config = config.prefixCacheNameWith(redisProperties.getKeyPrefix());\n        &#125;\n\n        if (!redisProperties.isCacheNullValues()) &#123;\n            config = config.disableCachingNullValues();\n        &#125;\n\n        if (!redisProperties.isUseKeyPrefix()) &#123;\n            config = config.disableKeyPrefix();\n        &#125;\n\n        return config;\n    &#125;\n&#125;\n○可能存在的问题\nCacheAutoConfiguration 中并没有显式的注入CacheManager 而是提供了其他一系列对象，暂时不清楚其用途，自定义配置文件中未注入这些对象可能会引发一些问题，我在实际使用中暂时还未发现，目前仍在正常使用。\n","categories":["后端"],"tags":["web","java"]},{"title":"Vue中ElementPlus与Tailwindcss冲突问题解决","url":"/2021/08/18/vue-elemnt-tailwind/","content":"使用ElementPlus 对 vue-cli@4.5+ 的插件与Tailwindcss在build时出现顺序冲突\n\n○问题描述\n直接 npm run serve 时样式一切正常，build部署到生产环境时 tailwindcss 样式被原本的 elementui 样式覆盖，导致样式错乱。\n○原因\ntailwindcss与scss兼容性较差，而elementplus提供的插件在安装了scss-loader的情况下使用.scss文件来引入全局样式，导致构建时taiwindcss晚一步被打包，部署后分包请求css时是先进行elementplus的样式请求（包含在了app.xxxxx.css内，所以就选tailwindcss再最后引入也无法改变构建后的顺序）\n○解决方案\n将src目录下的element-variables.scss文件删除，然后更改src/plugins/element.js内import该文件的那段代码，改为直接引用element-plus/lib/theme-chalk/index.css，然后确保main.js中tailwindcss样式文件在该插件之后引入即可。\n","categories":["前端"],"tags":["vue"]},{"title":"分布式日志（三）OAuth2安全控制","url":"/2021/08/21/distribute-security/","content":"分布式日志第三篇，基于SpringSecurity的分布式系统的安全管理方案\n\n分布式安全协议\n微服务架构下的安全方案有许多种，如\n\n共享Session （最容易实现）\nToken凭证 （最高可用性）\nSSO单点登录 (折中方案)\n\n○共享Session\n由认证服务器认证后将本地Session保存在Redis中，其他服务器读取Redis中的Session对请求进行身份认证，最大的优点是不需要多余的代码，可以像开发单体应用一样开发安全管理系统\n缺点：Redis服务或认证服务不可用时 将无法访问所有的资源服务器。\n○基于OAuth2协议的Token认证方案\nToken也分为两种模式：\n\n\n短Token\n认证服务器颁发access_token，与之对应的是储存在Redis或数据库中的权限信息，资源服务通过此凭证向认证服务器请求认证，从而获取用户的权限信息\n\n\n长Token(JWT)\n认证服务器直接颁发包含权限信息的Token，使用JWT的形式做签名加密，资源服务器可直接验证用户身份，不需要再次与认证服务器交互（除了使用非对称加密需要请求公钥）\n\n\n短Token的优缺点：\n\n字段较短，网络传输更快\n回收Token更容易，只需对数据库或Redis进行删除\n依赖于认证服务，认证服务器不可用时 其他服务将无法访问\n每次请求都需要与认证服务器交互 增加了网络通信代价\n\nJWT优缺点：\n\nToken可本地解析，获得Token后不再依赖认证服务器，具有高可用性\n本地解析速度更快，没有网络通信代价\n字段较长，会增加网络传输时间\n回收Token困难 可能造成一定程度上的安全问题\n\n○SpringSecurity构建认证服务器\nSpringSecurityOAuth2认证流程为:\nTokenEndPoint-&gt;TokenGranter-&gt;AuthenticationManager-&gt;ProviderManager-&gt;Provider\n\n\nTokenEndPoint\n其实就是一个内置的 Controller ，用于接收认证请求，内置异常处理，如果想要使用自己的异常处理，建议重写此类。\n\n\nTokenGranter\n一个验证方式管理器，根据 grant_type  选择验证方式，每个验证方式对应一个TokenGranter，但是我们需要多种验证方式，于是乎SpringSecurity内部采用了CompositeTokenGranter（可以放入多个TokenGranter，并根据grant_type选择）并包装成委托对象。如果想要自己添加新的认证方式，需要自己写该委托类并进行配置，可以参考AutoConfiguration进行编写和配置\npublic class CustomTokenGranterDelegator implements TokenGranter &#123;\n    private CompositeTokenGranter delegate;\n    private AuthenticationManager authenticationManager;\n    private OAuth2RequestFactory OAuth2RequestFactory;\n    private AuthorizationCodeServices authorizationCodeServices;\n    private AuthorizationServerTokenServices tokenServices;\n    private ClientDetailsService clientDetailsService;\n    //可以通过该属性在配置文件中添加新的TokenGranter\n    private Collection&lt;TokenGranter> additionalTokenGranters;\n\n    public CustomTokenGranterDelegator(AuthenticationManager authenticationManager, OAuth2RequestFactory OAuth2RequestFactory, AuthorizationCodeServices authorizationCodeServices, AuthorizationServerTokenServices tokenServices, ClientDetailsService clientDetailsService) &#123;\n        this.authenticationManager = authenticationManager;\n        this.OAuth2RequestFactory = OAuth2RequestFactory;\n        this.authorizationCodeServices = authorizationCodeServices;\n        this.tokenServices = tokenServices;\n        this.clientDetailsService = clientDetailsService;\n        this.additionalTokenGranters = new ArrayList&lt;>(3);\n    &#125;\n\n    @Override\n    public OAuth2AccessToken grant(String s, TokenRequest tokenRequest) &#123;\n        if (this.delegate == null) &#123;\n            this.delegate = new CompositeTokenGranter(this.getDefaultTokenGranters());\n        &#125;\n        return this.delegate.grant(s, tokenRequest);\n    &#125;\n\n    public void addTokenGranter(TokenGranter tokenGranter) &#123;\n        this.additionalTokenGranters.add(tokenGranter);\n    &#125;\n\n    private List&lt;TokenGranter> getDefaultTokenGranters() &#123;\n        ClientDetailsService clientDetails = getClientDetailsService();\n        AuthorizationServerTokenServices tokenServices = getTokenServices();\n        AuthorizationCodeServices authorizationCodeServices = getAuthorizationCodeServices();\n        OAuth2RequestFactory requestFactory = getOAuth2RequestFactory();\n        List&lt;TokenGranter> tokenGranters = new ArrayList&lt;>(this.additionalTokenGranters);\n        tokenGranters.add(new AuthorizationCodeTokenGranter(tokenServices, authorizationCodeServices, clientDetails, requestFactory));\n        tokenGranters.add(new RefreshTokenGranter(tokenServices, clientDetails, requestFactory));\n        ImplicitTokenGranter implicit = new ImplicitTokenGranter(tokenServices, clientDetails, requestFactory);\n        tokenGranters.add(implicit);\n        tokenGranters.add(new ClientCredentialsTokenGranter(tokenServices, clientDetails, requestFactory));\n        if (getAuthenticationManager() != null) &#123;\n            tokenGranters.add(new ResourceOwnerPasswordTokenGranter(getAuthenticationManager(), tokenServices, clientDetails, requestFactory));\n            //也可以直接写在这个方法内 不推荐\n            tokenGranters.add(new ResourceOwnerPhoneTokenGranter(getAuthenticationManager(), tokenServices, clientDetails, requestFactory));\n        &#125;\n\n        return tokenGranters;\n    &#125;\n    //... getter setter\n&#125;\n\n\nAuthenticationManager\n委托Provider对参数进行验证，本身用于执行验证前后的一些预处理\n\n\nProviderManager\n用于选择合适的Provider进行验证，并举行投票机制\n\n\nProvider\n对具体的参数进行验证，需要自定义时请重写此类\n\n由于内部的AbstractUserDetailsAuthenticationProvider把Token类型写死了为UsernamePasswordToken，个人认为是非常不明智的设定，简直不把拓展考虑进来，所以可以复制其代码并改为泛型类作为以后拓展的通用继承类 参考\n\n\n\n还有一些基本的组件 ClientDetailsService UserDetailsService是必备的拓展点 也很简单。\n自用配置文件参考（JWT版）\n@Configuration\n@EnableAuthorizationServer\npublic class AuthorizationConfig extends AuthorizationServerConfigurerAdapter &#123;\n    @Autowired\n    @Qualifier(\"myAuthorizationTS\")\n    private AuthorizationServerTokenServices tokenServices;\n\n    @Autowired\n    private AuthenticationManager authenticationManager;\n\n    @Autowired\n    @Qualifier(\"myUserDetailService\")\n    private UserDetailsService userDetailsService;\n\n    @Autowired\n    @Qualifier(\"myClientDetailsService\")\n    private ClientDetailsService clientDetailsService;\n\n    //授权码认证模式的拓展点 一般来说直接由内存记录就够了 不需要持久化\n    @Bean\n    public AuthorizationCodeServices authorizationCodeServices() &#123;\n        return new InMemoryAuthorizationCodeServices();\n    &#125;\n\n    @Override\n    public void configure(AuthorizationServerSecurityConfigurer security) throws Exception &#123;\n        security.checkTokenAccess(\"permitAll()\")\n                .tokenKeyAccess(\"isAuthenticated()\");\n    &#125;\n\n    @Override\n    public void configure(ClientDetailsServiceConfigurer clients) throws Exception &#123;\n        clients.withClientDetails(clientDetailsService)\n                .build();\n    &#125;\n\n    @Override\n    public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception &#123;\n        Function&lt;AuthorizationServerEndpointsConfigurer, TokenGranter> customTokenGranter = (config)-> new CustomTokenGranterDelegator(\n                authenticationManager,\n                config.getOAuth2RequestFactory(),\n                authorizationCodeServices(),\n                tokenServices,\n                clientDetailsService\n        );\n        endpoints.userDetailsService(userDetailsService)\n                .tokenGranter(customTokenGranter.apply(endpoints));\n    &#125;\n&#125;\n@Configuration\npublic class TokenConfig &#123;\n\n    @Bean\n    public JwtAccessTokenConverter jwtAccessTokenConverter() &#123;\n        JwtAccessTokenConverter converter = new JwtAccessTokenConverter();\n        converter.setSigningKey(\"test_sign\");\n        return converter;\n    &#125;\n\n    @Bean(\"myTokenStore\")\n    public TokenStore myTokenStore() &#123;\n        return new JwtTokenStore(jwtAccessTokenConverter());\n    &#125;\n\t\n    //由TokenGranter调用的服务 用于生成Token 也可以认证token\n    @Bean(\"myAuthorizationTS\")\n    public AuthorizationServerTokenServices tokenServices(ClientDetailsService clientDetailsService) &#123;\n        DefaultTokenServices tokenServices = new DefaultTokenServices();\n        tokenServices.setClientDetailsService(clientDetailsService);\n        tokenServices.setTokenStore(myTokenStore());\n        tokenServices.setTokenEnhancer(jwtAccessTokenConverter());\n        tokenServices.setSupportRefreshToken(true);\n        tokenServices.setAccessTokenValiditySeconds(60 * 60 * 2);\n        tokenServices.setRefreshTokenValiditySeconds(60 * 60 * 24 * 3);\n        return tokenServices;\n    &#125;\n&#125;\n@Configuration\n@EnableWebSecurity\npublic class WebSecurityConfig extends WebSecurityConfigurerAdapter &#123;\n\n    @Autowired\n    @Qualifier(\"myUserDetailService\")\n    private UserDetailsService userDetailsService;\n\n    @Autowired\n    private RedisTemplate&lt;Object,Object> redisTemplate;\n\n    @Autowired\n    private CacheManager cacheManager;\n\n    @Bean\n    public PasswordEncoder passwordEncoder() &#123;\n        return new BCryptPasswordEncoder();\n    &#125;\n\n    //AuthenticationManager 必须使用该方式注入\n    @Bean\n    public AuthenticationManager authenticationManagerProvider() throws Exception &#123;\n        return super.authenticationManagerBean();\n    &#125;\n\n    @Bean\n    public UserCache userCache() &#123;\n        return new SpringCacheBasedUserCache(cacheManager.getCache(\"security:user:cache\"));\n    &#125;\n\t\n    //可对Provider添加缓存器 优化性能\n    @Override\n    protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;\n        RedisPhoneAuthProvider phoneAuthProvider = new RedisPhoneAuthProvider(redisTemplate, s -> s.concat(\":security:phone:code\"));\n        phoneAuthProvider.setUserCache(userCache());\n        phoneAuthProvider.setUserDetailsService(userDetailsService);\n        auth.userDetailsService(userDetailsService)\n                .and()\n                .authenticationProvider(phoneAuthProvider);\n    &#125;\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception &#123;\n        http.csrf().disable().cors().disable()\n                .antMatcher(\"/oauth/**\")\n                .authorizeRequests()\n                .antMatchers(\"/oauth/**\").permitAll();\n    &#125;\n&#125;\n○SpringSecurity构建资源服务器\n鲁迅说过，所有的微服务都是资源服务器\n资源服务器主要功能只有从access_token中获取用户信息 配置起来简单得多\n@Configuration\n@EnableResourceServer\n//开启方法级别权限控制\n@EnableGlobalMethodSecurity(prePostEnabled = true, securedEnabled = true)\npublic class ResourceServerConfig extends ResourceServerConfigurerAdapter &#123;\n\n    @Autowired\n    private RestTemplate restTemplate;\n\n    @Autowired\n    private AccessDeniedHandler securityAccessDeniedHandler;\n\n    //配置当前资源服务器的ID\n    private static final String RESOURCE_ID = \"test\";\n\n    /**当前资源服务器的一些配置, 如资源服务器ID **/\n    @Override\n    public void configure(ResourceServerSecurityConfigurer resources) throws Exception&#123;\n        // 配置当前资源服务器的ID, 会在认证服务器验证(客户端表的resources配置了就可以访问这个服务)\n        resources.resourceId(RESOURCE_ID)\n                // 实现令牌服务, ResourceServerTokenServices实例\n                .tokenServices(defaultTokenService())\n                .accessDeniedHandler(securityAccessDeniedHandler);\n    &#125;\n\t\n\t//JWT本地认证\n    @Bean\n    public ResourceServerTokenServices defaultTokenService() throws Exception&#123;\n        DefaultTokenServices tk = new DefaultTokenServices();\n        JwtAccessTokenConverter jwtAccessTokenConverter = new JwtAccessTokenConverter();\n        //使用本地认证jwt，签名需在多个服务器上同步\n        jwtAccessTokenConverter.setSigningKey(\"test_sign\");\n        //非Spring注入方式需手动调用来配置默认的 verifier\n        jwtAccessTokenConverter.afterPropertiesSet();\n        JwtTokenStore jwtTokenStore = new JwtTokenStore(jwtAccessTokenConverter);\n        tk.setTokenEnhancer(jwtAccessTokenConverter);\n        tk.setTokenStore(jwtTokenStore);\n        return tk;\n    &#125;\n\n    //远程认证 非 JWT Token 使用\n    public ResourceServerTokenServices tokenService() &#123;\n        // 资源服务器去远程认证服务器验证 token 是否有效\n        RemoteTokenServices service = new RemoteTokenServices();\n        //负载均衡（使用自定义RestTemplate可以实现负载均衡和服务发现）\n        service.setRestTemplate(restTemplate);\n        // 请求认证服务器验证URL，注意：默认这个端点是拒绝访问的，要设置认证后可访问\n        service.setCheckTokenEndpointUrl(\"http://auth-server/oauth/check_token\");\n        // 在认证服务器配置的客户端id\n        service.setClientId(\"test_client\");\n        // 在认证服务器配置的客户端密码\n        service.setClientSecret(\"test\");\n        return service;\n    &#125;\n&#125;\n○基于OAuth2协议的SSO\n待补充\n","categories":["分布式"],"tags":["web","java"]},{"title":"分布式日志（四）服务限流、降级与熔断","url":"/2021/09/14/distribute-qbs/","content":"分布式日志第四篇，高可用的好帮手之一，服务的限流、降级与熔断\n\n微服务限流、降级与熔断\n","categories":["分布式"],"tags":["web","java"]},{"title":"特殊矩阵的二分搜索","url":"/2021/10/02/matrix-binary-search/","content":"行列上有序的矩阵采用分治法进行递归搜索 O(log2N)\n\n矩阵分治法搜索\n○思考\n前提条件：n*n 的矩阵对于每一行有序，对于每一列有序。\n**算法思想：**采用分治法 参考一维数组的二分搜索思路，根据子矩阵的最小值在左上角，最大值在右下角通过不断划分最终将定位到1*1也就是单个元素上，每次将矩阵划分为四块。\n○实现\nimport cn.hutool.core.text.StrJoiner;\nimport cn.hutool.core.util.StrUtil;\n\npublic class MatrixBinarySearch &#123;\n    public static void main(String[] args) &#123;\n        int[][] m = new int[][]&#123;\n                &#123;0, 2, 4, 6&#125;,\n                &#123;1, 5, 7, 8&#125;,\n                &#123;3, 10, 11, 21&#125;,\n                &#123;9, 13, 15, 24&#125;\n        &#125;;\n        int n = m.length;\n        boolean b = binarySearch(m, 0, 0, n, 6);\n        System.out.println(b);\n    &#125;\n\n    public static boolean binarySearch(int[][] matrix, int startRow, int startCol,  int size, int target) &#123;\n        int min = matrix[startRow][startCol];\n        int max = matrix[startRow + size - 1][startCol + size - 1];\n        //出口一 不在范围内\n        if (target &lt; min || target > max) &#123;\n            return false;\n        &#125;\n        //出口二 边界值是目标值 （少数情况）\n        if (target == min) &#123;\n            System.out.println(StrUtil.format(\"found in (&#123;&#125;,&#123;&#125;)\", startRow, startCol));\n            return true;\n        &#125; else if (target == max) &#123;\n            System.out.println(StrUtil.format(\"found in (&#123;&#125;,&#123;&#125;)\", startRow + size - 1, startCol + size -1));\n            return true;\n        &#125;\n        //出口三 递归终点\n        if (size == 1) &#123;\n            if (matrix[startRow][startCol] == target) &#123;\n                System.out.println(StrUtil.format(\"found in (&#123;&#125;,&#123;&#125;)\", startRow, startCol));\n                return true;\n            &#125; else &#123;\n                System.out.println(\"not found\");\n                return false;\n            &#125;\n        &#125;\n        int s = size / 2;\n        int centerRow = startRow + s;\n        int centerCol = startCol + s;\n        return  //递归搜索左上矩阵\n                binarySearch(matrix, startRow, startCol, s, target) ||\n                //递归搜索右上矩阵\n                binarySearch(matrix, startRow, centerCol, s, target) ||\n                //递归搜索左下矩阵\n                binarySearch(matrix, centerRow, startRow, s, target) ||\n                //递归搜索右下矩阵\n                binarySearch(matrix, centerRow, centerCol, s, target);\n    &#125;\n&#125;\n","tags":["algorithm","java"]}]