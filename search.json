[{"title":"背包问题2","url":"/2019/12/15/bagProblem2/","content":"这道题是一道动态规划(dp)算法的基础题，有两种实现方式，分别是递归和递推（迭代），前者比后者好理解。\n\n\n题目来源：LintCode\n\n有 i 个物品和一个总容量为 j 的背包. 给定数组 weight 表示每个物品的重量和数组 value 表示每个物品的价值，求最大价值。（物品不能分割）\n\n\n背包问题II\n这道题是一道动态规划(dp)算法的基础题，有两种实现方式，分别是递归和递推（迭代），前者比后者好理解。\n○解题思路\n首先，题目的要求是找出最大价值，所以我们要想，怎么存放才能让他的价值最大呢？因为物品具有重量，背包容量也有限，所以我们不能每次都放入最大价值的物品，举个例子，假设背包容量为 12，现在有三个物品对应价值和重量的关系如下表\n\n\n\n物品\n质量\n价值\n\n\n\n\nA\n10\n8\n\n\nB\n6\n5\n\n\nC\n5\n4\n\n\n\n显然我们就要选B和C,然后有人可能就会灵光一闪，那全都选择性价比（价值/质量）最大的不就行了（贪心算法），但是题目还有要求“物品不能分割”，所以实际上我们不能使用贪心算法。\n我们可以从最普通的思考方式得到一个动态规划的递推式子。我们有i个物品，考虑到重量的情况下，按照通常人类的想法就是找出各种组合，然后依次比较这些组合的价值，选最大的那个就行了，所以我们线性遍历i个物品的时候就有两种选择，“要”和“不要”，\n每个物品都经历这两个选择，最终就是产生全部的组合方式。当轮到第i个物品的时候，我们的最大价值就是这样一个式子：maxvalue = max(value[i],value[i-1]) （并考虑每次选择背包能不能装得下）,意思就是要第i个物品和不要第i个物品那个情况得到的价值最大，因为判断i个物品我们需要知道i-1个时的最大价值，所以这个式子会一直传递到背包满了或者物品都确认完了，所以可以想到用递归来解决这个过程。\n○递归算法实现\n我们需要让程序知道每个物品的信息，因此需要两个数组来储存每个物品对应的信息（也可用一个结构体数组），分别是value[],weight[]。递归程序需要有会变化的参数，物品的价值和重量时不会变的，显然会变的是物品的数量和背包的剩余容量，所以可以写一个函数bag（前i个物品，剩余背包容量j);\n\n找到递归出口\n上文提到的，背包无剩余空间或者物品算完了，即（j==0||i==0)，此时它返回的最大价值应该是0；\n递推关系\n这个关系有两种，比较容易想到的是 ``maxvalue = max(bag(i-1,j),bag(i-1,j-weight[i])+value[i]) 前一个是“不要”，后一个是“要”； 还有一种情况是 当j!=0但是当前选择的物品的重量weight[i]`比剩下空间j多了，我们就要跳过这个物品，即强制选择“不要”。\n完成这两部我们就能初步得到递归的算法啦！\n\nint bag(int i, int j)  //递归实现\n&#123;\n\tif (i == 0 || j == 0)\n\t\treturn 0;\n\tif (weight[i] &gt; j)\n\t\treturn bag(i-1,j);\n\telse &#123;\n\t\tint res = max(bag(i - 1, j), bag(i - 1, j - weight[i]) + value[i]);\n\t\treturn res;\n\t&#125;\n        //max函数可以自己判断每一种情况下的最大价值（TIPS：对于递归程序不能刻意去思考它的过程，主要理解它的方向）\n&#125;\n然而这个还不能称为DP,因为这个效率极差，我们发现它计算几百种情况，难免会出现重复的，重复的节点可能是物品为i,重量为j，所以可以建立一个用来记录的二维数组maxdata[i][j]，每个i，j都是一种情况，储存这种情况下的最大价值，这样效率就能大大提高\nint bag(int i, int j)  //递归实现\n&#123;\n    if (maxdata[i][j] != EOF)   //一开始让每个点都等于EOF（-1），如果不是-1证明这个情况已经算过了，可以直接return\n        return maxdata[i][j];\n    if (i == 0 || j == 0)\n        return 0;\n    if (weight[i] &gt; j)\n        return bag(i-1,j);\n    else &#123;\n        int res = max(bag(i - 1, j), bag(i - 1, j - weight[i]) + value[i]);\n        maxdata[i][j] = res;     //没算过就存一下\n        return res;\n    &#125;\n&#125;\n○迭代算法\n迭代算法和递归算法有一个本质的区别，递归我们是从i个物品一直找到剩下1个，而迭代算法则恰恰相反，要从一个开始找出最大价值，并逐步向上得到i个物品能得到的最大价值，而我们要记录的是前i种物品在各种重量下的最大价值。（这是比较难理解的点）\n但是具体的判断方法仍然是“要”和“不要”的问题。因为是从1个开始，所以我们每轮递推的关键点在于重量，递推式还是那个样子max(maxdata[j],max[j-weight[i]]+value[i]);但是我们是根据数组中储存的前一轮的数据进行判断的。\n然后再来分析一下这个递推式，假如现在正计算i种物品，maxdata[j]则是i-1种物品对应j重量的最大价值，如果我们“不要”第i个物品，那么最大价值还是i-1个物品对应的最大价值，如果我们“要”第i个物品，那么要对应前i-1个物品在容量扣除weight[i]时的最大价值，然后加上value[i]。这两个数值哪个大就选哪个作为这一轮的最大价值，因为判断完成后上一轮对应的数据就没有用了 所以我们新的数据就可以覆盖在对应的位置，即maxdata[j] = max(maxdata[j],maxdata[j-weight[i]]+value[i]);\n核心代码奉上\n//递推（迭代） 滚动数组\nint f[100] = &#123; 0 &#125;;    //f[j]储存前一轮各个重量下最大价值\nfor (int i = 1; i &lt;= n; i++) &#123;       //枚举种类j\n    for (int  j = totalweight; j &gt;= 0; j--)&#123;   //算前n种的各个重量下最大价值\n        int next_w = j - weight[i];      //“要”这个物品的情况下对应的下标\n        if (next_w &lt; 0) next_w = 0;   //防止下标越界\n        if (weight[i] &gt; j)data\n            f[j] = f[j];    //超重则最大价值等于前一轮对应容量下的最大价值，直接“不要”\n        else \n            f[j] = max(f[j], f[next_w] + value[i]);\n        if(i==n) break;      //最后一个物品只需要算一个totalweight的就够了\n    &#125;\n&#125;//最终得到的f[totalweight]就是n个物品用整个背包去装能得到的最大价值。\n理解这个程序，只要搞懂i = 1 到 i = 2 的过程就能理解全部了。可以随便举个例子：假设背包容量为 12\n\n\n\n编号\n物品\n质量\n价值\n\n\n\n\n1\nA\n10\n8\n\n\n2\nB\n6\n5\n\n\n3\nC\n5\n4\n\n\n\n\n从第1个A开始，我们发现容量大于等于10的时候最大价值就是8，其他的都是0，此时f[]内的数据全是零，于是大于等于10以后的式子都会是f[j] = max(0,0+8),所以就能得到新的f[]；\nf[] = &#123;0 0 0 0 0 0 0 0 0 0 8 8 8 ……&#125;\n然后在看第二个物品B,\n在总容量为12时，有f[12] = max(f[12],f[12-6]+5) f[12]从前一轮得出等于8，f[6] = 0, 所以显然在这个容量的限制下，我们会选择“不要”。\n以此类推，我们可以发现直到 5&lt;j&lt;10 我们才会选择&quot;要”，因此可以得到这一轮的f[] = &#123;0 0 0 0 0 0 6 6 6 6 8 8 8……&#125;\n如果还没理解就，继续看下第三个物品C\n跟前一轮完全相同的想法，当j=12的时候，f[12] = max(f[12],f[12-5]+4) 我们发现 f[12] = 8 &lt; f[7]+5 = 11; 所以我们选择“要”\n因为这是最后一个了所以继续往下算已经没用了，我们已经得到3个物品，12容量下的最大价值则为 11 ；\n到这里迭代算法就算讲解完了！！\n\n○迭代算法的流程图\n\n○闲话\n第一次写这种博客，感觉还挺有趣的，最重要的是还能让自己复习学过的知识，本篇内容是按自己的理解写的，可能存在逻辑错误或者漏洞，如果发现问题还请评论指教。\n动态规划的学习可以参考mooc上郭伟的《算法与程序设计》，最简单的dp问题有 数字金字塔 等。动态规划太灵活了，没有固定的模板，要根据问题具体分析\n\n完整代码参考我的GitHub\n\n","tags":["algorithm","c/c++"]},{"title":"角色与地图遮挡","url":"/2020/05/12/roleAndMap/","content":"曾经学习CocosCreater引擎时遇见的问题，现在已经放弃学习了\n\n○前言\n2d地图与角色的互相遮挡是我在短暂的学习过程中遇到的第一个难点，即使cocos creator（以下简称 cc）的TiledMap组件提供了addUserNode这个方法，但是实际效果不尽人意，经常穿模。在官方社区寻找解决办法的时候我了解到了一种比较高级的做法，大概就是动态的提取和加载地图块来形成互相遮挡，但是实现难度较大，涉及cc引擎的修改，于是乎我就自己想了这个方法。\n○实现原理\n这个方法很简单就是利用addUserNode把角色添加到地图的某一层中，但是那一层的图片本身不能让角色碰撞到，不然还是会穿模。在该层中的图片（包括添加进去的角色）都是遵循Tiledmap里面图层之间的关系的，所以可以把地图总体的分成三个部分，一个是需要被角色遮挡的部分，一个是需要遮挡角色的部分，以及角色所在的部分，这三个的顺序是固定的如图所示。\n\n○实现方法\n首先就是要把地图按照这个模式去制作，然后重点是如上图所示的npc层要在地图均匀的添加2~4个地图块（尽可能的替换其他层中不会与角色产生碰撞的地方）不然游戏中添加进去的角色无法显示在在地图上层，具体原因不明，涉及addUserNode的算法。然后如果你是使用如上图的meta层去记录障碍物信息的话  最好把角色的Anchor设为（0.5,0）以免发生如下情况：\nAnchor为（0.5,0.5）：\n\nAnchor为（0.5,0）：\n\n图片中建筑的上部分为（cover）层，下部分为（becover）层且有meta障碍物信息。\n如果使用碰撞体组件的就不会有这种情况。\n○缺点和瑕疵\n如果使用的时meta层判断障碍物的话会放生以下比较尴尬的情况：\n1.因为Anchor的x是图片中间，判断的时候是使用Anchor的坐标\n\n2.当Anchor的位置产生阻挡时角色似乎念在了墙壁上\n\n以上情况使用碰撞体组件时都不会发生，如果改进meta层判断的算法可能可以避免\n本人是初学者，如有错误和改进方法还请指出\n","tags":["cocos","tiledmap"]},{"title":"城市间紧急救援","url":"/2020/05/18/cityRescue/","content":"来自PTA的一道最短路径算法题\n\n○题目要求\n作为一个城市的应急救援队伍的负责人，你有一张特殊的全国地图。在地图上显示有多个分散的城市和一些连接城市的快速道路。每个城市的救援队数量和每一条连接两个城市的快速道路长度都标在地图上。\n当其他城市有紧急求助电话给你的时候，你的任务是带领你的救援队尽快赶往事发地，同时，一路上召集尽可能多的救援队。\n○输入格式:\n输入第一行给出4个正整数N、M、S、D，其中N（2≤N≤500）是城市的个数，顺便假设城市的编号为0 ~ (N−1)；M是快速道路的条数；S是出发地的城市编号；D是目的地的城市编号。\n第二行给出N个正整数，其中第i个数是第i个城市的救援队的数目，数字间以空格分隔。随后的M行中，每行给出一条快速道路的信息，分别是：城市1、城市2、快速道路的长度，中间用空格分开，数字均为整数且不超过500。输入保证救援可行且最优解唯一。\n○输出格式:\n第一行输出最短路径的条数和能够召集的最多的救援队数量。第二行输出从S到D的路径中经过的城市编号。数字间以空格分隔，输出结尾不能有多余空格。\n○输入样例:\n4 5 0 3\n20 30 40 10\n0 1 1\n1 3 2\n0 3 3\n0 2 2\n2 3 2\n○输出样例:\n2 60\n0 1 3\n○解题思路\n利用Dijsktra算法进行变式，因为题目要求的权值有两种，且长度优先级大于救援人数，因此自定义一个类/结构体来表示dist[]，并按照需求重载操作符。\nclass node\n&#123;\npublic:\n\tint dis;\n\tint manNum;\n\tnode(int a = INF, int b = 0):dis(a),manNum(b)&#123;&#125;\n\tbool operator &lt; (const node &amp; a) &#123;\n\t\tif (dis == a.dis)\n\t\t\treturn manNum &gt; a.manNum;\n\t\telse\n\t\t\treturn dis &lt; a.dis;\n\t&#125;\n\tbool operator &gt; (const node&amp; a) &#123;\n\t\treturn !(*this &lt; a);\n\t&#125;\n\tnode operator + (const node&amp; a) &#123;\n\t\treturn node&#123; dis + a.dis, manNum + a.manNum &#125;;\n\t&#125;\n&#125;;\n本题重点是最短路径条数，要想到如 a-&gt;b-&gt;c , a-&gt;c的条数等于a-&gt;b的条数加上b-&gt;c的条数这个递推思想，具体实现方法就是数组再每次遍历邻接点的时候进行判断。\n//entry 入口\n//pathchoice entry-&gt;每个点的最短路径条数\npathchoice[entry] = 1;\n//访问v的每一个邻接点w\nfor (int w = 0; w &lt; n; w++) &#123;\n\tif (!visted[w] &amp;&amp; mg[v][w] != INF) &#123;\n\t\tnode temp = node&#123; mg[v][w],rescue[w] &#125;;\t\t\t\t\n\t\tif (dist[w].dis == temp.dis + dist[v].dis)            //1.如果entry-&gt;w的最短距离和entry-&gt;v-&gt;w的距离相等，则entry-&gt;w的条数就要进行递推\n\t\t\tpathchoice[w] += pathchoice[v];\n\t\tif (dist[w] &gt; dist[v] + temp) &#123;\n\t\t\tdist[w] = dist[v] + temp;\n\t\t\tpath[w] = v;\n\t\t\tpathchoice[w] = max(pathchoice[w],pathchoice[v]);      //2.真正要保留的是最短路径的条数\n\t\t&#125;\t\t\t\t\n\t&#125;\n&#125;\n这里要解释一下为什么1，2两点是分开且顺序不能颠倒。因为最短路径条数不同于最优路径，最短路径不需要考虑救援人数，如果颠倒了顺序就可能会导致最短路径条数因为最优路径的关系先一步发生变化。\n然后2的地方用了一个max()，是因为即使满足1也有可能进入这个if(详见claass node中重载的运算符), 本来pathchoice[w] = pathchoice[v] 应该是第一次遍历到做的赋值，但是可能在前几次遍历中已经经过了1，\n所以应该保留最大的哪个数才是最短路径的条数。\nAC代码参考: github\n","tags":["algorithm","c/c++"]},{"title":"使用BaiduOcr识别图片文字","url":"/2021/02/14/signUpBaiduOcr/","content":"百度AI平台提供了很多AI接口，大部分都提供了免费的调用额度，如果是个人使用可以获得很大的便利，这里将介绍如何使用百度提供的文字识别接口。包含注册申请以及使用例！\n\n使用BaiduOcr识别图片文字\n百度AI平台提供了很多AI接口，大部分都提供了免费的调用额度，如果是个人使用可以获得很大的便利，这里将介绍如何使用百度提供的文字识别接口。\n○注册并申请使用权\nBaiduAI官网进入后点击右上角控制台进行登录\n○注册百度账号\n百度账号注册这里不再赘述，进入控制台登陆时即可注册。\n○实名认证\n\n\n登入控制台后会要求填写以下信息来激活账号，只需要填写*号信息栏。\n\n\n\n完成后点击左侧工具栏的文字识别，如下图所示\n\n\n\n点击立即认证，填入姓名和身份后点击下一步，无需刷脸验证，直接返回上一步的页面即可\n\n\n\n○创建文字识别应用\n\n\n回到控制台后点击 创建应用，填一些信息，不需要包名并选择所属为个人\n\n\n\n创建完成后点击 应用详情 ，进入页面后请记住API Key和Secret Key\n\n\n\n○调用API识别图片\n○获取Token\n每隔一段时间使用前都需要获取Token，一个Token的有效期为30分钟\n通过发送HTTP Get请求token：\n\n\nurl：https://aip.baidubce.com/oauth/2.0/token?grant_type=client_credentials&amp;client_id=&#123;API_Key&#125;&amp;client_secret=&#123;Secret_Key&#125;\n\n\n请求中携带参数API_key和Secret_key替换为你刚才申请的两个值，当然&#123;&#125;需要删除！\n\n\n请求成功将获得一串Json，例如\n&#123;\n  &quot;refresh_token&quot;: &quot;25.b55fe1d287227ca97aab219bb249b8ab.315360000.1798284651.282335-8574074&quot;,\n  &quot;expires_in&quot;: 2592000,\n  &quot;scope&quot;: &quot;public wise_adapt&quot;,\n  &quot;session_key&quot;: &quot;9mzdDZXu3dENdFZQurfg0Vz8slgSgvvOAUebNFzyzcpQ5EnbxbF+hfG9DQkpUVQdh4p6HbQcAiz5RmuBAja1JJGgIdJI&quot;,\n  &quot;access_token&quot;: &quot;24.6c5e1ff107f0e8bcef8c46d3424a0e78.2592000.1485516651.282335-8574074&quot;,\n  &quot;session_secret&quot;: &quot;dfac94a3489fe9fca7c3221cbf7525ff&quot;\n&#125;\n我们只需要获取access_token即可\n若返回失败则会得到包含error_description的Json信息\n\n\n○调用所需接口\n文字识别分为通用文字识别、通用文字识别（高精度），不同的接口有不同的免费额度\n通过发送HTTP POST上传图片数据或者地址进行文字识别\n\n\nurl：https://aip.baidubce.com/rest/2.0/ocr/v1/&#123;ocr_type&#125;?access_token=&#123;token&#125;\n此处ocr_type根据不同的识别方式变化，可以用“general_basic”或者“accurate_basic”替换.\ntoken是上一步获取的access_token\n\n\npost的请求体为表单类型，分为两种方式\n\n\n图片数据\n图片数据必须使用Base64编码，并用以下格式作为请求体\n\n\n\nkey\nvalue\n\n\n\n\nimage\nbase64数组\n\n\n\n\n\n图片地址\n\n\n\nkey\nvalue\n\n\n\n\nurl\nurl字符串\n\n\n\n仅general_basic支持用网络图片\n\n\n\n\n请求完成后将返回 Json 数据\n&#123;\n    &quot;log_id&quot;: 2471272194,\n    &quot;words_result_num&quot;: 2,\n    &quot;words_result&quot;: [\n        &#123;&quot;words&quot;: &quot; example&quot;&#125;,\n        &#123;&quot;words&quot;: &quot;helloworld&quot;&#125;\n    ]\n&#125;\n出错则会返回包含err_msg的 Json 数据，具体错误类型可见官方文档\n\n\n○Python使用例\n点此到Github中查看上述介绍的内容分别对应def _get_token()和def general_ocr(img_b64)\n○额外选择\n百度ocr还包含很多种类型具体请查看 官方文档，调用api时也可传入其他参数，如是否检测图片方向、图片需要识别的语言等，这里就不多介绍，入门后看官方文档就没有任何问题了。\n","tags":["web","ai"]},{"title":"Java Simple Calculator","url":"/2020/11/18/JavaSimpleCalculator/","content":"swing ui 编写、功能简单且存在一点瑕疵的计算器程序\n\n简易计算器\n○程序解释\n○原理详解\n从类的设计的角度上来讲，计算器应该是界面与操作分离，由界面程序获取操作数并传递给计算程序，从计算程序中获取结果。\n○类的设计\n\n\nCalculator\n用于计算的类，传入操作数和操作符后可获取结果，运算错误抛出异常。\n\n\nCalculator Frame\n计算器的界面类，提供操作数和操作符。\n\n\n○结构解析\nCalculator类采用两个堆栈分别存放运算数和操作符，在计算时从中抛出操作数与操作符。对小数和负数，采用标记位进行判断。\n小数：当输入了小数点“.“后，记录接下来输入数字的个数，在数字输入结束后（即输入操作符）时，将栈中的第一位数抛出并转化为小数\n负数：当输入了”neg&quot;标记后，同上，在同一时刻转化成负数\n输入数字或者操作符后，自动检查堆栈元素进行计算，因此这个简易计算器在按下“=”前，在特定情况下，会先计算部分算式；\n另一种思路：输入的任何符号都先记录起来等按下“=”时再进行读取数字和操作符进行运算\n○缺点\n因为即时运算的原因，计算器无法实现单步删除功能，只能直接清空重置计算器。代码可拓展性差，添加新的操作符运算可能需要改动部分原有逻辑。\n要不要改？卧槽，我懒啊！\n○源码展示\n○Calculator.java\npackage calculator;\n\nimport com.sun.xml.internal.ws.api.ha.StickyFeature;\n\nimport java.math.BigDecimal;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\n\npublic class Calculator &#123;\n    private final HashMap&lt;String, Integer&gt; operatorPriority;\n\n    private final LinkedList&lt;Double&gt; numberStack;\n    private final LinkedList&lt;String&gt; operatorStack;\n\n    /**\n     * 是否开始输入下一个数字\n     */\n    private boolean nextNum;\n    /**\n     * 是否已经完成了一次计算\n     */\n    private boolean calculated;\n    /**\n     * 是否输入了小数\n     */\n    private boolean decimal;\n    private int decimalDigits;\n    /**\n     * 是否输入了负数\n     */\n    private boolean negative;\n\n    public Calculator() &#123;\n        operatorPriority = new HashMap&lt;&gt;();\n        numberStack = new LinkedList&lt;&gt;();\n        operatorStack = new LinkedList&lt;&gt;();\n\n        List&lt;String&gt; level1 = Arrays.asList(&quot;+&quot;, &quot;-&quot;);\n        List&lt;String&gt; level2 = Arrays.asList(&quot;*&quot;, &quot;/&quot;, &quot;%&quot;);\n        level1.forEach(op -&gt; operatorPriority.put(op, 1));\n        level2.forEach(op -&gt; operatorPriority.put(op, 2));\n\n\n        reset();\n    &#125;\n\n    public void reset() &#123;\n        calculated = true;\n        numberStack.clear();\n        operatorStack.clear();\n        numberStack.push(0.0);\n        nextNum = true;\n        negative = false;\n        decimal = false;\n        decimalDigits = 0;\n    &#125;\n\n    /**\n     * 是否已经完成了一次计算\n     */\n    public boolean isCalculated() &#123;\n        return this.calculated;\n    &#125;\n\n    /**\n     * 获得计算结果\n     *\n     * @return 计算结果\n     * @throws ArithmeticException 如果输入不合法运算公式则抛出这个异常\n     */\n    public double getResult() throws ArithmeticException &#123;\n        tryDecimal();\n        tryNegative();\n\n        while (!numberStack.isEmpty() &amp;&amp; !operatorStack.isEmpty()) &#123;\n            double num2 = numberStack.pop();\n            double num1 = numberStack.pop();\n            String operator = operatorStack.pop();\n            numberStack.push(calculate(num1, num2, operator));\n        &#125;\n\n        calculated = true;\n\n        if (numberStack.isEmpty()) &#123;\n            return 0.0;\n        &#125; else &#123;\n            return numberStack.peek();\n        &#125;\n    &#125;\n\n    /**\n     * 输入一个操作数\n     *\n     * @param value 整数\n     */\n    public void inputNum(int value) &#123;\n        double number = value;\n        if (!nextNum) &#123;\n            number = numberStack.pop();\n            number = number * 10 + value;\n            if (decimal) decimalDigits++;\n        &#125;\n        numberStack.push(number);\n\n        //开始输入当前这个数字\n        nextNum = false;\n        //还未完成一次计算\n        calculated = false;\n    &#125;\n\n    /**\n     * 输入一个运算符号\n     *\n     * @param op 运算符号，目前仅支持“+、-、*、/“，支持小数和负数\n     * @throws ArithmeticException 如果输入不合法运算公式则抛出这个异常\n     */\n    public void inputOperator(String op) throws ArithmeticException &#123;\n        //输入运算符时意味着正在进行运算（即未完成）\n        calculated = false;\n\n        if (op.equals(&quot;.&quot;)) &#123;\n            decimal = true;\n            return;\n        &#125;\n\n        if(op.equals(&quot;neg&quot;))&#123;\n            negative = !negative;\n            return;\n        &#125;\n\n        tryDecimal();\n        tryNegative();\n\n        while (!operatorStack.isEmpty() &amp;&amp; compareOperator(op, operatorStack.peek()) &lt; 0) &#123;\n            Double num2 = numberStack.pop();\n            Double num1 = numberStack.pop();\n            String operator = operatorStack.pop();\n            numberStack.push(calculate(num1, num2, operator));\n        &#125;\n\n        operatorStack.push(op);\n\n        //输运算符后意味着开始输入下一个数字\n        nextNum = true;\n    &#125;\n\n    /**\n     * 检验是否输入了小数\n     */\n    private boolean tryDecimal() &#123;\n        //如果刚刚输入的数字（即栈顶）是小数\n        if (decimal) &#123;\n            double top = numberStack.pop();\n            top *= Math.pow(10, -1 * decimalDigits);\n            numberStack.push(top);\n\n            //下一个数字不一定是小数，重置小数参数\n            decimal = false;\n            decimalDigits = 0;\n\n            return true;\n        &#125;\n        return false;\n    &#125;\n\n    private boolean tryNegative() &#123;\n        if(negative)&#123;\n            double top = numberStack.pop();\n            numberStack.push(-top);\n\n            //重置标记\n            negative = false;\n\n            return true;\n        &#125;\n        return false;\n    &#125;\n\n    private double calculate(double num1, double num2, String op) &#123;\n        //使用string类型消除double精度误差\n        BigDecimal bigNum1 = new BigDecimal(String.valueOf(num1));\n        BigDecimal bigNum2 = new BigDecimal(String.valueOf(num2));\n        BigDecimal result;\n        switch (op) &#123;\n            case &quot;+&quot;:\n                result = bigNum1.add(bigNum2);\n                break;\n            case &quot;-&quot;:\n                result = bigNum1.subtract(bigNum2);\n                break;\n            case &quot;*&quot;:\n                result = bigNum1.multiply(bigNum2);\n                break;\n            case &quot;/&quot;:\n                result = bigNum1.divide(bigNum2, BigDecimal.ROUND_HALF_UP);\n                break;\n            default:\n                throw new ArithmeticException();\n        &#125;\n\n        return result.doubleValue();\n    &#125;\n\n    private int compareOperator(String op1, String op2) &#123;\n        int op1Level = 0, op2Level = 0;\n\n        op1Level = operatorPriority.get(op1);\n        op2Level = operatorPriority.get(op2);\n\n        return op1Level - op2Level;\n    &#125;\n\n&#125;\n○CalculatorFrame.java\npackage calculator;\n\nimport javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\n\npublic class CalculatorFrame extends JFrame &#123;\n    //region -JComponents-\n    private JPanel northPanel;\n    private JPanel centerPanel;\n    private JPanel numberPanel;\n    private JPanel operatorPanel;\n    private JPanel southPanel;\n    private JPanel westPanel;\n    private JPanel eastPanel;\n    private JTextField textArea;\n    private JButton[] numberBtn;\n    private JButton[] operatorBtn;\n    private JButton point;\n    private JButton delete;\n    private JButton neg;\n    //endregion\n\n    private Calculator calculator;\n\n    private void initComponent() &#123;\n        this.setLayout(new BorderLayout(10, 10));\n\n        centerPanel = new JPanel(new BorderLayout(10, 6));\n        numberPanel = new JPanel(new GridLayout(4, 4, 10, 10));\n        operatorPanel = new JPanel(new GridLayout(6, 1, 10, 6));\n\n        northPanel = new JPanel();\n        southPanel = new JPanel();\n        eastPanel = new JPanel();\n        westPanel = new JPanel();\n\n        textArea = new JTextField(&quot;0&quot;, 1);\n\n        numberBtn = new JButton[10];\n        operatorBtn = new JButton[5];\n        delete = new JButton(&quot;AC&quot;);\n        point = new JButton(&quot;.&quot;);\n        neg = new JButton(&quot;neg&quot;);\n\n        textArea.setEditable(false);\n        textArea.setFont(new Font(&quot;微软雅黑&quot;, Font.BOLD, 24));\n        textArea.setHorizontalAlignment(SwingConstants.TRAILING);\n\n        point.setFont(new Font(&quot;黑体&quot;, Font.BOLD, 18));\n        delete.setFont(new Font(&quot;黑体&quot;, Font.BOLD, 15));\n\n        delete.addActionListener(event -&gt; &#123;\n            textArea.setText(&quot;0&quot;);\n            calculator.reset();\n        &#125;);\n        point.addActionListener(new OperatorButtonListener(&quot;.&quot;));\n        neg.addActionListener(new OperatorButtonListener(&quot;neg&quot;));\n\n        for (int i = 0; i &lt; 10; i++) &#123;\n            numberBtn[i] = new JButton(String.valueOf(i));\n            numberBtn[i].addActionListener(new NumberButtonListener(i));\n            numberBtn[i].setFont(new Font(&quot;黑体&quot;, Font.BOLD, 18));\n            numberPanel.add(numberBtn[i]);\n        &#125;\n\n        numberPanel.add(point);\n        numberPanel.add(delete);\n\n        operatorPanel.add(neg);\n\n        String[] temp = &#123;&quot;+&quot;, &quot;-&quot;, &quot;*&quot;, &quot;/&quot;, &quot;=&quot;&#125;;\n        for (int i = 0; i &lt; operatorBtn.length; i++) &#123;\n            operatorBtn[i] = new JButton(temp[i]);\n            operatorBtn[i].setFont(new Font(&quot;黑体&quot;, Font.BOLD, 18));\n            operatorBtn[i].addActionListener(new OperatorButtonListener(temp[i]));\n            operatorPanel.add(operatorBtn[i]);\n        &#125;\n\n\n        centerPanel.add(BorderLayout.NORTH, textArea);\n        centerPanel.add(BorderLayout.CENTER, numberPanel);\n        centerPanel.add(BorderLayout.EAST, operatorPanel);\n\n        this.add(BorderLayout.NORTH, northPanel);\n        this.add(BorderLayout.CENTER, centerPanel);\n        this.add(BorderLayout.SOUTH, southPanel);\n        this.add(BorderLayout.EAST, eastPanel);\n        this.add(BorderLayout.WEST, westPanel);\n\n        this.pack();\n        this.setSize(300, 300);\n    &#125;\n\n    public CalculatorFrame() &#123;\n        initComponent();\n\n        this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n        this.setLocationRelativeTo(null);\n        this.setVisible(true);\n        this.setTitle(&quot;简易计算器&quot;);\n\n        calculator = new Calculator();\n    &#125;\n\n    private class NumberButtonListener implements ActionListener &#123;\n        private final int value;\n\n        public NumberButtonListener(int value) &#123;\n            this.value = value;\n        &#125;\n\n        @Override\n        public void actionPerformed(ActionEvent e) &#123;\n            if (calculator.isCalculated()) &#123;\n                calculator.reset();\n                textArea.setText(String.valueOf(value));\n            &#125; else &#123;\n                textArea.setText(textArea.getText() + value);\n            &#125;\n\n            calculator.inputNum(value);\n        &#125;\n    &#125;\n\n    private class OperatorButtonListener implements ActionListener &#123;\n        private final String value;\n\n        public OperatorButtonListener(String value) &#123;\n            this.value = value;\n        &#125;\n\n        @Override\n        public void actionPerformed(ActionEvent e) &#123;\n            try &#123;\n                if (value.equals(&quot;=&quot;)) &#123;\n                    textArea.setText(String.valueOf(calculator.getResult()));\n                &#125; else &#123;\n                    if (value.equals(&quot;neg&quot;) &amp;&amp; calculator.isCalculated()) &#123;\n                        textArea.setText(“neg”);\n                    &#125; else &#123;\n                        textArea.setText(textArea.getText() + value);\n                    &#125;\n                    calculator.inputOperator(value);\n                &#125;\n            &#125; catch (ArithmeticException arithmeticException) &#123;\n                calculator.reset();\n                textArea.setText(&quot;Error Input&quot;);\n            &#125;\n        &#125;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        new CalculatorFrame();\n    &#125;\n&#125;\n","tags":["java","swing"]},{"title":"关于Spring事务管理失效问题","url":"/2021/02/21/springTxError/","content":"spring事务管理与AOP中的神坑\n\n关于Spring事务管理失效问题\n○前言\n学习 Java Web学到了Spring的事务管理，在实际使用过程中发现，@Transcational与 @EnableTranscationManagement 组合使用时，出现了事务管理失效、无法回滚的问题，在网上搜索一番依然无法得到答案，后来在自己的冥思苦想下联想起Spring事务管理本质时AOP的结论时恍然大悟，于是通过逐个注释来测试其他切面的方法终于得到答案——环绕通知导致了无法进行事务回滚！\n○原因分析\n得知无法进行事务管理的原因是环绕通知时，我开始思考原因，通过查阅网上资料，得知Spring执行AOP切面遵循着一定的顺序，而这个顺序是由 Order 属性决定的！然后我就通过更改Order的方式对环绕通知的切面和事务管理切面进行测试，最终得出原因为事务切面的优先级高于环绕通知切面的优先级时，事务管理无法执行（回滚）\n○解决办法\n○快速解决办法\n解决办法由上文非常容易得知，需要通过以下方法修改Order的值，需要注意的是该值越大，优先级越低，而事务切面默认值为Integer.MAX_VALUE，默认是优先级最低的，但是同样的其他Aspect默认值也是Integral.MAX_VALAUE，具体原因本人愚昧未知。所以说以下配置可以忽略事务管理切面的优先级Order的配置，只更改其他Aspect的Order。\n○XML式配置\n在以下两个标签中添加配置order属性值\n&lt;aop:advisor order=&quot;&quot; /&gt;\n&lt;aop:around order=&quot;&quot; /&gt;\n○注解式配置\n普通切面类通过@Order 注释传入一个int值即可\n@Component\n@Aspect\n@Order(10086)\npublic class MyAspect &#123;&#125;\n事务管理切面需要在@EnableTranscationManagement中配置order参数\n@EnableTransactionManagement(order = 1008611)\n@Configuration\npublic class SpringConfiguration &#123;&#125;\n○优雅的解决办法\n如果按照以上方法配置Order难免会在项目越来越大的情况变得难以管理，因为是耦合在代码上的所以不利于管理，所以我们最优雅的解决办法是使用.properties配置文件。\n○XML配置\n这个就是引用properties罢了，没什么好讲的，学过Spring XML配置都应该知道如何引入properties文件然后通过$&#123;keyName&#125;访问。\n○注解配置\n因为注解配置使用的是Java代码，且本人暂未发现Spring框架本身对Order批量管理的支持，所以只好自己想一套简单但又良好的方法，从贴合框架啊本身的角度来讲，使用XML配置更符合🍃Spring框架的生态。\n\n\n创建properties文件，并在配置类中使用@PropertySource加载\n\n\n让你的Aspect类继承org.springframework.core.Ordered接口并按照如下来实现接口方法\n@Component\n@Aspect\npublic class MyAspect implements Ordered &#123;\n    @Value(&quot;$&#123;keyName&#125;&quot;)\n    private int order;\n\n    @Override\n    public int getOrder() &#123;\n        return this.order;\n    &#125;\n&#125;\n\n\n○关于解决方法\n注解配置的解决方法可能不够完美，但是也很好的进行解耦了，还有一些比较方便的方法但是实现难度较大，比如动态代理注解，用类名代替注解内的参数，来避免每次创建类都要用@Value注入order，然后就可以再配置文件中直接使用类名作为key配置Order了，目前动态代理注释的方法仍不清楚，所以暂时放弃这种方案。\n","tags":["web","java"]},{"title":"LinkGame","url":"/2020/12/18/LinkGame/","content":"Java课设作品，完成度较高，这里贴出设计方案！\n\n《连连看》 Java课程设计方案\n\n项目已开源，请点击：GithubHomePage\n\n○目录\n\n目录\n{:toc}\n\n○Swing界面组成\n○需求分析\n○1.核心界面\n位于窗口中央，核心界面由n*n的方块组成，同种方块成对出现，并且是乱序的。每个方块一张图片，同类方块图片相同。方块间留足间隙满足观赏性。方块点击后应有方框标记。\n○2.信息栏\n位于窗口上方，提示栏包括游戏的标题和游戏的具体信息，包括游戏剩余时间(s)，时间进度条(%)和得分情况。\n得分：根据时间、重置次数、消去方块得出。其中消去方块分最多为(n^4/2)分，在此基础上除以消耗时间/(n/4)*重置次数*(提示次数*5)*0.1。\n○3.菜单栏\n位于窗口最上方横条，菜单栏应包含游戏暂停、游戏重开、游戏退出、方块再次打乱、提示方块和“关于”界面的选项，应使用菜单和子菜单组合。游戏退出后显示欢迎界面。\n○4.关于界面\n新的对话框，由菜单栏启动，内容应包含该项目的基本信息，包括作者、时间、项目名称、源码地址等。\n○5.欢迎界面\n可切换的界面，用于打开主界面。界面中应包括游戏标题、开始按钮、关于按钮和退出按钮。开始按钮点击后应显示难度选择按钮。\n○6.结算界面\n可切换的界面，显示得分和总消耗时间。包括退出、重开按钮。退出后显示欢迎界面。\n○界面结构图\n\n○类的封装\n○GameClient\nextends JFrame\n界面程序的本体，用于联络各个组件，控制游戏开始结束。\n功能：\n\n创建菜单栏、信息栏、游戏界面、关于界面、欢迎界面、结算界面。\n订阅组件的监听器，实现各种页面的切换。页面切换使用CardLayout实现。\n开始游戏和重开游戏，设定各个组件的初始参数。\n\n○EntryPanel\nextends JPanel\n退出或者开始。记录选择的难度（地图规模、方块类数）。\n功能：\n\n提供获取所选难度的方法\n切换界面&gt;(GamePanel+MessagePanel)\n\n○OverPanel\nextends JPanel\n结算界面，显示成功或者失败信息。\n功能：\n\n\n重开游戏&gt;GameClient(reopen)\n\n\n切换界面&gt;EntryPanel\n\n\n获取从MessagePanel中获取游戏信息\n\n\n○MessagePanel\nextends JPanel\n显示信息栏界面的内容。主要用于记录分数和时间。\n功能：\n\n各种参数的getter/setter方法。\n当时间耗尽时调用自定义监听器\n\n○GamePanel\nextends JPanel\n使用Block对象填充GridLayout。根据GameMap对象提供的数据绘制Block，方块相消判定成功后绘制连线，记录数量。\n功能：\n\n为每一个Block添加MouseClicked监听器：被点击时传递自身的引用给GamePanel。\n使用GameMap判断两个坐标是否能连通后，若成功则画线并检测是否消除完全，失败则改变所选取的Block状态，并删除其引用。\n画线：\n\n直接连通：直接使用两方块坐标画线\n单拐点：两方块坐标以及一个拐点，用三个点画线段。\n双拐点：两方块坐标以及两个拐点，用四个点画线段，应注意线段总是在X或Y轴方向上。\n\n\n刷新GameMap后，遍历Blocks，重置Blocks状态\n提示两个可以相消的方块。\n当消除一次方块后调用自定义监听器。\n\n○Block\nextends JComponent\n保存方块在Map上的下标。\n功能：\n\n重置方块，包括图片、ID、状态（利用BlockFactory）\n被选取时，绘制方框\nid的getter\n\n○BlockFactory\n单例工厂类，用enum类型。\n功能：\n\n通过方块的id，生成一个带图片的Block对象。\n通过方块id，重置一个现成的Block对象。\n\n○Sound\n音效对象，实现多线程播放音效。\n○AboutDialog\nextends JDialog\n显示关于该游戏以及该项目的信息。\n○ScaleIcon\nimplements Icon\n实现图片随容器大小变化而变化\n○UMP类图\n\n○游戏逻辑构建\n游戏逻辑主要在于方块数据处理和判断两个方块是否能消去。\n○需求分析\n假设地图规模大小为n*n，方块种类为i种\n○1.记录方块分布数据\n一个二维数组，不同的ID对应不同的方块，同一个ID应成对出现。空白方块使用特殊标记。\n○2.操作方块分布数据\n重新打乱二维数组中的数据，应注意只能打乱非空白方块的数据，空白的位置应保持不变。\n判断两个方块是否能够相消，以何种方式相消。\n遍历查找两个可连通的点。\n传出和修改对应点的方块ID。\n○3.生成方块分布数据\n根据地图大小，创建一个二维数组，并在里面随机添加方块的ID。每种类型的方块添加(n*n)/i个，共(n*n)/2i组。根据需求i == n\n○核心算法\n按照连连看规则——可连接的两个方块之间最多用三条直线相连——可以分类为三种判定方式。在判定过程中应注意边界问题。\n○1.直接连通\n即两个方块间可以用一条直线连接。处在同一行或者同一列且中间没有其他方块。\n○2.单拐点连通\n即两个方块间可以用两条线段连接。以两个方块为顶点得到一个矩形，矩形的另外两个顶点中，任意一个可以空白顶点，与这两个方块都可以直接连通，则可连接。\n○3.双拐点连通\n即两个方块间可以用三条线段连接。搜索其中一个方块周围四个方向空白的点，若任意一个可以直接连通点，能与另一个方块单拐点连通，则能够连通。\n○4.寻找连通点\n○方案一\n暴力求解，不推荐\n四重循环，遍历每一个方块，起点遍历一次，终点遍历一次，判断起点和终点的连通性。\n○方案二\n广搜\n对每个方块进行广搜判断，两种判断方法\n\n方向改变不大于三次内可以找到的终点即可以连通，连通类型根据方向改变次数可以得出，拐点和方向改变次数每一次搜索都需要记录。（稍微麻烦，但速度快一点）\n对找到的终点进行连通性判断，不需要额外记录。（简单，相对慢一点，推荐）\n\n○5.数据随机\n将所有决定好的方块ID放入一个容器中进行混排，每次随机从容器中抛出一个ID设置在Map上，容器内的ID不能重复抛出。\n○判断流程图\n\n○连通示意图\n\n○类的封装\n○LinkType\n枚举类型，表示四种方块的连通方式（包括一种无法连通）。\n\nSTRAIGHT_LINK\nSINGLECORNER_LINK\nDOUBLECORNER_LINK\nNO_LINK\n\n○GameMap\n保存方块数据的类。负责判断连通，提供数据和信号给界面程序。构造时应指定地图大小和方块ID最大值。\n接口：\n\n判断是否连通的方法，并记录所有拐点，返回LinkResult。\n地图数据的getter方法，返回方块ID。\n清空指定两个点的方法。\n判断并清空两个点的方法，返回布尔类型。\n重新随机地图的方法。\n自动寻找两个可相消的点。成功返回一个LinkResult，失败抛出RuntimException（或自定义一个Exception）。\n\n○LinkResult\n自定义封装类，用于返回五个参数（初始化为null），为每个参数设置一个getter/setter。\n\nfristPoint\nsecondPoint\nfirstCorner\nsecondCorner\nlinkType\n\n○UMP类图\n\n","tags":["java","swing"]},{"title":"MyBatis","url":"/2021/03/12/myBatis/","content":"mybatis是一个优秀的持久层框架，通过配置的方式即可对数据库进行持久化操作。主要讲述原始Mybatis的用法，偏入门向\n\n🐦MyBatis\nmybatis是一个优秀的持久层框架，通过配置的方式即可对数据库进行持久化操作。\n\n推荐IDEA插件FreeMyBatisPlugin。\n\n○配置详解\nMaven坐标\n&lt;dependency&gt;\n  &lt;groupId&gt;org.mybatis&lt;/groupId&gt;\n  &lt;artifactId&gt;mybatis&lt;/artifactId&gt;\n  &lt;version&gt;x.x.x&lt;/version&gt;\n&lt;/dependency&gt;\n○XML核心配置\n○运行环境配置\n运行环境需要指定数据库连接池和事务管理类型。完成以下配置即可完成最简单的持久化操作。\n\n\n数据源环境\n&lt;environments default=&quot;id&quot;&gt;\n    &lt;environment id=&quot;&quot;&gt;\n        &lt;transactionManager type=&quot;JDBC&quot;/&gt;\n        &lt;dataSource type=&quot;POOLED&quot;&gt;\n            &lt;property name=&quot;&quot; value=&quot;$&#123;&#125;&quot;/&gt;\n        &lt;/dataSource&gt;\n    &lt;/environment&gt;\n&lt;/environments&gt;\n数据源环境可以配置多个，其中指定一个ID为默认运行环境，配置DataSource的方法与Spring配置相似，同样可以使用properties文件。\n\n\n加载映射文件\n&lt;mappers&gt;\n\t&lt;mapper resource=&quot;xml-url&quot;/&gt;\n&lt;/mappers&gt;\n\n\n○详细配置\n\n\nenvironment\ntransactionManager：事务管理器类型，分为 JDBC、MANAGED\ndataSource：连接池类型，分为UNPOOLED、POOLED、JNDI，也可以指定一个实现UnpooledDataSourceFactory的类作为type，如果要使用第三方连接池就需要这么做\nJDBC和POOLED是最常用的，其他功能不做解释。\n\n\nmapper\n加载映射器可以使用多种方式，如以下三种：\nresource：相对类路径，相当于classpath:，用于加载映射器配置文件\nclass：加载类，通过全限定类名加载，用于加载实现映射器接口的类（注解配置）\npackagename：加载包名下所有的类，同样是用于注解配置\n\n\nproperties\n加载配置文件，使用resource=&quot;path&quot;加载类下路径的文件，不需要加classpath\n\n\ntypeAliases\n定义类型别名，用于简化全限定类名，创建别名和真名的映射关系。Mybatis内部将Java基础类型与包装器类型映射起来了，所以使用int、double等名称时，对应的是包装器类名。\n\n\ntypeHanlder\n配置自定义类型转处理器，需要包裹在typeHanlders中，通过属性handler=&quot;类全限定名&quot;配置一个处理器。\n\n\n○XML映射关系配置\n○命名空间\n每个映射文件对应一个命名空间，需要在标签内指定。命名空间的作用同Java包，使用映射关系时，需要以命名空间为开头的路径。\n&lt;mapper namespace=&quot;spaceName&quot;&gt;&lt;/mapper&gt;\n○sql语句配置\nid是语句的标识符，sql语句可以直接写在标签中。\n\n\nSELECT\n&lt;!--resultType是返回结果的类型，指定一个类Mybatis能够自动封装--&gt;\n&lt;select id=&quot;&quot; resultType=&quot;&quot;&gt;sql&lt;/select&gt;\n\n\nUPDATE\n&lt;update id=&quot;&quot; parameterType=&quot;&quot;&gt;sql&lt;/update&gt;\n\n\nDELETE\n&lt;delete id=&quot;&quot; &gt;sql&lt;/delete&gt;\n\n\nINSERT\n&lt;!--后面三个属性表示返回插入的主键id并使用指定的映射关系！--&gt;\n&lt;insert id=&quot;&quot; useGeneratedKeys=true keyProperty=&quot;&quot; keyColumn=&quot;&quot;&gt;sql&lt;/insert&gt;\n\n\n○使用占位符\nmybatis中占位符用#&#123;name&#125;表示，这个占位符是安全的，与Jdbc的?一样。在符号内部可以填写多个属性，如限定这个占位符的类型等，更多属性的设置请到官方文档中查询。\n#&#123;id, javaType=int, jdbcType=NUMERIC&#125;\n用实体对象作为占位符参数\nMybatis具备将复杂对象的属性配置到占位符中的功能，其中对象的属性名需要和占位符内name的参数名保持一致，mybatis即可自动的配置到占位符中。\nsql标签使用parameterType属性可以指定该条语句所需要的参数对象类型，在缺省的情况下Mybatis能够自动推断。\n○ResultMap\n测试用例子\n结果映射，通过resultType指定的类型，能够被mybatis自动创建并设置其中的属性值，当列名和属性名匹配上时，不需要额外配置，而复杂情况下可以通过显式配置resultMap的方式完成映射，大多数情况下ResultMap在配置一对一、一对多、多对多关联查询时使用。\n\n配置一个所需的resultMap\n\n   &lt;resultMap  id=&quot;&quot; type=&quot;class&quot;&gt;\n    &lt;!--把class的属性名同列名关联起来--&gt;\n    &lt;id property=&quot;&quot; column=&quot;&quot;/&gt;\n\t&lt;result property=&quot;name&quot; column=&quot;name&quot;/&gt;\n    &lt;!--一对一关系映射--&gt;\n    &lt;assosiation property=&quot;&quot; javaType=&quot;class&quot;&gt;&lt;/assosiation&gt;\n    &lt;!--一对多/多对多关系映射--&gt;\n    &lt;collection property=&quot;&quot; ofType=&quot;class&quot;&gt;&lt;/collection&gt;\n&lt;/resultMap&gt;\n主键一般使用&lt;id&gt;标签来配置。\n\n将sql语句的resultType更换为resultMap\n\n   &lt;select resultMap=&quot;mapId&quot;&gt;sql&lt;/select&gt;\n更加复杂的高级结果映射请看官方文档包含多表关系查询需要的复杂嵌套映射\n○SelectKey\n该标签用在增删改语句中，能够完成一次子查询并封装到参数中。\n&lt;selectKey keyProperty=&quot;&quot; keyColumn=&quot;&quot; resultType=&quot;&quot; order=&quot;&quot;&gt;sql&lt;/selectKey&gt;\n\nkeyProperty、keyColumn 配置映射关系，结果将保存到keyProperty对应参数中（可以是对象中的属性）\nresultType 返回结果对应的JavaType\norder 指定为BEFORE/AFTER，意为在主查询之前还是之后进行这个子查询\n\nSelectKey需要注意order属性，像Mysql一类支持自动增长类型的数据库中，order需要设置为after才会取到正确的值\n\n⚠️如果是需要获取自增长的主键ID，推荐使用insert标签中的useGeneratorKeys模式，如果是注解方法，请使用@Options配置相同的内容。mssql中，用SelectKey且使用SCOPE_IDENTITY()来获取主键的话是无法获取的（null）但使用@@IDENTITY能够正确获取\n\n○缓存优化\n当一条语句被调用时，mybatis能够将其返回结果缓存起来，若有多次查询则可以使用缓存直接返回。\nSelect语句默认是打开缓存的，缓存开启方式如下：\n在sql语句标签中添加属性useCache=&quot;true&quot;即可开启，当使用属性flushCache=&quot;true&quot;时，调用sql会刷新缓存区，默认为false\n○注解配置\n\n\n\n常用注解\n说明\n\n\n\n\n@Insert, @Update, @Delete,   @Select\n增删改查语句，填写sql语句，参数通用#&#123;&#125;\n\n\n@Result\n映射封装结果，相当于xml中的id/result，使用column和property配置映射关系，使用@One/@Many作为参数配置复杂映射，参数id=true表明为主键\n\n\n@Results\n封装多个结果，相当于xml中的resultMap，可指定属性id，组合多个@Result标签\n\n\n@One\n实现一对一查询封装，调用其他接口，完成子查询操作，返回单一的对象\n\n\n@Many\n实现一对多、多对多查询封装，调用其他接口，完成子查询操作，返回集合对象\n\n\n@ResultMap\n给@Select提供&lt;resultMap&gt;/@Results的id，复用resultMap，参数为一个int数组\n\n\n@Options\n配置对应方法的sql属性，如flushCache、useCahce等，无法指定空值，所以一旦使用就受所有默认值的支配。\n\n\n@SelectKey\n提供在insert、update、delete时进行二次查询，并返回某些属性。参数keyProperty、keyColumn指定映射关系，statement指定sql语句，before代替order属性，使用bool决定，还有其他参数同上文\n\n\n\n\n\n一对一查询\n原理是进行两次查询，第二次查询的条件取决于第一次查询得到的外键\n@Results(&#123;\n    @Result(id=true,column=&quot;&quot;,property=&quot;&quot;),\n    // 进行一次子查询封装\n   \t@Resutl(\n        property=&quot;&quot;,javaType=class,\n        column=&quot;下一次查询使用哪一列的值&quot;\n    \tone=@One(select=&quot;接口方法全限定名&quot;)\n    )\n&#125;)\n@Select(&quot;sql&quot;)\n\n\n一对多、多对多查询\n@Result(\n    @Result(\n\t\t/*省略相同部分*/\n        many=@Many(select=&quot;&quot;)\n    )\n)\n@Select(&quot;sql&quot;)\n\n\n○动态SQL\n在配置映射关系时，Mybatis提供了一系列标签，使得sql语句能够动态的生成。根据参数不同，在同一个标签下能够生成不同语句。\n○动态标签\n动态标签是用于select等标签内部，用来动态生成sql语句的标签。\n\n\n&lt;where&gt;\n用于包裹其他动态标签，防止不使用条件判断时造成sql语法问题，当where标签内没有生成任何sql语句时，不会在原有sql上加入where字段，反之则加上where字段。（实际上是添加一个’ where 1=1 '）\n\n\n&lt;if&gt;\n&lt;if test=&quot;bool表达式&quot;&gt;\n    sql\n&lt;/if&gt;\n\n\n&lt;foreach&gt;\n&lt;foreach collection=&quot;集合类型&quot; open=&quot;开始字段&quot; close=&quot;结束字段&quot; item=&quot;name&quot; separator=&quot;分隔符&quot;&gt;\n\tsql，使用#&#123;name&#125;引用item\n&lt;/foreach&gt;\n\n\n&lt;trim&gt; 与where用法相似\n&lt;trim perfix=&quot;&quot; suffix=&quot;&quot; prefixOverrides=&quot;&quot; suffixOverrides=&quot;&quot;&gt;\n\tsql\n&lt;/trim&gt;\n\n\n\n属性\n描述\n\n\n\n\nperfix\n给sql语句拼接的前缀\n\n\nsuffix\n给sql语句拼接的后缀\n\n\nprefixOverrides\n去除sql语句前面的关键字或者字符，该关键字或者字符由prefixOverrides属性指定，假设该属性指定为&quot;AND&quot;，当sql语句的开头为&quot;AND&quot;，trim标签将会去除该&quot;AND&quot;\n\n\nsuffixOverrides\n去除sql语句后面的关键字或者字符，该关键字或者字符由suffixOverrides属性指定\n\n\n\n\n\n○片段抽取\n&lt;sql&gt;片段标签，使用这个标签可以抽取重复片段，并使用标签id作为变量代替。\n创建sql片段\n&lt;sql id=&quot;&quot;&gt;sql&lt;/sql&gt;\n引用sql片段\n&lt;include refid=&quot;sqlId&quot;/&gt;\n○注解使用动态SQL\nMybatis对注解方式的SQL也有动态功能的支持，一共有两种方法。\n\n\n方法一\n在sql字符串内使用&lt;script&gt;把sql语句包裹起来，在&lt;script&gt;内部就能够使用上面讲到的标签了，用法相同，但需要注意内部的引号”“需要使用转义字符！\n\n\n方法二\n使用@XXXProvider标签，XXX包括Select、Insert等，如：\n@SelectProvider(type=A.class, method=&quot;mySelect&quot;)\ntype指定一个类，method指定一个方法的名称，该方法的参数应与接口方法参数相同方便判空，并返回一个String对象作为为Sql字符串。所以我们需要在方法中实现Sql的动态生成！\n在这个方法中，Sql如何动态生成完全取决于我们自己，我们可以使用自己定义的逻辑来完成这个工作。但是Mybatis也为我们提供了一种选择——使用SQL对象构建sql语句。\n\n\n○SQL对象\nSQL对象是一个构建Sql的工具类，可以很方便的构造一个Sql语句，使用其提供的SELECT()、WHERER()、JOIN()等方法来拼接字符串，且无需担心语法问题。\n简单用例（来自官方文档）\n// 匿名内部类风格\npublic String deletePersonSql() &#123;\n  return new SQL() &#123;&#123;\n    DELETE_FROM(&quot;PERSON&quot;);\n    WHERE(&quot;ID = #&#123;id&#125;&quot;);\n  &#125;&#125;.toString();\n&#125;\n\n// Builder / Fluent 风格\npublic String insertPersonSql() &#123;\n  String sql = new SQL()\n    .INSERT_INTO(&quot;PERSON&quot;)\n    .VALUES(&quot;ID, FIRST_NAME&quot;, &quot;#&#123;id&#125;, #&#123;firstName&#125;&quot;)\n    .VALUES(&quot;LAST_NAME&quot;, &quot;#&#123;lastName&#125;&quot;)\n    .toString();\n  return sql;\n&#125;\n\n// 动态条件（注意参数需要使用 final 修饰，以便匿名内部类对它们进行访问）\npublic String selectPersonLike(final String id, final String firstName, final String lastName) &#123;\n  return new SQL() &#123;&#123;\n    SELECT(&quot;P.ID, P.USERNAME, P.PASSWORD, P.FIRST_NAME, P.LAST_NAME&quot;);\n    FROM(&quot;PERSON P&quot;);\n    if (id != null) &#123;\n      WHERE(&quot;P.ID like #&#123;id&#125;&quot;);\n    &#125;\n    if (firstName != null) &#123;\n      WHERE(&quot;P.FIRST_NAME like #&#123;firstName&#125;&quot;);\n    &#125;\n    if (lastName != null) &#123;\n      WHERE(&quot;P.LAST_NAME like #&#123;lastName&#125;&quot;);\n    &#125;\n    ORDER_BY(&quot;P.LAST_NAME&quot;);\n  &#125;&#125;.toString();\n&#125;\n○Plugins\n使用第三方插件或自己开发的插件对Mybatis的功能进行拓展\n○配置Plugin\n&lt;plugins&gt;\n\t&lt;plugin interceptor=&quot;类全限定名&quot;&gt;\n        &lt;property name=&quot;&quot; value=&quot;&quot;/&gt;\n    &lt;/plugin&gt;\n&lt;/plugins&gt;\n○常用插件\n\n\npageHelper\n非常好用的分页插件，简单的参数设定，简单的数据获取。\n&lt;dependency&gt;\n  &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;\n  &lt;artifactId&gt;pagehelper&lt;/artifactId&gt;\n&lt;/dependency&gt;\n\n\n○自定义插件\n实现Interceptor接口，主要实现三个方法\n\n\n核心方法，通过invocation参数能够获得映射好的sql语句，该方法的返回值是invocation对象proceed方法的返回值，与Proxy代理模式一样。\npublic Object intercept(Invocation invocation) throws Throwable &#123;&#125;\n\n\n主要用来将对象封装成代理对象，确保interceptI()能够被调用\npublic Object plugin(Object target) &#123;\n\t// 一般都是通过该方法封装\n    return Plugin.wrap(target, this);\n&#125;\n\n\n提供插件自定义属性，这个方法的属性能够在配置阶段进行注入\npublic void setProperties(Properties properties) &#123;&#125;\n\n\n○配置拦截注解\n在自定义插件类完成后，需要使用注解@Intercepts来表明该插件需要拦截的方法签名。\nMybatis只允许拦截以下类中的方法：\n\nExecutor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)\nParameterHandler (getParameterObject, setParameters)\nResultSetHandler (handleResultSets, handleOutputParameters)\nStatementHandler (prepare, parameterize, batch, update, query)\n\n@Intercepts(&#123;@Signature(\n  type= Executor.class,\n  method = &quot;update&quot;,\n  args = &#123;MappedStatement.class,Object.class&#125;)&#125;)\n\n@Singnature：表示一个构造一个方法签名\n\ntype：被拦截类名\nmethod：被拦截类中的方法名\nargs：被拦截方法的参数\n\n\n\n○JAVA-API\n使用mybatis提供的java开发包，用java对数据库进行持久化操作。\n○快速入门\n快速入门演示了mybatis-api的一个基本使用流程\n//1. 加载核心配置\nInputStream configStream = Resources.getResourcesAsStream(&quot;sqlMapConfig.xml&quot;);\n//2. 获得SqlSession工厂对象\nSqlSessionFactory factory = new SqlSessionFactoryBuilder().build(configStream);\n//3. SqlSession对象\nSqlSession session = factory.openSession();\n//4. 执行sql语句\nList&lt;Object&gt; list = session.selectList(&quot;mapping-parttern&quot;);\n// 提交事务\nsession.commit();\n//5. 释放SqlSession\nsession.close();\n○常用对象详解\n\n\nSqlSession\nmybatis主要的java接口，一切数据库操作都是由这个对象完成的。其地位类似于JdbcTemplate，在使用spring时也能通过IOC进行注入。\n主要方法有selectXxx()、update()、delete()以及事务管理的commit、rollback等\n\n\nSqlSessionFactoryBuilder\n用于创建SqlSessionFactory的对象，其中构建方法为build()，支持使用InputStream加载配置文件来创建工厂对象。\n\n\nSqlSessionFactory\n创建SqlSession对象的工厂类，用openSession()方法创建，可以使用其重载来设置SqlSession的一些属性，如是否自动提交事务以及事物的隔离级别等。\n引用官方文档的一段话\n\nSqlSessionFactory 有六个方法创建 SqlSession 实例。通常来说，当你选择其中一个方法时，你需要考虑以下几点：\n\n事务处理：你希望在 session 作用域中使用事务作用域，还是使用自动提交（auto-commit）？（对很多数据库和/或 JDBC 驱动来说，等同于关闭事务支持）\n数据库连接：你希望 MyBatis 帮你从已配置的数据源获取连接，还是使用自己提供的连接？\n语句执行：你希望 MyBatis 复用 PreparedStatement 和/或批量更新语句（包括插入语句和删除语句）吗？\n\n\n\n\n○DAO层接口代理\nMybatis能够将编写的Mapper.xml通过Java的接口进行动态代理，使得开发人员调用dao接口就能完成mapper中定义的数据库操作。使用接口代理的有以下的条件约束：\n\nmapper中namesapce属性的值需要为所需接口的全限定名。\nmapper中每个定义的sql语句id属性需要与接口中的方法名一一对应。\nsql语句的参数类型、结果类型即为接口方法的参数和返回值。\n接口的设计不能使用重载。\n\nℹ️使用IDEA插件能够根据数据库关系自动生成实体和接口\n○API\n通过SqlSession的getMapper(dao.class)获得接口的代理对象，直接使用接口即可。\n○typeHandler\n类型处理器，在Mybatis生成PreparedStatement或获取结果时会调用类型处理器来转化sql所需的参数。Mybatis默认使用了许多转换器，在使用时能够自动推断类型使用响应转换器，也能事先通过parameterType、resultType指明参数类型。\n○自定义typeHandler\n类型转换器需要实现TypeHandler接口或继承BaseTypeHandler&lt;T&gt;类，泛型为需要自定义转化的Java类。\n\n\nparameter转化逻辑\n当mybatis设置数据到数据库时调用，使用这个方法来自定义参数转化逻辑\n@Override\npublic void setNonNullParameter(PreparedStatement preparedStatement, int i, T obj, \n                                JdbcType jdbcType) &#123;\n    //直接使用preparedStatement的set方法设置参数&#x27;obj&#x27;，参数的index为&#x27;i&#x27;\n&#125;\n\n\nresult转化逻辑\n从数据库取出数据时调用的转化方法\n//从三类不同的结果集取出给定的数据并转化成Java数据，第二个参数即为结果集中所需参数的位置\n@Override\npublic T getNullableResult(ResultSet resultSet, String s) &#123;&#125;\n\n@Override\npublic T getNullableResult(ResultSet resultSet, int i) &#123;&#125;\n\n@Override\npublic T getNullableResult(CallableStatement callableStatement, int i) &#123;&#125;\n\n","tags":["web","java"]},{"title":"Java Web","url":"/2021/03/12/javaweb/","content":"从零开始学JAVA web，我学了些什么，这篇文章将会记录这一段学习历程。(暂告一段落)\n\nJavaWeb-Spring\n\nGitHub：Spring学习过程中创建的项目，包含一些例子\n\n○一​、🚶JavaSE\n\n[x] Java语言基础内容，已经掌握\n\n○二、🐴JSP/Servlet\n主要以理解Tomcat中Servlet的运行原理为重点\n○JSP\nJsp本质是servlet，约等于分不清前后端，耦合性太强，已经被时代抛弃，大概了解即可，直接跳过学习。\n○JSTL\nJavaServer Pages Tag Library ：JSP标准标签库\n用于简化和替换jsp页面上的java 代码\n○Servlet\n\n\nServlet:\n注解声明@WebServlet(&quot;path&quot;)\ntomcat服务器的核心，主要是理解Http协议、HttpServletRequest以及HttpServletResponse原理。req可以进行转发forward（服务器内servlet间转发），resp可以进行重定向redirect(由浏览器发送第二次请求，可跨服务器)\n\n\nFilter：\n注解声明@WebFilter(&quot;path&quot;)\n过滤器，拦截request和response，可以对req和resp进行判断是否放行。\n\n\nListener：\n注解声明@WebListener\n监听器，ServletContextListener监听ServletContext对象的创建（服务器启动）和销毁（服务器关闭），该接口主要用于加载资源和释放资源等操作。除此之外还有其他监听器。\n\n\nServletContext：\n服务器内的一个全局上下文，可以从servlet或req中获取（单例类）。作用是获取服务器真实路径getRealPath()、设置和获取服务器内共享的数据域set/getAttribute()和获取Content-typegetMimeType(filename)，通过配置&lt;context-param&gt;可以用getInitParam()来加载资源文件\n\n\nCookie：保存于浏览器的数据，用来识别身份，保存sessionid等。可以设置存活周期。\n\n\nSession：保存于服务器的数据，用来记录每个浏览器特定的信息，由一个id对应。可以设置存活周期，服务器关闭后会钝化，再次开启后活化\n\n\n○EL表达式\n语法：$&#123;expression&#125;\n\n\n运算\n算数运算、比较运算、逻辑运算、判空运算empty\n\n\n获取值\n从域对象中获取值$&#123;域名称.keyName&#125;、$&#123;keyName&#125;\n\n\n\n域名称\n说明\n\n\n\n\npageScope\n从pageContext获取\n\n\nrequestScope\n从request中获取\n\n\nsessionScope\n从session中获取\n\n\napplicationScope\n从ServletContext获取\n\n\n\n\n\n○ExtraDetail\n这里记录在学习这个模块的过程中额外学习到的内容。\n○ProxyMode\n代理模式，软件设计模式的一种，通过中间代理执行方法，来达到增强的目的。后续框架中经常使用该模式。\n动态代理在Java中使用\nclass Proxy&#123;\n    public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfacies, InvocationHandler h)&#123;&#125;\n&#125;\n其中InvocationHandler是抽象类，需实现\n@Override\npublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;&#125;\n通过在该方法中调用method.invoke(obj,args)来执行被代理的对象的方法。可以修改返回值或者参数等手段来增强该方法，也可以在方法调用前和调用后增加其他类的方法。\n○MVC开发模式\n\n\nM: Model 模型 JavaBean\n完成业务逻辑操作，如查询数据库、封装数据\n\n\nV: View 视图 jsp\n展示数据\n\n\nC: Controller 控制器 servlet\n分发工作，获取客户端的输入然后调用模型，将数据交给视图。\n\n\n○三层架构\n\n\n界面层（表示层 web）SpringMVC\n用户能够通过界面的组件和服务器进行交互，调用Service完成请求处理，转发jsp页面完成显示。\n\n控制器：servlet，接受用户请求并封装参数信息到Servic层\n视图：JSP，接受控制器提供的数据并展示出来给用户\n\n\n\n业务逻辑层 (service) Spring\n处理业务逻辑，组合DAO层的简单方法，组成各种复杂的业务功能。\n\n\n数据访问层 (dao) MyBatis\n操作数据存储文件，定义了对数据库最基本的CRUD操作\n\n\n○Bootstrap/JQuery/AJAX\n皆为前端框架\n\n\nBoostrap\n提供丰富的html标签和css样式，具有响应式布局，配合JQuery/Vue使用。\n\n\nJQuery\n对js的封装，提供了选择器等许多丰富API来帮助编写js动态生成页面。\n\n\nAJAX\n异步的JavaScript和XML，用于向服务器发送异步请求，可以在JQuery/Vue中便捷使用。\n\n\n○三​、🚲JDBC/SQL\n两者是数据库的重要内容，SQL有MySQL、SQLserver等，JDBC则是Java操作数据库SQL的重要API，都应熟练掌握并理解原理。\n○MySQL\n学会数据库增删查改等操作，熟练运用操控数据库的高级技巧，重点理解数据库原理，学会优化数据库。\n○事务\n○基本介绍\n事务指的是一个包含多个步骤的业务操作，如果这个操作被事务管理，则要么同时成功，要么同时失败。事务可以提供回滚操作，撤销出错的影响。\n\nＳＴＡＲＴ　ＴＲＡＮＳＡＣＴＩＯＮ　开启事务管理\nＲＯＬＬＢＡＣＫ　回滚\nＣＯＭＭＩＴ　提交事务\n\nSELECT @@autocommit 查看是否为自动提交，修改后可以改变默认管理方式\n○四大特征\n\n原子性：数据库操作中不可分割的最小单位，要么同时成功，要么同时失败\n持久性：事务提交或回滚后，数据会持久化保存在数据库中\n隔离性：多个事务之间相互独立\n一致性：事务操作前后，数据总量不变\n\n○隔离级别\n多个事务操作同一批数据会引发一些问题，通过设置隔离级别可以解决这些问题。\n\n脏读：一个事务，读取到另一个事务中没有提交的数据。\n不可重复读：同一个事务中，两次读取到的数据不一样（可能被另一个事务修改了）MySql-MVCC原理\n幻读：一个事务(同一个read view)在前后两次查询同一范围的时候，后一次查询看到了前一次查询没有看到的行。\n\n\n\n\n级别\n说明\n安全性\n\n\n\n\nread uncommitted\n读未提交，允许读取未提交的数据\n0\n\n\nread committed\n当前读、读已提交，只有已经提交的数据才能被读取\n1\n\n\nrepeatable read\n可重复读，使一个事务周期内的数据不受其他事务影响\n2\n\n\nserializable\n串行化，锁定一张表，相当于单线程执行事务\n3\n\n\n\n从小到大安全性越来越高，效率越来越低！不同的数据库隔离级别原理不同，如MySql的MMVC，因此能解决的问题也不同\n通过SELECT @@tx_isolation查询隔离级别，SET GLOBAL TRANSACTION ISOLATION LEVEL 级别名设置隔离级别\n○JDBC\nJDBC是Java用来操作数据库的接口，具体实现由不同数据库公司实现，他的实现类被称为**“驱动”（Driver）**。\n常见驱动类：\n\nMySql：“com.mysql.jdbc.Driver”\nSqlServer：“com.microsoft.sqlserver.jdbc.SQLServerDriver”\n\n○使用方法\n\n\n注册驱动\n/*\n 通过该方法把类加载到内存\n 驱动类来自每个不同的数据库公司，以下是mysql的驱动类\n 该方法执行时，类的静态代码块会被执行，Driver会使用registerDriver方法注册DriverManager\n mysql5以上的版本可以省略这个注册过程\n*/\nClass.forName(&quot;com.mysql.jdbc.Driver&quot;);\n\n\n获取数据库连接对象\nimport java.sql.*;\n/*\n url: 数据库地址 jdbc:mysql://域名:端口/dbName\n user: 管理员用户名\n pwd: 管理员密码\n*/\nConnection conn = DriverManager.getConnection(url,user,pwd);\n\n\n定义sql语句String\n\n\n获取执行sql对象\nimport java.sql.*;\n//satement 可以执行sql语句\nStatement stat = conn.createStatement();\n\n\n执行sql获取返回结果\n//sqlStr 为数据库执行语句，如DML(insert、update、delete)、DDL(create、alter、drop)\n//返回影响的行数：可以通过这个值判断DML语句是否执行成功\nstat.excuteUpdate(sqlStr);\n\n\n释放资源\n//执行对象释放\nstat.close();\n//数据库连接释放\nconn.close();\n//结果对象释放\nresultSet.close();\n\n\n○常用对象详解\nConnection：\n\n\n获取sql对象\ncreateStatement()、preparedStatement(sqlStr)\n\n\n管理事务\n关闭自动提交事务的功能即可开启手动事务管理\n开启：setAutoCommit(false)、提交：commit()、回滚：rollback()\n\n\nStatement：\n\nexcuteUpdate(sql)：执行DML(insert、update、delete)、DDL(create、alter、drop)，返回影响的行数\nexecuteQuery(sql)：执行DQL(select)语句，返回ResultSet\n\nResultSet：\n\n\nnext()：移动游标到下一行，游标初始于第0行（表头），如果下一行没有数据则返回false\n\n\ngetXxx(int/str)\n获取当前行的数据，Xxx为数据类型名，返回类型为Xxx\n方法指定参数为int时，表示columIndex获取第几列的数据\n方法指定参数为str时，表示columName获取名为str的列的数据\n\n\nPreparedStatement：\n\n\n解决SQL注入问题\n某些sql特殊关键字参与字符串拼接会造成安全性问题，如WHERE后存在恒等式则表示没有约束作用\n\n\n预编译sql\nsql语句的参数使用？占位符，使用setXxx(pos, value)方法赋值，该方法传入占位符的位置（第几个）和值来进行sql参数补充，value类型为Xxx\n\n\nexcuteUpdate()\n\n\nexecuteQuery()\n\n\n○事务管理\n事务指的是一个包含多个步骤的业务操作，如果这个操作被事务管理，则要么同时成功，要么同时失败。\n\n开启 提交 回滚 使用Connection管理\n\n○使用方法\ntry &#123;\n    conn.setAutoCommit(false); //open\n    // TODO: do sql\n    conn.commit(); //commit if no exception occur\n&#125; catch (Exception e)&#123;\n    conn.rollback(); //rollback if has any exception \n&#125;\n当rollback()执行时，刚刚执行的sql操作都会撤销。\n○数据库连接池\n优化Connection操作，提高数据库访问性能\n○原理\n使用连接对象容器管理Connection，从容器中获取，归还到容器中去，由容器管理是否断开连接。\n○实现方法\n*Interface DataSource：*由Driver实现，Druid性能较高\n\n\nC3P0：ComboPooledDataSource\n使用classpath:c3p0.properties/c3p0-config.xml配置参数\n\n\nDruid：DruidDataSourceFactory\n使用druid.properties配置参数，需要手动加载。通常封装成工具类静态加载配置文件。\n\n\n○Spring JdbcTemplete\n由Spring封装的JDBCUtils，简化操作。详细见下文\n○Junit4\nJunit单元测试属于白盒测试的一种。\n○注解\n\n\n\n注解\n说明\n\n\n\n\n@Before\n在所有测试方法前执行\n\n\n@After\n在所有测试方法后执行，无论是否存在异常\n\n\n@Test\n标注方法为测试方法\n\n\n\n○测试方法\n所有测试方法都是无参的，测试方法内最好不要直接输出数值，应该尽量使用assert断言结果于预期是否相符合。对于测试期间出现的异常应该尽量捕获并写入文件中，标明异常方法和异常原因。\n○Redis/Jedis\n非关系型数据库，有缓存功能。。。\n○四、🚗SSM\nJavaWeb框架集合之一，由Spring+SpringMVC+Mybatis组成，适用于轻量级微服务开发，要深入理解原理。\n○Spring\nSpring框架属于Service层框架，但是也管理了Web层和DAO层\n○IOC\n○ioc容器\nBean容器，spring在内部创建Java类，我们或Spring可以从容器中取出Bean\n○XML式依赖注入\n对&lt;bean id=&quot;&quot; class=&quot;&quot;&gt;&lt;/bean&gt;对象的属性进行配置\n分别为：对象注入ref、普通数据类型注入value、集合类型\n\n\n集合类型：配置文件使用&lt;list&gt;&lt;value&gt;、&lt;map&gt;&lt;entry key=&quot;&quot; value-ref=&quot;&quot;&gt;、&lt;props&gt;&lt;prop key=&quot;&quot;&gt;组合使用\n\n\n构造方法：有参构造，配置文件中使用&lt;constructor-arg name=&quot;&quot; ref=&quot;&quot;/&gt;注入\n\n\nset方法：配置文件中使用&lt;property name=&quot;&quot; ref=&quot;&quot;/&gt;子标签标签设置属性值注入\n\n\n模块开发\n&lt;import resource=&quot;applicationContext-xxx.xml&quot; /&gt;\n○注解式依赖注入\n\n\n原始注解\n使用前须在配置文件中配置组件扫描，指定需要注解开发的包\n&lt;context:component-scan base-package=&quot;&quot;&gt;\n    &lt;!--用于排除不需要被扫描的类--&gt;\n\t&lt;context:exclude-filter type=&quot;&quot; expression=&quot;&quot; /&gt;\n&lt;/context:component-scan&gt;\n\n\n\n注解\n说明\n\n\n\n\n@Component\n类上实例化Bean，代替Bean标签\n\n\n@Controller\nweb层类上实例化Bean\n\n\n@Respository\ndao层上实例化Bean\n\n\n@Service\nservice层上实例化Bean\n\n\n@Autowired\n依赖注入标签，加在成员变量/setter/构造方法\n\n\n@Qualifier\n结合Autowired一起使用根据名称进行依赖注入\n\n\n@Resource\n相当于前两者的结合，是javaEE的注解，不是Spring的注解\n\n\n@Value\n注入普通属性（int等）\n\n\n@PostConstruct\n声明Bean的初始化方法\n\n\n@PreDestroy\n声明Bean的销毁方法\n\n\n@Scope\n标志Bean的范围，singleton/prototype\n\n\n\n\n\n新注解\n可以完全替代xml配置文件\n\n\n\n注解\n说明\n\n\n\n\n@Configuration\n指定类为配置类，创建容器时从该类上加载注解\n\n\n@ComponentScan\n指定要扫描的包，同&lt;context:componnet-scan&gt;，使用excludeFilters排除不需要被扫描的类\n\n\n@Bean\n标注方法的返回值储存于容器中\n\n\n@PropertySource\n用于加载.properties文件的配置\n\n\n@Import\n用于导入其他配置类\n\n\n\n\n\n○AOP\n○概念\n面向切面编程，是动态代理的规范化编程，动态代理如何增强方法见上文。SpringAOP底层使用的动态代理为以下两种：\n\n\nJava原生接口代理\n通过接口反射出代理对象，使用的是 ProxyMode\n\n\ncglib子类代理\n外部的工具库，已经集成在springframework-core中，使用的是Enhancer类。通过指定父类反射出代理对象。\n\n\n根据目标对象[1]是否有接口来选择其中一个方法。\n○XML配置动态代理\nmaven导入依赖aspectjweaver、spring-aop\n\n\n配置目标对象和切面对象Bean\n切面类和目标类都需要配置为Bean才能被Spring从IOC容器中取出来\n\n\n配置织入（前置、后置……）\n使用命名空间xmlns:aop\n&lt;aop:config&gt;\n \t&lt;!--声明切面类--&gt;   \n\t&lt;aop:aspect ref=&quot;beanName&quot;&gt;\n    \t&lt;!--配置切面：切点+通知--&gt;\n        &lt;!--类似的还有aop:after等等--&gt;\n        &lt;aop:before method=&quot;adviceName&quot; pointcut=&quot;execution(&#x27;方法声明&#x27;)&quot; /&gt;\n    &lt;/aop:aspect&gt;\n&lt;/aop:config&gt;\n切面标签\n\n\n\n名称\n标签\n说明\n\n\n\n\n前置通知\naop:before\n略\n\n\n后置通知\naop:after-returning\n略\n\n\n环绕通知\naop:around\n前后都执行，比前置更前，比后置更后\n\n\n异常抛出通知\naop:throwing\n出现异常时执行\n\n\n最终通知\naop:after\n最后执行，无论是否抛出异常\n\n\n\nℹ️环绕通知方法需要携带参数ProceedingJoinPoint表示连接点[2]对象，要在方法中执行该对象的proceed()方法并return该方法的返回值。\n⚠️环绕通知方法的返回值都为Object，表示被增强的方法会返回一个对象或者NULL，因此需要注意被增强的方法不能返回boolean、int等基础类型，需要用对应的包装类替换！\n\n\n切点表达式\nexecution([修饰符] 返回值 包名.类名.方法(参数))\n\n\n修饰符可以省略（public、private……）\n\n\n可以用通配符（*）代表任意\n\n\n参数可以用..表示任意个数，任意类型的参数列表（可变参数）\n\n\nex:\nexecution(* cn.test.*.*(..)) //cn.test包下任意类的任意方法\n**表达式抽取：**替换point-cut为point-cut-ref，引用&lt;aop:pointcut id=&quot;&quot; expression=&quot;&quot;/&gt;标签设定好的表达式id\n\n\n○注解配置动态代理\n在配置文件中添加&lt;aop:aspect-autoproxy /&gt;自动代理aop\n或者在配置类上用@EnableAspectJAutoProxy标注\n\n\n\n注解\n说明\n\n\n\n\n@Aspect\n标注为切面类\n\n\n@Before\n标志为前置通知，参数为execution表达式\n\n\n@AfterReturning\n标志为后置通知，参数为execution表达式\n\n\n@Around\n标志为环绕通知，参数为execution表达式\n\n\n@AfterThrowing\n标志为异常抛出通知，参数为execution表达式\n\n\n@After\n标志为最终通知，参数为execution表达式\n\n\n\n**切点[3]表达式抽取：**在切面类中定义空实现方法，在方法上用@PointCut（’表达式‘）标注，引用时按照className.methodName()来描述\npublic class Aspect &#123;\n    @PointCut(&quot;excution(*.cn.shijh.*.*(..))&quot;)\n    public void myPointCut()&#123;&#125;\n\n    @Before(Aspect.myPointCut())\n    public void beforeEnhance()    \n&#125;\n\n○Spring事务控制\n底层基于AOP实现事务管理，一般在Service层进行。\n切点：Service方法\n通知：事务管理\n\n⚠️ ⚠️ ⚠️ 关于这个问题的详细说明\nSpring事务管理与AOP之间存在神坑，被环绕通知的方法是无法进行事务控制的！！！！坑了我两三个小时！原因是事务管理本身就是环绕通知！！解决办法：设定Aspect和advisor的Order，且事务控制的Order要比环绕通知的大，否则无法完成事务回滚\n\n○编程式控制\n\nPlatfromTransactionManager\n\nspring事务管理器的接口，依据不同Dao层技术使用不同的实现类。\n\nDataSourceTransactionManager\n\n Jdbc or MyBatis 对应的实现类。\n\n\nTransacitonDefinition\n\n事务的定义对象，封装事务的隔离级别、传播行为、超时时间等属性。\n\n\n隔离级别\nISOLATION_DEFAULT：数据库默认级别\nISOLATION_READ_UNCOMMITTED\nISOLATION_READ_COMMITTED\nISOLATION_REPEATABLE_READ\nISOLATION_SERIALIZABLE\n\n\n传播行为\nREQUIRED：默认值，防止嵌套的两个事务发生，后一个事务会加入到前一个事务中。\nSUPPORTS：后一个事务将不会开启\nMANDATORY：强制加进入前一个事务中，没有前一个事务就报错\n\n\n\n\nTransactionStatus\n事务的运行状态对象。是否完成、是否回滚等状态。\n\n\n○XML声明式控制\n&lt;!--配置事务管理的增强方法--&gt;\n&lt;tx:advice id=&quot;&quot; transaction-manager=&quot;&quot;&gt;\n\t&lt;tx:attributes&gt;\n        &lt;!--name可以使用通配符‘*’和字符串组合使用\n\t\t\t如‘update*’表示以update开头的所有方法名--&gt;\n    \t&lt;tx:method name=&quot;methodName&quot; isolation=&quot;&quot; propogation=&quot;&quot;/&gt;\n    &lt;/tx:attributes&gt;\n&lt;/tx:advice&gt;\n&lt;!--transactionManager需要注入到IOC容器中--&gt;\n&lt;!--配置增强方法的织入，使用aop--&gt;\n&lt;aop:config&gt;\n    &lt;!--事务管理增强专用标签--&gt;\n\t&lt;aop:advisor advice-ref=&quot;tx:advice&quot; pointcut=&quot;execution&quot;/&gt;\t\n&lt;/aop:config&gt;\n\n\n\n标签\n说明\n\n\n\n\ntx:advice\n配置事务管理的通知，需指定transactionManager\n\n\ntx:attributes\n配置事务的属性，具体由多个tx:method配置\n\n\ntx:method\n指定一个方法名，配置一个业务方法的属性，包括隔离级别等\n\n\naop:advisor\n用于事务管理的aop增强方法，引用配置好的tx:advice作为通知\n\n\n\n配置事务属性时，只需指定方法名，不需要指定包名类名等，具体位置在织入时配置\n○注解声明式控制\n\n\n\n注解\n说明\n\n\n\n\n@EnableTransactionManagement\n在配置类中标注，表示开启spring事务管理\n\n\n@Transactional\n在方法或者类上标注，表示类下的方法都会被spring事务进行管理，可以加参数来配置事务的属性\n\n\n\n使用注解配置时，driver会由spring自动配置，只需要将transactionManager放到IOC容器中\n○Spring-Junit\n通过注解集成Junit\n\n\n\n注解\n说明\n\n\n\n\n@RunWith\n指定使用Spring内置的测试类\n\n\n@ContextConfiguration\n指定Spring配置文件、配置类\n\n\n@AutoWired\n从IOC容器中注入测试对象\n\n\n\n○Spring-JdbcTemplate\n对JDBC API的封装，使调用更加简单\nmaven需要导入依赖spring-jdbc和spring-tx\n常用方法\n\n\nsetDataSource()：设置连接池对象\n\n\nupdate()、query()：执行sql语句\n\n\nRowMapper&lt;T&gt;可以自动完成数据封装的接口，是query()的方法参数，对应实现类有 BeanPropertyRowMapper&lt;T&gt;，需要构造参数：\nnew BeanPropertyRowMapper&lt;JavaBean&gt;(JavaBean.class)\nquery()将返回List&lt;T&gt;类型的集合\n\n\nqueryForObject()同query()一样，但是只返回一个对象\n\n\n查询简单对象只需要传入Class&lt;T&gt;\n\n\n可以使用IOC容器来创建jdbcTemplate、dataSource对象，完成参数的注入。\n○Spring-web\n用于集成web环境的maven依赖spring-web，提供获取应用上下文（ApplicationContext）的工具类和监听器。获取的原理是在服务器启动时创建上下文并放入ServletContext域中，即可在服务器共享。方便在 Servlet中获取应用上下文，且可以避免多次创建带来的性能开销。\n\n\nweb.xml中配置监听器ContextLoaderListener\n\n\n配置&lt;context-param&gt;指定applicationContext.xml/.class的路径\n&lt;context-param&gt;\n\t&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;\n    &lt;param-value&gt;xx.xx.xx.ClassName&lt;/param-value&gt;\n&lt;/context-param&gt;\n&lt;!--如果使用类配置则一定要指定下面的参数--&gt;\n&lt;context-param&gt;\n\t&lt;param-name&gt;contextClass&lt;/param-name&gt;\n    &lt;param-value&gt;org.springframework.web.context.support.AnnotationConfigWebApplicationContext&lt;/param-value&gt;\n&lt;/context-param&gt;\n\n\n使用WebApplicationContextUtils获取上下文\n\n\n○SpringMVC\nSpring+SpringMvc Demo\n属于web层框架，提供轻量级的MVC开发 ，核心是用servlet实现的前端控制器。该控制器执行servlet的共有行为，并调用特有行为servlet，称为 Controller\n○组件解析\n○原理图解\n\n○组件详解\n\n\nHandlerMapping\n\n\nHandlerAdaptor\n执行对应的Controller，并把Controller的返回值包装成ModelAndView对象。\n\n\nModelAndView\n\nsetViewName()设置页面跳转的页面名称\naddObject()设置request域中的参数\nnew ModelAndView(JsonView, ModelMap)用一个Map和JsonView对象创建Json数据视图\n\n\n\nViewResolver\n参考地址\n视图解析器，SpringMvc内部有很多解析器，默认使用的 InternalResourceViewResolver。主要作用是把一个ModelAndView解析为一个真正的视图。\n其中一种视图解析使用了一种拼接url的方式，内部规定了前缀(prefix)、后缀(suffix)，与视图的名称，如&quot;index&quot;，拼接后就得到视图URL了。url方式可以在ViewName中加上前缀指定，有&quot;redirect:“和&quot;forward:”，表示重定向和转发。视图解析器会把这些包装成View对象返回前端控制器。\n\n\nView\n由解析器产生的对象，分为URL(jsp, jstl)、文档(excel, pdf)、报表、JSON。\n\n\n○XML配置\n\n\n在web.xml中配置前端控制器DispatcherServlet\n&lt;servlet&gt;\n    &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt;\n    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;\n    &lt;!--设定SpringMVC配置文件的地址 使用类配置时要指定contextClass类型，同spring-web--&gt;\n    &lt;init-param&gt;\n        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;\n        &lt;param-value&gt;配置文件地址&lt;/param-value&gt;\n    &lt;/init-param&gt;\n    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;\n&lt;/servlet&gt;\n\n&lt;servlet-mapping&gt;\n    &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt;\n    &lt;url-pattern&gt;/&lt;/url-pattern&gt;\n&lt;/servlet-mapping&gt;\n\n\n使用独立的spring-mvc.xml配置SpringMVC的各种属性\n\n\n配置组件，ViewResolver、HandleAdapter等\n用&lt;bean&gt;标签配置，同Spring一样\n\n\n\n\n&lt;mvc:annotation-driven&gt; 自动配置一些组件的属性\n\n\n○注解配置\nSpring新注解也通用于SpringMVC\n\n\n\n注解\n说明\n参数\n\n\n\n\n@EnableWebMvc\n启用mvc注解驱动\n无\n\n\n@RequestMapping\n请求映射地址，用于类或方法中\nvalue：路径；method：请求方式；params：限定请求参数\n\n\n@GetMapping\nRequest的细分\nvalue：路径\n\n\n@PostMapping\n同上\n同上\n\n\n@ResponseBody\n标注返回值到content中\n无\n\n\n@RequestParam\n取request的参数\nvalue：所需参数的名称; require：强制要求？;defaultValue：默认值\n\n\n@RequestBody\n标注方法参数上，注入JSON请求参数\n无\n\n\n@PathVariable\n标注方法参数上，用于restful风格的参数\nvalue；require；defaultValue; 同RequestParam\n\n\n@RequstHeader\n获取请求头数据\nvalue; require;\n\n\n\nWebMvcConfigurer\nMvc配置类需要实现的接口，用于配置更多SpringMvc的属性，如资源解析、拦截器等。\n○注解配置web.xml\n配置web.xml的类需要实现接口AbstractAnnotationConfigDispatcherServletInitializer，并实现其中方法，Spring会自动查找该实现类来代替web.xml\n/**\n * 指定 ContextLoaderListener 所需的配置类\n */\n@Override\nprotected Class&lt;?&gt;[] getRootConfigClasses() &#123;&#125;\n\n/**\n * 指定mvc的核心配置类\n */\n@Override\nprotected Class&lt;?&gt;[] getServletConfigClasses() &#123;&#125;\n\n/**\n * 等同于设置 DispatcherServlet 的 url-pattern\n */\n@Override\nprotected String[] getServletMappings() &#123;&#125;\n\n/**\n * 配置过滤器\n */\n@Override\nprotected Filter[] getServletFilters() &#123;\n    return new Filter[]&#123;\n        new CharacterEncodingFilter(&quot;UTF-8&quot;),\n    &#125;;\n&#125;\n○数据响应\n服务的的数据响应分为页面跳转和回写数据。\n○页面跳转\n\n\n直接返回字符串，如页面的名称&quot;index&quot;，默认为转发\n\n\n返回ModelAndView对象\n通过setViewName()指定页面名称，addObject()保存数据供JSP调用\nModelAndView对象可以放在形参中，Spring会自动注入一个空的对象。\n\n\n○回写数据\n\n\nModelAndView\nJson数据内容由LinkedHashMap转化而来，Json转化驱动可以是jackjson、fastjson，需要添加maven依赖。\nreturn new ModelAndView(new FastJsonJsonView(), map);\n\n\n字符串\n方法上标注@ResponseBody表示返回值直接写入response的content。Json也可以作为字符串直接返回，使用json驱动转化。\n\n\n对象或集合\n通过配置消息转换器，可以直接返回集合或者对象自动转化成Json字符串，同时要在方法上标注@ResponseBody。\n\n\nXML\n配置RequestMappingHandlerAdapterbean标签，把Json转化驱动注入messageConverters中。\n\n\n注解、类配置\n在Mvc配置类中继承WebMvcConfigurer接口，实现以下方法\n@Override\npublic void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123;\n    // 此处配置FastJson\n    FastJsonConfig config = new FastJsonConfig();\n    FastJsonHttpMessageConverter converter = new FastJsonHttpMessageConverter();\n    config.setSerializerFeatures(\n        SerializerFeature.DisableCircularReferenceDetect,\n        SerializerFeature.WriteMapNullValue,\n        SerializerFeature.WriteNullStringAsEmpty\n    );\n    converter.setFastJsonConfig(config);\n    converters.add(converter);\n&#125;\n\n\n*返回Map集合时，最好使用LinkedHashMap来保证Json内数据顺序不会乱掉\n\n\n○获得请求参数\n\n\nspring自动注入方法的参数中\n限制：基本类型、数组和 Javabea(POJO)。集合对象（List等）需要包装到Bean中才能自动注入。当方法参数名与请求参数名一致时不需要加@RequestParam\n\n\n@RequestBody直接接收request的参数数据\n注释在参数上，一般用于非表单的数据，如application/json、application/xml\n用Json格式的数组作为请求参数，可以通过该标签直接注入到集合类型的方法参数中。\n\n\n获得Restful风格的请求参数\n使用@PathVariable获取，具体使用如下\n@RequsetMapping(&quot;/api/&#123;id&#125;/&#123;name&#125;&quot;)\npublic void testController(@PathVariable(&quot;id&quot;) int id, @PathVariable(&quot;name&quot;) Stirng name) &#123;&#125;\n\n\n获取请求头\n使用@RequstHeader(name)在方法参数中注入。\n@CookieValue直接获取Cookie数据。\n\n\n○文件上传\nPost Content类型为 Multipart/form-data时，需要借助第三方工具简化获取参数的过程。\n导入maven依赖 commons-io、commons-fileupload\nSpringMvc获取到上传的文件时，会打包成MulitpartFile对象，因此用于获取文件的Controller方法需要有此类型的参数。\nMultipartFile\n\ngetOriginFilename()获取文件名\ntransferTo(File)通过IO保存本地或其他服务器\n\n○自定义类型转换器\n实现 Convert&lt;S,D&gt; 接口，并配置到SpringMvc中。接口泛型分别为转换前类型和转换后类型。\n&lt;bean id=&quot;&quot; class=&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;&gt;\n\t&lt;property name=&quot;converters&quot;&gt;\n    \t&lt;list&gt;\n        \t&lt;bean id=&quot;&quot; class=&quot;&quot;&gt;&lt;/bean&gt;\n        &lt;/list&gt;\n    &lt;/property&gt;\n&lt;/bean&gt;\n&lt;mvc:annotation-driven conversion-service=&quot;&quot;/&gt;\n○静态资源访问\n当 spring-mvc 的 dispatcher-servlet 路径配置为/，访问资源时也会去寻找Handler，无法访问到资源文件。解决方法有两种，第一种是配置资源文件的映射，第二种是交由tomcat来寻找资源文件。\n\n\nXML配置\n&lt;!--1.配置资源文件的映射--&gt;\n&lt;mvc:resource mapping=&quot;url&quot; location=&quot;path&quot; /&gt;\n&lt;!--2.启用默认servlet-handler管理资源文件--&gt;\n&lt;mvc:default-servlet-handler /&gt;\n\n\n注解、类配置\n在Mvc配置类中继承WebMvcConfigurer接口，实现以下方法\n@Override\n public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) &#123;\n     configurer.enable();\n &#125;\n\n\n○Session管理\nSpringMvc可以使用注解对Session进行一些简单的管理操作，如向session域中存入数据等。\n\n\n方法一：\n在Controller方法中使用HttpSession对象作为参数，Spring会自动注入。HttpSession能够同时完成添加、删除、查询Attribute的功能。\n\n\n方法二：\n在Controller类上使用@SessionAttributes并指定参数为该类需要使用的AttributeNames，然后方法上的参数就可以使用@ModelAttribute(name)注入Session域的数据。在方法参数中使用Model类型，Spring会把该类的所有Session注入到Model对象中，因此也能够获取Session中的值，同时能够向Session中添加值。需要注意的是，使用该方法清除Session时，需要使用SessionStatus（作为方法参数，spring自动注入）的SetComplete()来清除，并且只会清除@SessionAttributes中标记的键值对。\n\n\n✋Spring官方文档中提出，对于用户登录验证的session最好使用方法一\n○拦截器 Interceptor\n与Filter过滤器类似，用于预处理和后处理，原理为AOP。只对控制器方法进行拦截，不拦截资源访问\n○自定义拦截器\n实现HandlerInterceptor接口，并进行配置。\n\n\n类配置\n@Override\npublic void addInterceptors(InterceptorRegistry registry)&#123;\n    registry.addInterceptor(interceptor).addPathPatterns(&quot;/&quot;);\n&#125;\n\n\nxml配置\n&lt;mvc:interceptors&gt;\n\t&lt;mvc:interceptor&gt;\n        &lt;mvc:mapping path=&quot;&quot;/&gt;\n    \t&lt;bean/&gt;\n    &lt;/mvc:interceptor&gt;\n&lt;/mvc:interceptors&gt;\n\n\nHandlerInterceptor\n// 执行前拦截\npublic boolean preHandle(req, resp, handler);\t\n// 执行后，返回前拦截\npublic void postHandle(req,resp, handler, modelAndView);\n// 流程完毕后拦截\npublic void afterCompletion(req, resp, handler, exception)\n\npreHandle返回为 True 时，后续操作才能执行。\nHandler为控制器方法执行对象（Method）\n\n\n\n○拦截器执行顺序\n多个拦截器执行时，并非串行，而是嵌套的，也就是说拦截器执行链最后执行的方法时第一个拦截器的afterCompletion。执行的顺序与配置的顺序有关，先配置先执行。\n○异常处理机制\n把异常处理抽取出来，通过异常处理组件统一解决，在SpringMvc中异常处理可以由DispatcherServlet调用响应组件处理。\n○异常处理器\nHandlerExceptionResolver\n\n\nSimpleMappingExceptionResolver\n框架自带的实现类。Mapping——发生异常时跳转到异常视图，映射关系通过配置完成。\n&lt;bean class=&quot;org.xx.x.SimpleMappingExceptionResolver&quot;&gt;\n\t&lt;property name=&quot;defalutErrorView&quot; vlaue=&quot;&quot;/&gt;\n    &lt;property name=&quot;exceptionMappings&quot;&gt;\n    \t&lt;map&gt;\n        \t&lt;entry key=&quot;&quot; value=&quot;&quot;/&gt;\n        &lt;/map&gt;\n    &lt;/property&gt;\n&lt;/bean&gt;\n\n\n○自定义异常处理器\n\n\n异常处理方法\n使用注解@ExceptionHanlder标注在方法上时，该方法为所在类的异常处理方法。\n\n\n异常处理类\n使用注解@ControllerAdvice标注在类上时，该类为全局的异常处理类。类内的方法使用@ExceptionHandler标注的方法将用于处理发生的异常。\n\n\n\n\n\n注解\n说明\n参数\n\n\n\n\n@ExceptionHanlder\n用于方法上，异常处理方法\n可以指定异常类，表示只处理个别异常\n\n\n@ControllerAdvice\n用于类上，全局的异常处理类\n无\n\n\n\n*异常处理方法，会被当做一个Controller处理，因此其返回值最终会包装成ModelAndView对象，所以可以使用 @ResponseBody注解\n○使用MockMvc集成Junit\n由于SpringMvc面向web层，因此无法直接调用Controller组件进行测试。\n○使用方法\n\n在Junit测试类上注解@WebAppConfiguration引入Web层配置文件\n使用IOC注入WebApplicationContext对象\n使用MockMvcBuilders创建MockMvc对象，需要传入WebApplicationContext初始化\n使用MockMvc进行测试\n\n○MockMvc\nMockMvc主要使用perform()方法向Controller发出请求，无需启动Tomcat服务器。perfrom方法的参数由MockMvcRequestBuilders创建，并返回一个ResultActions对象。\n\nMockMvcRequestBuilders：创建一个模拟请求，有get或post类型，能够设置请求体和请求头参数\nResultActions：通常使用andDo方法输出请求和响应的所有信息，执行andReturn返回MvcResult结果对象\nMvcResult：结果对象，包含request和response信息\n\n测试样例：\n@Test\npublic void test3() throws Exception&#123;\n    MvcResult res = mockMvc.perform(\n        MockMvcRequestBuilders\n        .post(&quot;/user/login&quot;)\n        .contentType(MediaType.APPLICATION_FORM_URLENCODED)\n        .characterEncoding(&quot;UTF-8&quot;)\n        .param(&quot;userName&quot;, &quot;zhangsan&quot;)\n        .param(&quot;password&quot;, &quot;123&quot;)\n    ).andDo(MockMvcResultHandlers.print()).andReturn();\n    System.out.println(res.getResponse().getContentAsString());\n&#125;\n○Mybatis-Spring\n前置-关于Mybatis的详细内容：Mybatis原始教程\nMaven：mybatis-spring\n○IOC注入\n将Mybatis的SqlSessionFactory等对象配置到SpringIOC容器中。\n\n\n配置SqlSessionFactory，主要是配置其数据源dataSource和核心配置文件configLocation（非必须）\n\n\nmapper组件扫描\n注解方式：\n\n@MapperScan(basepackage=&quot;&quot;)\n\n简洁方式：\n\n&lt;mybatis:scan base-package=&quot;&quot; /&gt;，这个方式不需要额外注解，但是也支持配置自定义注解来限制其扫描范围，指定annotation为自定义的注解即可。以上两种方法将映射器(DAO)z注入到SpringIOC时，默认使用首字母小写作为Bean的名称，可以在自定义注解中设置org.springframework.stereotype.Component 这样的注解既可以作为标记，也可以作为一个名字提供器来使用了。\n\n经典方式（不推荐使用了）：\n\n\n&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;\n\t&lt;property name=&quot;basePackage&quot; value=&quot;xx.xx&quot;/&gt;\n&lt;/bean&gt;\n\n\n\n\n\n配置完毕后即可使用依赖注入直接创建DAO/Mapper接口对象。\n○事务控制\n配置事务管理器transactionManager和事务增强，同样可以使用注解，同上文。配置完成后就可以像使用JdbcTempelate一样进行事务管理。\n○ExtraDetail\n○Properties/ResourceBundle\nproperties是一种键值对key=value储存文件，Java中自带的Properties类可以简单的读写properties文件，但是ResourceBundle类更好的支持了不同的语言，比前者要好一点。\n○Restful\nRestful是一种软件架构、设计风格，提供了一些原则和约束，可以帮助软件设计变得更加简介有层次，更易于实现缓存机制等。Restful风格表现为“url+请求方式”来表现一次HTTP请求，特点是请求参数用/接在url后面，而不再使用?来表示请求参数。如：http://url/api?id=1使用restful风格后应该是http://url/api/1。\nRestful规定请求方式具有如下几个含义:\n\nGET 表示获取\nPOST 表示新建\nPUT 表示更新\nDELETE 表示删除\n\n○FastJson\n由阿里巴巴开发的Json转化驱动。其中FastJsonHttpMessageConverter可以用于SpringMvc的消息转换器中。\n\n@JSONType: 可以标注在类上，通过指定orders参数可以决定转化该类时解析属性的顺序。\n@JSONFiled: 标注在成员变量上，可以指定转化后名称以及转化顺序。\n\n○五、⛵️SpringBoot\n\n\n\n被代理的类 ↩︎\n\n目标对象被增强的方法 ↩︎\n\npointCut 目标对象的方法 ↩︎\n\n\n\n","tags":["web","java"]}]